#line 13 "/usr/vacpp/include/iostream"
#pragma info(none)

#  pragma report(level, E)

#pragma info(restore)
#line 46
#pragma object_model(compat)
#line 51
  #pragma namemangling(v7)
#line 13 "/usr/vacpp/include/istream"
#pragma info(none)

#  pragma report(level, E)

#pragma info(restore)
#line 46
#pragma object_model(compat)
#line 51
  #pragma namemangling(v7)
#line 13 "/usr/vacpp/include/ostream"
#pragma info(none)

#  pragma report(level, E)

#pragma info(restore)
#line 46
#pragma object_model(compat)
#line 20 "/usr/vacpp/include/yvals.h"
  #pragma info(none)

    #pragma report(level, E)

  #pragma info(restore)
#line 54
typedef void* __xlocale_ptr;
#line 107
namespace std {
#line 110
  typedef bool _Bool;
#line 201
  class _Lock;

  class _Lockit
          {        
  public:
          enum _Mux {_Loc, _Mal, _Str, _Nolock = 0xFFFF};
          _Lockit(int);
          ~_Lockit();
  private:
          _Lock *_L;
          };
#line 747
};
#line 750
  #pragma info(none)

    #pragma report(pop)

  #pragma info(restore)
#line 51 "/usr/vacpp/include/ostream"
#pragma namemangling(v5)
#line 13 "/usr/vacpp/include/ios"
#pragma info(none)

#  pragma report(level, E)

#pragma info(restore)
#line 46
#pragma object_model(compat)
#line 51
  #pragma namemangling(v7)
#line 13 "/usr/vacpp/include/xlocnum"
#pragma info(none)

#  pragma report(level, E)

#pragma info(restore)
#line 46
#pragma object_model(compat)
#line 51
  #pragma namemangling(v7)
#line 13 "/usr/vacpp/include/cerrno"
#pragma info(none)

#  pragma report(level, E)

#pragma info(restore)
#line 31
#pragma object_model(compat)
#line 35
  #pragma namemangling(v7)
extern "C" {
}
extern "C" {
}
extern "C" {
#line 62 "/usr/include/errno.h"
extern int errno;
#line 70
extern	char	*sys_errlist[];
extern	int	sys_nerr;
}
#line 61 "/usr/vacpp/include/cerrno"
#pragma namemangling()
#pragma object_model(pop)
#line 68
#pragma info(none)

#  pragma report(pop)

#pragma info(restore)
#line 13 "/usr/vacpp/include/climits"
#pragma info(none)

#  pragma report(level, E)

#pragma info(restore)
#line 31
#pragma object_model(compat)
#line 35
  #pragma namemangling(v7)
extern "C" {
}
extern "C" {
#line 35 "/usr/include/sys/limits.h"
extern "C" {
}
extern "C" {
#line 234 "/usr/include/float.h"
	extern  unsigned   int SINFINITY;
	extern  unsigned   int _DBLINF[2];
	extern  unsigned   int SQNAN;
	extern  unsigned   int DQNAN[2];
	extern  unsigned   int SSNAN;
	extern  unsigned   int DSNAN[2];
#line 265
typedef	unsigned short fprnd_t;
#line 274
fprnd_t fp_read_rnd(void);
fprnd_t fp_swap_rnd(fprnd_t rnd);
}
extern "C" {
#line 465 "/usr/include/sys/limits.h"
}
}
extern "C" {
}
#line 61 "/usr/vacpp/include/climits"
#pragma namemangling()
#pragma object_model(pop)
#line 68
#pragma info(none)

#  pragma report(pop)

#pragma info(restore)
#line 13 "/usr/vacpp/include/cstdio"
#pragma info(none)

#  pragma report(level, E)

#pragma info(restore)
#line 39
#pragma object_model(compat)
#line 43
  #pragma namemangling(v7)
extern "C" {
#line 47 "/usr/include/stdio.h"
extern "C" {
#line 73
typedef unsigned long	size_t;
#line 82
typedef long	fpos_t;
#line 86
typedef long long fpos64_t;
#line 152
typedef struct {
	unsigned char	*_ptr;
	int	_cnt;
	unsigned char	*_base;
	unsigned char   *_bufendp;
	short	_flag;
	short	_file;
	int	__stdioid;
	char	*__newbase;
	void	*_lock;
} FILE;
#line 168
extern FILE	_iob[16];
#line 181
extern size_t 		fread(void *restrict, size_t, size_t, FILE *restrict);
extern size_t		fwrite(const void *restrict, size_t, size_t,FILE *restrict);
}
extern "C" {
#line 62 "/usr/include/va_list.h"
typedef	char *va_list;
}
extern "C" {
#line 192 "/usr/include/stdio.h"
extern int  vscanf(const char *restrict, va_list);
extern int  vfscanf(FILE *restrict, const char *restrict, va_list);
extern int  vsscanf(const char *restrict, const char *restrict, va_list);
#line 243
extern int	__flsbuf(unsigned char, FILE *);
extern int	__filbuf(FILE *);
extern int 	ferror(FILE *);
extern int 	feof(FILE *);
extern void 	clearerr(FILE *);
extern int 	putchar(int);
extern int 	getchar(void);
extern int 	putc(int, FILE *);
extern int 	getc(FILE *);
extern int	remove(const char *);
extern int	rename(const char *, const char *);
extern FILE 	*tmpfile(void);
extern char 	*tmpnam(char *);
extern int 	fclose(FILE *);
extern int 	fflush(FILE *);
extern FILE *	fopen(const char *restrict, const char *restrict);
extern FILE *	freopen(const char *restrict, const char *restrict, FILE *restrict);
extern void 	setbuf(FILE *restrict, char *restrict);
extern int 	setvbuf(FILE *restrict, char *restrict, int, size_t);
extern int	fprintf(FILE *restrict, const char *restrict, ...); 
extern int	fscanf(FILE *restrict, const char *restrict, ...);
extern int	printf(const char *restrict, ...); 
extern int	scanf(const char *restrict, ...); 
extern int	sprintf(char *restrict, const char *restrict, ...); 

extern int	snprintf(char *restrict, size_t, const char *restrict, ...);

extern int	sscanf(const char *restrict, const char *restrict, ...); 
#line 273
extern int	vfprintf(FILE *restrict, const char *restrict, va_list);
extern int	vprintf(const char *restrict, va_list); 
extern int	vsprintf(char *restrict, const char *restrict, va_list);

extern int	vsnprintf(char *restrict, size_t, const char *restrict, va_list);
#line 290
extern int 	fgetc(FILE *);
extern char *	fgets(char *restrict, int, FILE *restrict);
extern int 	fputc(int, FILE *);
extern int 	fputs(const char *restrict, FILE *restrict);
extern char 	*gets(char *);
extern int 	puts(const char *);
extern int	ungetc(int, FILE *);
extern int	fgetpos(FILE *restrict, fpos_t *restrict);
extern int 	fseek(FILE *, long int, int);
extern int	fsetpos(FILE *, const fpos_t *);
extern long	ftell(FILE *);
extern void	rewind(FILE *);
extern void 	perror(const char *); 
#line 308
extern int	getc_unlocked(FILE *);
extern int	getchar_unlocked(void);
extern int	putc_unlocked(int, FILE *);
extern int	putchar_unlocked(int);
}
extern "C" {
#line 43 "/usr/include/sys/types.h"
extern "C" {
}
extern "C" {
}
extern "C" {
}
extern "C" {
#line 45 "/usr/include/sys/inttypes.h"
extern "C" {
}
extern "C" {
#line 33 "/usr/include/stdint.h"
extern "C" {
#line 45
typedef signed char		int8_t;
typedef signed short		int16_t;
typedef signed int		int32_t;
#line 52
typedef	signed long long	int64_t;
#line 56
typedef unsigned char		uint8_t;
typedef unsigned short		uint16_t;
typedef unsigned int		uint32_t;
#line 64
typedef unsigned long long	uint64_t;
#line 74
typedef int64_t			intmax_t;
typedef uint64_t		uintmax_t;
#line 86
typedef signed long		intptr_t;
typedef unsigned long		uintptr_t;
#line 93
typedef signed char		int_least8_t;
typedef signed short		int_least16_t;
typedef signed int		int_least32_t;
#line 100
typedef signed long long	int_least64_t;
#line 104
typedef unsigned char		uint_least8_t;
typedef unsigned short		uint_least16_t;
typedef unsigned int		uint_least32_t;
#line 111
typedef unsigned long long	uint_least64_t;
#line 121
typedef signed char	int_fast8_t;
typedef int16_t		int_fast16_t;
typedef int32_t		int_fast32_t;
typedef unsigned char	uint_fast8_t;
typedef uint16_t	uint_fast16_t;
typedef uint32_t	uint_fast32_t;

typedef int64_t		int_fast64_t;
typedef uint64_t	uint_fast64_t;
#line 290
}
}
extern "C" {
#line 58 "/usr/include/sys/inttypes.h"
typedef struct {
	intmax_t quot;
	intmax_t rem;
} imaxdiv_t;
#line 64
extern intmax_t __strtollmax(const char * restrict, char ** restrict, int);

static intmax_t
strtoimax (const char * restrict __nptr, char ** restrict __endptr, int __base) {
	return __strtollmax (__nptr, __endptr, __base);
}
#line 89
extern intmax_t imaxabs(intmax_t);
extern imaxdiv_t imaxdiv (intmax_t, intmax_t); 
extern uintmax_t strtoumax(const char * restrict, char ** restrict, int);
#line 101
extern intmax_t wcstoimax(const wchar_t * restrict, wchar_t ** restrict, int );
extern uintmax_t wcstoumax(const wchar_t * restrict, wchar_t ** restrict, int);
#line 112
typedef int32_t         intfast_t;
typedef uint32_t        uintfast_t;
#line 563
typedef signed long	__long32_t;
typedef unsigned long	__ulong32_t;
#line 577
typedef signed int	__long64_t;
typedef unsigned int	__ulong64_t;
#line 590
typedef signed int	int32long64_t;
typedef unsigned int	uint32long64_t;
#line 603
typedef signed long	long32int64_t;
typedef unsigned long	ulong32int64_t;
#line 618
typedef signed char		int8;
typedef signed short		int16;
typedef signed int		int32;
#line 625
typedef	signed long long	int64;
#line 629
typedef unsigned char		u_int8;
typedef unsigned char		u_int8_t;
typedef unsigned short		u_int16;
typedef unsigned short		u_int16_t;
typedef unsigned int		u_int32;
typedef unsigned int		u_int32_t;
#line 640
typedef unsigned long long	u_int64;
typedef unsigned long long	u_int64_t;
#line 654
}
}
extern "C" {
}
extern "C" {
}
extern "C" {
#line 88 "/usr/include/sys/types.h"
typedef long		ptrdiff_t;
#line 102
typedef unsigned int	wctype_t;
#line 128
typedef int		time_t;
#line 135
typedef int		clock_t;
#line 151
typedef	unsigned char	uchar_t;
#line 154
typedef	unsigned short	ushort_t;
typedef	unsigned int	uint_t;
typedef unsigned long	ulong_t;
#line 160
typedef	signed long	ssize_t;
#line 166
typedef int		level_t;
typedef	__long64_t	daddr_t;	 
typedef	int		daddr32_t;	 

typedef	int64_t		daddr64_t;	 

typedef	char *		caddr_t;	 
typedef	__ulong64_t	ino_t;		 
typedef	uint_t 		ino32_t;	 

typedef	uint64_t 	ino64_t;	 

typedef short		cnt_t;
#line 183
typedef	__ulong64_t	dev_t;		 

typedef uint_t 		dev32_t;	 

typedef uint64_t 	dev64_t;	 

typedef	int		chan_t;		 
typedef int		time32_t;		 
typedef int		pid32_t;		 
typedef int		tid32_t;		 

typedef uint64_t     pid64_t;      
typedef uint64_t     tid64_t;      

typedef int64_t      time64_t;     
#line 208
typedef void * __ptr32;
typedef char * __cptr32;
#line 212
typedef int soff_t;			 
#line 219
typedef long		off_t;		 
#line 224
typedef long long 	off64_t;
#line 227
typedef	long		paddr_t;
#line 232
typedef	int32long64_t	key_t;
#line 237
typedef __long64_t	timer_t;	 

typedef int		timer32_t;	 

typedef int64_t 	timer64_t;	 

typedef	short		nlink_t;
#line 248
typedef	uint_t		mode_t;		 
#line 254
typedef uint_t		uid_t;		 
typedef uint_t		gid_t;		 
typedef uint_t		rid_t;		 
#line 259
typedef ushort_t        authnum_t;       
typedef	__ptr32 	mid_t;		 
#line 264
typedef	int32long64_t	pid_t;		 
#line 267
typedef __long64_t	tid_t;		 
typedef char		slab_t[12];	 
typedef long		mtyp_t;		 
typedef int             boolean_t;
typedef int     	crid_t;
#line 277
typedef __long64_t	blkcnt_t;  
#line 283
typedef __long64_t	blksize_t;  
#line 288
typedef int		blkcnt32_t;  
typedef int		blksize32_t;  

typedef uint64_t	blkcnt64_t;  
typedef uint64_t	blksize64_t;  
#line 296
typedef ulong_t 	fsblkcnt_t;	 
typedef ulong_t		fsfilcnt_t;	 
#line 301
	typedef	int		wint_t;		 
#line 305
typedef uint32long64_t	id_t;		 
typedef unsigned int	useconds_t;	 
typedef signed   int	suseconds_t;	 
#line 311
typedef long long       clockid_t;       
#line 320
typedef struct sigset_t	{
#line 329
	unsigned int losigs;
	unsigned int hisigs;
#line 336
} sigset_t;

typedef struct {

	unsigned int losigs, hisigs;
#line 344
} sigset32_t;
#line 347
typedef struct {
	uint64_t ss_set[4];
} sigset64_t;
#line 358
typedef int signal_t;
#line 363
typedef struct fsid_t {
#line 368
	unsigned int val[2];
#line 373
} fsid_t;
#line 381
typedef struct fsid64_t {

	uint64_t val[2];
#line 387
} fsid64_t;

typedef void *pthread_attr_t;
typedef	void *pthread_condattr_t;	
typedef	void *pthread_mutexattr_t;
#line 394
typedef	void *pthread_rwlockattr_t;
#line 398
typedef	void *pthread_barrierattr_t;
#line 401
typedef unsigned int pthread_t;
typedef unsigned int pthread_key_t;

typedef struct
{
#line 409
	int	__mt_word[13];

}
pthread_mutex_t;

typedef struct
{
#line 419
	int	__cv_word[11];

}
pthread_cond_t;

typedef struct
{
#line 429
        int     __on_word[28];

}
pthread_once_t;
#line 435
typedef struct
{
#line 440
	int	__sp_word[6];

}
pthread_spinlock_t;

typedef struct
{
#line 450
	int	__br_word[8];

}
pthread_barrier_t;
#line 457
typedef struct
{
#line 462
	int	__rw_word[52];

}
pthread_rwlock_t;
#line 469
typedef void *trace_attr_t;
typedef unsigned trace_event_id_t;
typedef unsigned trace_id_t;

typedef uint64_t trace_event_set_t;
#line 481
typedef struct  _quad { int val[2]; } quad;
}
extern "C" {
}
extern "C" {
#line 35 "/usr/include/sys/vm_types.h"
typedef long            vmid_t;          
typedef ulong_t		vmhandle_t;	 
#line 42
typedef int             vmid32_t;        
typedef uint_t		vmhandle32_t;	 
#line 51
typedef long32int64_t	kvmid_t;	 
typedef ulong32int64_t	kvmhandle_t;	 
#line 62
typedef long long	vmid64_t;
typedef long long	rpn64_t;
typedef long long       cnt64_t;         
typedef long long       psize_t;         
#line 73
typedef int32long64_t	vmidx_t;	 

typedef uint32long64_t  vmfkey_t;        

typedef uint32long64_t  vmprkey_t;       
typedef int32long64_t	vmkey_t;	 
typedef int32long64_t	vmhwkey_t;       
typedef int             vmhkey_t;        
typedef int32long64_t	vpn_t;		 
typedef int32long64_t	rpn_t;		 

typedef unsigned long   ptex_t;          
typedef unsigned long   swhatx_t;        

typedef uint32long64_t  esid_t;          
#line 92
typedef ushort_t	aptx_t;		 
#line 95
typedef int             pdtx_t;          
typedef short           psx_t;           
typedef ushort_t        pshift_t;        
typedef ushort_t        sshift_t;        
#line 103
typedef uint_t		vm_mpss_t;

typedef int             unidx_t;         
typedef int             snidx_t;         
typedef int             vmnodeidx_t;     

typedef int		kvpn_t;		 

   typedef int		krpn_t;		 

typedef int32long64_t   vmsize_t;	 

typedef int32long64_t   vmm_lock_t;      
#line 123
typedef unsigned long ureg_t;		 
#line 142
typedef struct

vmaddr_t

{		 

	vmhandle_t	srval;		 
	caddr_t		offset;		 
#line 154
} vmaddr_t;
#line 158
typedef struct

adspace_t

{		 

	ulong32int64_t	alloc;		 
	vmhandle_t	srval[16];	 
#line 170
} adspace_t;
#line 187
typedef struct
adspace32_t
{
        uint_t alloc;
        uint_t srval[16];
} adspace32_t;
#line 200
typedef enum _MR_ATTR_TYPE {
  BadAttr = 0,
  VirtAddr = 1
} MR_ATTR_TYPE;

typedef enum _MR_LABEL_TYPE {
  BadMem = 0,
  FreeMem = 1,
  IPLCB = 2,
  RMALLOC = 3,
  PM_HEAP = 4,
  RTAS_HEAP = 5,
  TCE_TABLE = 6,
  IO_SPACE = 7,
  HUGE_PAGE = 8
} MR_LABEL_TYPE;
#line 220
typedef struct {
	unsigned long long	mr_addr;	 
	unsigned long long	mr_size;	 
	unsigned char	mr_att;			 
	unsigned char	mr_label;		 
	unsigned short	mr_nodeid;		 
	unsigned short  mr_flags;                
	char	reserved[2];			 
} iplcb_map_reg_t;
#line 261
typedef vmhandle_t      vmlpghandle_t;     
}
extern "C" {
#line 48 "/usr/include/sys/m_types.h"
typedef struct label_t
{					 
    long __opaque[25];
} label_t;

typedef int32long64_t	ext_t;		  
}
extern "C" {
#line 534 "/usr/include/sys/types.h"
typedef unsigned long long ptr64_t;
#line 544
typedef unsigned long long __ptr64;
typedef unsigned long long __cptr64;
#line 554
typedef ushort_t	UniChar;
typedef uint_t		UTF32Char;
#line 560
typedef	uchar_t		uchar;
typedef	ushort_t	ushort;
typedef	uint_t		uint;
typedef ulong_t		ulong;

typedef	struct { int r[1]; } *	physadr_t;
typedef	physadr_t	physadr;
#line 569
typedef	unsigned char	u_char;
typedef	unsigned short	u_short;
typedef	unsigned int	u_int;
typedef	unsigned long	u_long;

typedef	int	swblk_t;
#line 579
struct sigset	{
#line 583
	unsigned int losigs;
	unsigned int hisigs;

};
#line 589
struct fsid {

	unsigned int	val[2];
#line 595
};
#line 604
struct fileid {			 
	uint_t	fid_len;
	ino32_t	fid_ino;
	uint_t	fid_gen;
	char	fid_x[20 - (sizeof(ino32_t) + 2) - sizeof(uint_t)];
};
#line 625
struct fid {
	uint_t	fid_len;
	char	fid_data[20];
};
typedef struct fid fid_t;
#line 632
struct fhandle {
	char x[32];		 
};
typedef struct fhandle fhandle_t;

struct filehandle {			 
	fsid_t		fh_fsid;		 
	struct fileid	fh_fid;			 
};
#line 649
struct unique_id {
       __ulong32_t word1;
       __ulong32_t word2;
       __ulong32_t word3;
       __ulong32_t word4;
};
typedef struct unique_id unique_id_t;
#line 681
typedef	long long  offset_t;		 
#line 691
typedef long long ssize64_t;
#line 697
typedef long long longlong_t;         
typedef unsigned long long u_longlong_t;
#line 701
typedef unsigned int class_id_t;
#line 705
typedef uint_t          liobn_t;        

typedef unsigned long long unit_addr_t;    
#line 721
typedef uint8_t			eye_catch1b_t;
typedef uint16_t		eye_catch2b_t;
typedef uint32_t		eye_catch4b_t;

typedef uint64_t		eye_catch8b_t;
#line 733
typedef unsigned long		eye_catch_t;
#line 738
typedef unsigned long long size64_t;    
#line 745
}
}
extern "C" {
#line 432 "/usr/include/stdio.h"
extern int 	fileno(FILE *);
extern FILE 	*fdopen(int,const char *);
extern char	*ctermid(char *);
extern FILE 	*popen(const char *, const char *);
extern int 	pclose(FILE *);
#line 439
extern void	flockfile(FILE *);
extern void	funlockfile(FILE *);
extern int	fseeko(FILE *, off_t, int);
extern off_t	ftello(FILE *);
extern int	ftrylockfile(FILE *);
extern void	funlockfile(FILE *);
#line 460
extern	char	*optarg;
extern	int	opterr;
extern	int	optind;
extern	int	optopt;
#line 479
extern int 	getw(FILE *);
extern int      getopt(int, char * const [], const char*);
extern char     *cuserid(char *);
extern int 	putw(int, FILE *);

extern char 	*tempnam(const char*, const char*);
#line 498
extern int fgetpos64(FILE *, fpos64_t *);
extern FILE *fopen64(const char *, const char *);
extern FILE *freopen64(const char *, const char *, FILE *);
extern int fseeko64(FILE *, off64_t, int);
extern int fsetpos64(FILE *, const fpos64_t *);
extern off64_t ftello64(FILE *);
#line 510
extern void setbuffer(FILE *, char *, size_t);
extern void setlinebuf(FILE *);
#line 575
}
#line 579
inline int ferror(FILE * _p)
{
	return ((_p)->_flag & 0040);
}
#line 587
inline void clearerr(FILE * _p)
{
	((void) ((_p)->_flag &= ~(0040 | 0020)));
}
#line 595
inline int feof(FILE * _p) 
{
	return ((_p)->_flag & 0020); 
}
}
#line 69 "/usr/vacpp/include/cstdio"
namespace std {
#line 73
using ::size_t; using ::fpos_t; using ::FILE;
using ::clearerr; using ::fclose; using ::feof;
using ::ferror; using ::fflush; using ::fgetc;
using ::fgetpos; using ::fgets; using ::fopen;
using ::fprintf; using ::fputc; using ::fputs;
using ::fread; using ::freopen; using ::fscanf;
using ::fseek; using ::fsetpos; using ::ftell;
using ::fwrite; using ::gets; using ::perror;
using ::printf; using ::puts; using ::remove;
using ::rename; using ::rewind; using ::scanf;
using ::setbuf; using ::setvbuf; using ::sprintf;
using ::sscanf; using ::tmpfile; using ::tmpnam;
using ::ungetc; using ::vfprintf; using ::vprintf;
using ::vsprintf;
using ::getc; using ::getchar;
using ::putc; using ::putchar;
};
#line 105
#pragma namemangling()
#pragma object_model(pop)
#line 112
#pragma info(none)

#  pragma report(pop)

#pragma info(restore)
#line 13 "/usr/vacpp/include/cstdlib"
#pragma info(none)

#  pragma report(level, E)

#pragma info(restore)
#line 39
#pragma object_model(compat)
#line 43
  #pragma namemangling(v7)
#line 20 "/usr/vacpp/include/stdlib.h"
# pragma info(none)
extern "C" {
#line 39 "/usr/include/stdlib.h"
      inline int abs (int );
#line 43
      inline long labs (long );
#line 46
      inline long long llabs(long long);
#line 49
      inline void imul_dbl(long ,long ,long *);
      inline void umul_dbl(unsigned long ,unsigned long ,
                    unsigned long *);
#line 56
extern "C" {
#line 91
typedef struct div_t  {	         
	int quot;                
	int rem;                 
} div_t;

typedef struct ldiv_t  {	 
	long int quot;           
	long int rem;            
} ldiv_t;
#line 106
extern size_t __getmbcurmax (void);
extern int __getmaxdispwidth (void);
#line 117
        extern double   strtod(const char * restrict, char ** restrict);        extern long int strtol(const char * restrict, char ** restrict,
int);
        extern unsigned long int strtoul(const char * restrict, char ** restrict, int);
#line 130
	extern void     	_Exit(int);
	extern float    	____strtof(const char * restrict, char ** restrict);
#line 139
typedef struct lldiv_t {
     long long int quot;  
     long long int rem ;  
} lldiv_t;
#line 152
extern long long int    atoll(const char *);
extern long long int llabs( long long int );
extern lldiv_t lldiv( long long int, long long int ); 

extern long long int strtoll(
     const char * restrict,  
     char ** restrict,       
     int );                      
extern unsigned long long int strtoull(
     const char * restrict,  
     char ** restrict,       
     int );                      
#line 173
static long double
strtold(const char * restrict __a, char ** restrict __b) {
	return ((long double)strtod (__a, __b));
}
#line 192
	extern int	 	mblen(const char *, size_t);
	extern size_t 	mbstowcs(wchar_t * restrict, const char * restrict, size_t);
	extern int		mbtowc(wchar_t * restrict, const char * restrict, size_t);
	extern size_t	wcstombs(char * restrict, const wchar_t * restrict, size_t);
	extern int		wctomb(char *, const wchar_t);
#line 248
	extern double 	atof(const char *);
	extern int 	atoi(const char *);
	extern long int atol(const char *);
	extern int 	rand(void);
	extern void	srand(unsigned int);
	extern void 	*calloc(size_t, size_t);
	extern void	free(void *);
	extern void	*malloc(size_t);
	extern void 	*realloc(void *, size_t);
	extern void	abort(void);
	extern int	atexit(void (*)(void));
	extern void	exit(int);
	extern char	*getenv(const char *);
	extern int 	system(const char *);
	extern void 	*bsearch(const void *, const void *, size_t, size_t, int(*)(const void *,const void *));
	extern void 	qsort(void *, size_t, size_t, int(*)(const void *,const void *));
#line 274
	extern int 	abs(int);
	extern struct div_t	div(int, int);
	extern long int	labs(long int);
	extern struct ldiv_t 	ldiv(long int, long int);
#line 298
extern int posix_memalign(void **,size_t,size_t);
}
extern "C" {
}
extern "C" {
}
extern "C" {
#line 48 "/usr/include/sys/wait.h"
extern "C" {
}
extern "C" {
#line 54 "/usr/include/sys/resource.h"
extern "C" {
}
#line 21 "/usr/vacpp/include/sys/time.h"
struct timestruc_t;
extern "C" {
#line 50 "/usr/include/sys/time.h"
struct timestruc_t;

extern "C" {
#line 93
struct timeval {
	time_t		tv_sec;			 

	suseconds_t	tv_usec;		 
#line 100
};
#line 105
struct timeval32 {
    int32_t tv_sec;      
    int32_t tv_usec; 
};
#line 115
struct timeval64 {
    int64_t tv_sec;	 
    int32_t tv_usec;
#line 121
};
#line 128
struct timezone {
	int		tz_minuteswest;	 
	int		tz_dsttime;	 
};
#line 145
struct	itimerval {
	struct		timeval it_interval; 	 
	struct		timeval it_value; 	 
};
#line 159
extern int getitimer(int, struct itimerval *);
extern int setitimer(int, const struct itimerval *restrict, struct itimerval *restrict);
extern int gettimeofday(struct timeval *restrict, void *restrict);

extern int settimeofday(struct timeval *, struct timezone *);

extern int utimes(const char *, const struct timeval *);
#line 183
typedef struct 

fd_set

{
        long fds_bits[(65534/(sizeof(long) * 8)+1)];   
} fd_set;
#line 195
struct timespec {
	time_t tv_sec;          
	long   tv_nsec;         
};
#line 204
extern int pselect(int, void *restrict, void *restrict, void *restrict, const struct timespec *restrict, const sigset_t *restrict);
#line 224
extern int __fd_select(int, fd_set *restrict, fd_set *restrict, 
			fd_set *restrict, struct timeval *restrict);
static int select(int __fds, 
		fd_set *restrict __readlist,
		fd_set *restrict __writelist,
		fd_set *restrict __exceptlist,
		struct timeval *restrict __timeout)  
		{
			return __fd_select(__fds, __readlist, __writelist,
						__exceptlist, __timeout);
		}
#line 260
extern void     *memset(void *, int, size_t);
#line 363
struct timestruc_t {
        time_t		tv_sec;          
        suseconds_t	tv_nsec;         
};
#line 372
struct timestruc32_t {
    int32_t     tv_sec;          
    int32_t     tv_nsec;         
};
#line 380
struct timestruc64_t {
    int64_t     tv_sec;          
    int32_t     tv_nsec;         
};
#line 395
struct itimerstruc_t {
        struct  timestruc_t it_interval;  
        struct  timestruc_t it_value;     
};
#line 404
struct itimerstruc32_t {
    struct  timestruc32_t it_interval;  
    struct  timestruc32_t it_value;     
};
#line 412
struct itimerstruc64_t {
    struct  timestruc64_t it_interval;  
    struct  timestruc64_t it_value;     
};
#line 427
typedef struct timebasestruct {
	int		flag;     
	unsigned int	tb_high;  
	unsigned int	tb_low;	  
	} timebasestruct_t;	

int read_real_time(timebasestruct_t *, size_t);
int read_wall_time(timebasestruct_t *, size_t);
int time_base_to_time(timebasestruct_t *, size_t);
#line 576
int usleep (unsigned int);
int nsleep (timestruc_t*, timestruc_t*);
}
}
#line 25 "/usr/vacpp/include/sys/time.h"
extern "C" {

int gettimeofday(struct timeval*, void*);
#line 31
int settimeofday(struct timeval*, struct timezone*);
int usleep (unsigned int);
struct itimerval;
int setitimer (int, const itimerval*, itimerval*);
int getitimer (int, itimerval*);
int nsleep (timestruc_t*, timestruc_t*);
}
extern "C" {
#line 85 "/usr/include/sys/resource.h"
typedef unsigned long 	rlim_t;	
struct rlimit {
	rlim_t		rlim_cur;	 
	rlim_t		rlim_max;	 
};
#line 96
typedef unsigned int 	rlim32_t;	

struct rlimit32 {
	rlim32_t	rlim_cur;	 
	rlim32_t	rlim_max;	 
};
#line 110
typedef unsigned long long rlim64_t;
struct rlimit64 {
	rlim64_t	rlim_cur;	 
	rlim64_t	rlim_max;	 
};
#line 155
struct	rusage
{
	struct timeval 	ru_utime;	 
	struct timeval 	ru_stime;	 
	long		ru_maxrss;
	long		ru_ixrss;	 
	long		ru_idrss;	 
	long		ru_isrss;	 
	long		ru_minflt;	 
	long		ru_majflt;	 
	long		ru_nswap;	 
	long		ru_inblock;	 
	long		ru_oublock;	 
	long		ru_msgsnd;	 
	long		ru_msgrcv;	 
	long		ru_nsignals;	 
	long		ru_nvcsw;	 
	long		ru_nivcsw;	 

};
#line 183
struct	rusage64
{
#line 189
	struct timeval ru_utime;	 
	struct timeval ru_stime;	 

	long long	ru_maxrss;
	long long	ru_ixrss;	 
	long long	ru_idrss;	 
	long long	ru_isrss;	 
	long long	ru_minflt;	 
	long long	ru_majflt;	 
	long long	ru_nswap;	 
	long long	ru_inblock;	 
	long long	ru_oublock;	 
	long long	ru_msgsnd;	 
	long long	ru_msgrcv;	 
	long long	ru_nsignals;	 
	long long	ru_nvcsw;	 
	long long	ru_nivcsw;	 
};
#line 212
struct	trusage64
{
	struct timeval64 ru_utime;	 
	struct timeval64 ru_stime;	 
	longlong_t	 ru_maxrss;
	longlong_t	 ru_ixrss;	 
	longlong_t	 ru_idrss;	 
	longlong_t	 ru_isrss;	 
	longlong_t	 ru_minflt;	 
	longlong_t	 ru_majflt;	 
	longlong_t	 ru_nswap;	 
	longlong_t	 ru_inblock;	 
	longlong_t	 ru_oublock;	 
	longlong_t	 ru_msgsnd;	 
	longlong_t	 ru_msgrcv;	 
	longlong_t	 ru_nsignals;	 
	longlong_t	 ru_nvcsw;	 
	longlong_t	 ru_nivcsw;	 
};
#line 236
struct trusage32
{
        struct timeval32 ru_utime;       
        struct timeval32 ru_stime;       
        signed int      ru_maxrss;
        signed int      ru_ixrss;        
        signed int      ru_idrss;        
        signed int      ru_isrss;        
        signed int      ru_minflt;       
        signed int      ru_majflt;       
        signed int      ru_nswap;        
        signed int      ru_inblock;      
        signed int      ru_oublock;      
        signed int      ru_msgsnd;       
        signed int      ru_msgrcv;       
        signed int      ru_nsignals;     
        signed int      ru_nvcsw;        
        signed int      ru_nivcsw;       
};
#line 325
extern int getpriority(int, id_t);
extern int setpriority(int, id_t, int);
extern int getrlimit(int, struct rlimit *);
extern int setrlimit(int, const struct rlimit *);
#line 331
extern int getrlimit64(int, struct rlimit64 *);
extern int setrlimit64(int, const struct rlimit64 *);
#line 340
extern int getrusage(int, struct rusage *);

extern int getrusage64(int, struct rusage64 *);
#line 367
}
}
extern "C" {
}
extern "C" {
#line 69 "/usr/include/sys/signal.h"
extern "C" {
#line 100
extern void (*signal(int, void (*)(int)))(int);
#line 108
extern int raise(int);
#line 111
typedef volatile int sig_atomic_t;  
#line 245
union sigval
{
#line 250
        void *  sival_ptr;	 

        int     sival_int;	 
};
#line 266
typedef struct {
	int si_signo;		 
	int si_errno;		 
	int si_code;		 
#line 280
	pid_t si_pid;		 
#line 283
	uid_t si_uid;		 
#line 307
	void *si_addr;		 
	int si_status;		 
#line 311
	long si_band;		 
#line 314
        union sigval si_value;	 
#line 319
        int __si_flags;
#line 323
        int __pad[6];		 
#line 327
} siginfo_t;
#line 335
struct sigaction {
   union {
#line 343
	void	(*__su_handler)(int);	 
#line 347
	void    (*__su_sigaction) (int, siginfo_t *, void *);
#line 351
    } sa_union;
	sigset_t sa_mask;		 
	int	sa_flags;		 
};
}
extern "C" {
}
extern "C" {
}
extern "C" {
}
extern "C" {
#line 49 "/usr/include/sys/mstsave.h"
struct

mstsave
#line 55
{

	struct mstsave *prev;		 
	label_t		*kjmpbuf;	 
	char		*stackfix;	 
	char		intpri; 	 
	char		backt;		 
	char		rsvd[2];	 
	pid_t		curid;		 

	int		excp_type;	 
	ulong_t		iar;		 
	ulong_t		msr;		 
	ulong_t		cr;		 
	ulong_t		lr;		 
	ulong_t		ctr;		 
	ulong_t		xer;		 
	ulong_t		mq;		 
 	ulong_t		tid;		 
	ulong_t		fpscr;		 
	char		fpeu;		 
	char            fpinfo;          
	uchar		fpscr24_31;	 
	char            pad[1];          
	ulong_t         except[5];	 
	char            pad1[4];         
	ulong_t         o_iar;           
	ulong_t         o_toc;           
	ulong_t         o_arg1;          
	ulong_t		excbranch;	
#line 88
	ulong_t         fpscrx;          
	ulong_t         o_vaddr;         
	ulong_t		cachealign[7];	 
	adspace_t	as;		 
	ulong_t		gpr[32];	 
	double		fpr[32];	 
#line 133
};
#line 140
struct mstsave32
{
	__ptr32		prev;		 
	__ptr32		kjmpbuf;	 
	__cptr32	stackfix;	 
	char		intpri; 	 
	char		backt;		 
	char		rsvd[2];	 
	int		curid;		 

	int		excp_type;	 
	uint_t		iar;		 
	uint_t		msr;		 
	uint_t		cr;		 
	uint_t		lr;		 
	uint_t		ctr;		 
	uint_t		xer;		 
	uint_t		mq;		 
 	uint_t		tid;		 
	uint_t		fpscr;		 
	char		fpeu;		 
	char            fpinfo;          
	uchar_t		fpscr24_31;	 
	char            pad[1];          
	uint_t		except[5];	 
	char            pad1[4];         
	uint_t	     	o_iar;           
	uint_t	     	o_toc;           
	uint_t	     	o_arg1;          
	uint_t		excbranch;	
#line 173
	uint_t	     	fpscrx;          
	uint_t     	o_vaddr;         
	uint_t		cachealign[7];	 
	adspace32_t	as;		 
	uint_t		gpr[32];	 
	double		fpr[32];	 
};
#line 236
extern char __pmap_stack[];
}
extern "C" {
#line 42 "/usr/include/sys/context.h"
extern "C" {
#line 63
typedef struct {
#line 68
	void  *ss_sp;		 
	size_t ss_size;		 
#line 72
	int    ss_flags;	 

	int    __pad[4];	 

} stack_t;
#line 84
typedef struct {
        unsigned long long ss_sp;        
        unsigned long long ss_size;      
        int                ss_flags;     
        int                __pad[4];     
} stack64_t;
#line 95
typedef struct {
	__ptr32 ss_sp;		 
	uint_t ss_size;		 
	int    ss_flags;	 

	int    __pad[4];	 

} stack32_t;
#line 132
struct __context64 {
	unsigned long long	gpr[32]; 	 
	unsigned long long	msr;		 
	unsigned long long	iar;		 
	unsigned long long	lr;		 
	unsigned long long	ctr;		 
	unsigned int		cr;		 
	unsigned int		xer;		 
	unsigned int		fpscr;		 
	unsigned int		fpscrx;		 
        unsigned long long      except[1];       
	double  		fpr[32];	 
	char			fpeu;		 
	char			fpinfo;		 
	char			fpscr24_31;	 
        char                    pad[1];
        int                     excp_type;       
};
#line 185
struct sigcontext64 {
	int  		   sc_onstack;	 
	sigset64_t	sc_mask;	 
	int 		   sc_uerror;	 
	struct __context64 sc_context;	 
};
#line 265
typedef struct {
	unsigned int __v[4];
} __vmxreg_t;

typedef struct __vmx_context {
	__vmxreg_t 	__vr[32];	 
	unsigned int	__pad1[3];	 
	unsigned int	__vscr;		 
	unsigned int	__vrsave;	 
	unsigned int	__pad2[3];	 	
} __vmx_context_t;
#line 305
typedef struct __extctx {
	unsigned int	__flags;	 
	unsigned int	__rsvd1[3];	 
	union {
	    __vmx_context_t	__vmx;	 
	} __u1;

	unsigned int	__ukeys[2];	 
#line 315
	char	__reserved[(4096 - sizeof(__vmx_context_t) - (7 * sizeof(int)))]; 
#line 318
	int		__extctx_magic;   
#line 322
} __extctx_t;
#line 332
struct	__jmpbuf {

	struct	mstsave jmp_context;
#line 338
}; 
#line 365
struct	__jmpbuf32 {
	struct	mstsave32 jmp_context;
}; 
#line 375
struct	__sigcontext {

	int		sc_onstack;	 
#line 381
	sigset_t	sc_mask;	 

	int		sc_uerror;	 
	struct __jmpbuf sc_jmpbuf;	 
#line 395
};
#line 404
typedef struct __jmpbuf   mcontext_t;

typedef struct ucontext_t {
	int	    __sc_onstack;  
#line 412
        sigset_t    uc_sigmask;   
#line 415
        int	    __sc_uerror;   
	mcontext_t  uc_mcontext;   
#line 420
	struct ucontext_t *uc_link; 
#line 423
	stack_t     uc_stack;      
#line 427
	__extctx_t  *__extctx;	   
#line 430
	int	__extctx_magic;   
#line 436
	int	    __pad[2];	   
#line 444
} ucontext_t;
#line 448
typedef struct __jmpbuf32   mcontext32_t;

typedef struct ucontext32_t {
	int	    __sc_onstack;  
        sigset32_t    uc_sigmask;   

        int	    __sc_uerror;   
	mcontext32_t uc_mcontext;  
	__ptr32  uc_link;	   

	stack32_t     uc_stack;    
	__ptr32	    __extctx;	   

	int	__extctx_magic;   
#line 464
	int	    __pad[2];	   
#line 471
} ucontext32_t;
#line 475
}
}
extern "C" {
#line 381 "/usr/include/sys/signal.h"
struct	sigstack {
	void	*ss_sp;			 
	int	ss_onstack;		 
};
#line 474
extern int sigmask(int);
}
extern "C" {
}
extern "C" {
#line 660
struct sigevent {
	union sigval		sigev_value;
	int			sigev_signo;
	int			sigev_notify;
#line 668
	void			(*sigev_notify_function)(union sigval);
	pthread_attr_t *	sigev_notify_attributes;

};
#line 693
struct osigevent {
#line 697
	void		*sevt_value;

	signal_t	sevt_signo;
};
#line 1002
struct	sigvec {
#line 1014
   union {
#line 1021
	void    (*sv_handler)(int);	 
#line 1025
        void    (*sv_sigaction) (int, siginfo_t *, void *);
   } sv_union;
	int     sv_mask;         
	int     sv_flags;

};                           
#line 1089
extern int sigblock(int);
extern int siglocalmask(int, const sigset_t *);
extern int sigvec(int, struct sigvec *, struct sigvec *);
#line 1099
extern int siggetmask(void);
extern int sigsetmask(int);
#line 1142
extern int kill(pid_t, int);
extern int sigprocmask(int, const sigset_t *restrict, sigset_t *restrict);
extern int sigsuspend(const sigset_t *);
#line 1150
extern int sigwait(const sigset_t *restrict, int *restrict);
#line 1154
extern int sigaction(int, const struct sigaction *restrict, struct sigaction *restrict);

extern int sigemptyset(sigset_t *);
extern int sigfillset(sigset_t *);
extern int sigaddset(sigset_t *, int);
extern int sigdelset(sigset_t *, int);
extern int sigismember(const sigset_t *, int);
extern int sigpending(sigset_t *);
#line 1164
extern void (*bsd_signal (int, void (*)(int)))(int); 
extern int killpg(pid_t, int);
extern int sighold(int);
extern int sigignore(int);
extern int siginterrupt(int, int);
extern int sigpause(int);
extern int sigrelse(int);
extern void (*sigset(int, void(*)(int)))(int);

extern int sigaltstack(const stack_t *restrict, stack_t *restrict);

extern int sigstack(struct sigstack *, struct sigstack *);
#line 1180
extern int pthread_kill(pthread_t, int);
extern int pthread_sigmask(int, const sigset_t *, sigset_t *);
extern int sigqueue(pid_t, int, const union sigval);
struct timespec;
extern int sigtimedwait(const sigset_t *restrict, siginfo_t *restrict, const struct timespec *restrict);
extern int sigwaitinfo(const sigset_t *restrict, siginfo_t *restrict);
#line 1209
}
}
extern "C" {
#line 144 "/usr/include/sys/wait.h"
typedef enum {P_ALL, P_PID, P_PGID} idtype_t;
#line 162
extern pid_t wait(int *);

extern pid_t waitpid(pid_t, int *, int);
#line 178
extern int waitid(idtype_t, id_t, siginfo_t *, int);
#line 183
extern pid_t wait3(int *, int, struct rusage *);
#line 188
extern pid_t kwaitpid(int *, pid_t, int, struct rusage *, siginfo_t *);

extern pid_t kwaitpid64(int *, pid_t, int, struct rusage64 *, siginfo_t *);
#line 194
extern pid_t wait364(int *, int, struct rusage64 *);
#line 208
extern pid_t wait4(pid_t, int *, int, struct rusage *);
#line 228
}
}
extern "C" {
#line 394 "/usr/include/stdlib.h"
	extern double 		drand48(void);
	extern double 		erand48(unsigned short[]);
	extern long 		jrand48(unsigned short[]);
	extern void 		lcong48(unsigned short int *);
	extern long 		lrand48(void);
	extern long 		mrand48(void);
	extern long 		nrand48(unsigned short[]);
	extern unsigned short 	*seed48(unsigned short[]);
	extern void 		setkey(const char *);
	extern void 		srand48(long);

	extern int 		putenv(char *);
#line 423
	extern	int	rand_r(unsigned int *);
#line 447
	extern long a64l(const char *);
	extern char *ecvt(double, int, int *, int *);
	extern char *fcvt(double, int, int *, int *);
	extern char *gcvt(double, int, char *);
	extern int  getsubopt(char **, char *const *, char **);
	extern int  grantpt(int);
	extern char *initstate(unsigned, char *, size_t);
	extern char *l64a(long);
	extern char *mktemp(char *);
	extern int  mkstemp(char *);
#line 461
	extern int  mkstemp64(char *);

	extern char *ptsname(int);
	extern long random(void);
	extern char *realpath(const char *, char *);
	extern char *setstate(const char *);
	extern void srandom(unsigned);
	extern int  unlockpt(int);
#line 484
	extern int  	posix_openpt	(int);
	extern int      setenv		(const char *, const char *, int);
	extern int      unsetenv	(const char *);
}
extern "C" {
#line 39 "/usr/include/sys/localedef.h"
struct __LC_locale;              
struct _LC_locale_objhdl;        
}
extern "C" {
#line 39 "/usr/include/sys/lc_core.h"
extern "C" {
#line 52
typedef struct {

    unsigned short
	__type_id,
	__magic;
    unsigned long
	__version;

    size_t  __size;

} _LC_object_t;
#line 102
typedef struct {

    _LC_object_t  __hdr;
#line 108
    int __catgets;
    int __catclose;
#line 112
    int __compress;
    int __decompress;
    int __start_compress;
    int __end_compress;
#line 118
    int __init;
    void    *__data;
} _LC_core_car_t;

typedef struct {

    _LC_object_t  __hdr;
#line 127
    int __nl_langinfo;
#line 130
    int __mbtowc;
    int __mbstowcs;
    int __wctomb;
    int __wcstombs;
#line 136
    int __mblen;
#line 139
    int __wcswidth;
    int __wcwidth;
#line 143
    int __mbtopc;
    int __mbstopcs;
    int __pctomb;
    int __pcstombs;
#line 149
    int __csid;
    int __wcsid;
#line 153
    int __init;
    void     *__data;
} _LC_core_charmap_t;
#line 158
typedef struct {

    _LC_object_t  __hdr; 
#line 163
    int __towupper;
    int __towlower;
#line 167
    int __get_wctype;
    int __is_wctype;
#line 171
    int __init;
    void     *__data;
} _LC_core_ctype_t;

typedef struct {

    _LC_object_t  __hdr;
#line 180
    int __strcoll;
    int __strxfrm;
#line 184
    int __wcscoll;
    int __wcsxfrm;
#line 188
    int __fnmatch;
#line 191
    int __regcomp;
    int __regerror;
    int __regexec;
    int __regfree;
#line 197
    int __init;
    void     *__data;
} _LC_core_collate_t;
#line 202
typedef struct {

    _LC_object_t  __hdr;
#line 207
    int __nl_langinfo;
#line 210
    int __strftime;
    int __strptime;
#line 214
    int __wcsftime;
#line 217
    int __init;
    void     *__data;
} _LC_core_time_t;
#line 222
typedef struct {

    _LC_object_t  __hdr;
#line 227
    int __nl_langinfo;
#line 230
    int __strfmon;
#line 233
    int __init;
    void     *__data;
} _LC_core_monetary_t;
#line 238
typedef struct {

    _LC_object_t  __hdr;
#line 243
    int __nl_langinfo;
#line 246
    int __init;
    void     *__data;
} _LC_core_numeric_t;
#line 251
typedef struct {

    _LC_object_t  __hdr;
#line 256
    int __nl_langinfo;
#line 259
    int __rpmatch;
#line 262
    int __init;
    void        *__data;
} _LC_core_resp_t;

typedef struct {

    _LC_object_t __hdr;
#line 271
    int __nl_langinfo;
    int __localeconv;
#line 275
    int __init;
    void         *__data;
} _LC_core_locale_t;
#line 281
}
}
extern "C" {
}
extern "C" {
#line 40 "/usr/include/locale.h"
extern "C" {
#line 51
struct lconv {
   char *decimal_point;		 
   char *thousands_sep;		 
   char *grouping;		 
   char *int_curr_symbol;	 
   char *currency_symbol;	 
   char *mon_decimal_point;	 
   char *mon_thousands_sep;	 
   char *mon_grouping;		 
   char *positive_sign;		 
   char *negative_sign;		 
   char int_frac_digits;	 
   char frac_digits;		 
   char p_cs_precedes;		 
   char p_sep_by_space;		 
   char n_cs_precedes;		 
   char n_sep_by_space;		 
   char p_sign_posn;		 
   char n_sign_posn;		 
#line 72
   char *left_parenthesis;	 
   char *right_parenthesis;	 
#line 80
   char int_p_cs_precedes;       
   char int_p_sep_by_space;      
   char int_n_cs_precedes;       
   char int_n_sep_by_space;      
   char int_p_sign_posn;         
   char int_n_sign_posn;         
#line 94
} ;
#line 110
struct lconv *localeconv(void);
char   *setlocale(int, const char *);
#line 117
typedef struct lconv lconv;
#line 204
}
}
extern "C" {
}
extern "C" {
#line 39 "/usr/include/sys/localedef31.h"
typedef struct  coldesc  {                      
	short     cd_stroff;                    
	short	  cd_repoff;
	short     cd_cval;
	short	  cd_cuniq;
} coldesc_t;
#line 49
typedef struct collation_table {                 
	short    lc_version;                     
	short	 lc_length;			 
	char     *lc_locale_name;		 
	int      len_collate;
	short    *lc_collate;                    
	int      len_coluniq;
	short    *lc_coluniq;                    
	int      len_coldesc;
	coldesc_t *lc_coldesc;                   
	int	 len_strings;			
	wchar_t  *lc_strings;			 
	int	 high_cvalue;			 
} col_t;
#line 70
typedef struct char_classification_table {       
	short      lc_version; 		 
	short	   lc_length;  		 
	short      lc_code_type; 	 
	short      mb_cur_max;   	 
	short      mb_cur_min;   	 
	short      lc_dsp_width;                  
	char       *lc_locale_name; 	 
	int        len_caseconv;   	 
	wchar_t    *lc_caseconv;   	 
	int	   len_ctype;
	unsigned short *lc_ctype;	 	
} ctype_t;
#line 88
typedef	struct lc_monetary_table {
	short  	lc_version;
	short 	lc_length;		 
	char   	*lc_locale_name;	 
	char 	*int_curr_symbol;	 
	char 	*currency_symbol;	 
	char 	*mon_decimal_point;	 
	char 	*mon_thousands_sep;	 
	char 	*mon_grouping;		 
	char 	*positive_sign;		 
	char 	*negative_sign;		 
	char 	int_frac_digits;	 
	char 	frac_digits;		 
	char 	p_cs_precedes;		 
	char 	p_sep_by_space;		 
	char 	n_cs_precedes;		 
	char 	n_sep_by_space;		 
	char 	p_sign_posn;		 
	char 	n_sign_posn;		 
} mon_t;
#line 113
typedef struct numeric_table {                   
	short	lc_version;
	short	lc_length;		 
	char    *lc_locale_name;	 
	char 	*decimal_point;
	char 	*thousands_sep;
	char	*grouping;
} num_t;
#line 126
typedef struct lc_messages_table {
	short	lc_version;
	short	lc_length;		 
	char    *lc_locale_name;	 
	char 	*messages;		 
	char 	*yes_string;		 
	char 	*no_string;		 
} msg_t;
#line 139
typedef struct lc_time_table {
	short   lc_version;
	short	lc_length;	  
	char    *lc_locale_name;  
	char    *t_fmt;          
	char    *d_fmt;          
	char    *nlldate;        
	char    *d_t_fmt;        
	char    *abday;          
	char    *day;            
	char    *abmon;          
	char    *mon;            
#line 155
	char    *misc;           
	char    *tstrs;          
	char    *tunits;         
#line 161
	char	*year;		 
	char    *am_pm;          
} tim_t;
#line 170
typedef struct wchar_mapping_table {             
	short    lc_version;
	short	 lc_length;			 
	char     *lc_identifier;
} map_t;
#line 183
typedef struct localeinfo_table {           
	char     lc_mag0, lc_mag1;       
	short    lc_version;             
	short    lc_code_type;                 
	short	 lc_length;		 
	col_t    *lc_coltbl;		 
	ctype_t  *lc_chrtbl;		 
	mon_t    *lc_montbl;		 
	num_t    *lc_numtbl;		 
	tim_t    *lc_timtbl;		 
	msg_t    *lc_msgtbl;		 
	map_t    *lc_maptbl;		 
} loc_t;
}
extern "C" {
#line 66 "/usr/include/sys/localedef.h"
typedef struct {

    _LC_core_charmap_t core;

    char     *cm_csname;	 

    size_t   cm_mb_cur_max;      
    size_t   cm_mb_cur_min;	 

    unsigned char
	     cm_max_disp_width;  
#line 79
    unsigned 
	char *cm_cstab;		 

    struct __LC_locale 		 
             *loc_rec;

    void     *__meth_ptr;	 
    void     *__data_ptr;	 

} _LC_charmap_t;

typedef struct _LC_charmap_objhdl _LC_charmap_objhdl_t;

struct _LC_charmap_objhdl {
	_LC_charmap_t *obj;
#line 96
	void *(**meth)();
#line 99
struct _LC_locale_objhdl *loc_hdl;	 
#line 102
};
#line 110
typedef	struct {

    _LC_core_monetary_t   core;

    char *int_curr_symbol;	    
    char *currency_symbol;	    
    char *mon_decimal_point;	    
    char *mon_thousands_sep;	    
    char *mon_grouping;		    
    char *positive_sign;	    
    char *negative_sign;	    
    signed char int_frac_digits;    
    signed char frac_digits;	    
    signed char p_cs_precedes;	    
    signed char p_sep_by_space;	    
    signed char n_cs_precedes;	    
    signed char n_sep_by_space;	    
    signed char p_sign_posn;	    
    signed char n_sign_posn;	    
    char *debit_sign;		    
    char *credit_sign;		    
    char *left_parenthesis;	    
    char *right_parenthesis;	    

    struct __LC_locale 		    
             *loc_rec;		    

    void     *__meth_ptr;	    
    void     *__data_ptr;	    
#line 141
    signed char int_p_cs_precedes;  
    signed char int_p_sep_by_space; 
    signed char int_n_cs_precedes;  
    signed char int_n_sep_by_space; 
    signed char int_p_sign_posn;    
    signed char int_n_sign_posn;    
#line 156
} _LC_monetary_t;

typedef struct _LC_monetary_objhdl _LC_monetary_objhdl_t;
struct _LC_monetary_objhdl {
	_LC_monetary_t *obj;
#line 163
	void *(**meth)();
#line 166
struct _LC_locale_objhdl *loc_hdl;	 
#line 169
};
#line 176
typedef struct {

    _LC_core_numeric_t core;

    char     *decimal_point;
    char     *thousands_sep;
    char     *grouping;

    struct __LC_locale 		    
             *loc_rec;		    

    void     *__meth_ptr;	    
    void     *__data_ptr;	    

} _LC_numeric_t;

typedef struct _LC_numeric_objhdl _LC_numeric_objhdl_t;
struct _LC_numeric_objhdl {
	_LC_numeric_t *obj;
#line 197
	void *(**meth)();
#line 200
struct _LC_locale_objhdl *loc_hdl;	 
#line 203
};
#line 211
typedef struct  {

    _LC_core_resp_t core;

    char     *yesexpr;	      
    char     *noexpr;	      
    char     *yesstr;	      
    char     *nostr;	      

    struct __LC_locale	      
             *loc_rec;	      

    void     *__meth_ptr;     
    void     *__data_ptr;     

} _LC_resp_t;

typedef struct _LC_resp_objhdl _LC_resp_objhdl_t;
struct _LC_resp_objhdl {
	_LC_resp_t *obj;
#line 233
	void *(**meth)();
#line 236
struct _LC_locale_objhdl *loc_hdl;	 
#line 239
};
#line 247
typedef struct {

    _LC_core_time_t core;

    char *d_fmt;  
    char *t_fmt;  
    char *d_t_fmt;
    char *t_fmt_ampm;
    char *abday[7];  
    char *day[7];    
    char *abmon[12];  
    char *mon[12];    
    char *am_pm[2];
    char *era;
    char *era_year;
    char *era_d_fmt;
    char *alt_digits;
    char *era_d_t_fmt;
    char *era_t_fmt;

    struct __LC_locale	      
             *loc_rec;	      

    void     *__meth_ptr;     
    void     *__data_ptr;     

} _LC_time_t;

typedef struct _LC_time_objhdl _LC_time_objhdl_t;
struct _LC_time_objhdl {
	_LC_time_t *obj;
#line 280
	void *(**meth)();
#line 283
struct _LC_locale_objhdl *loc_hdl;	 
#line 286
};
#line 293
typedef struct {
    unsigned
	short  n[4+1];
} _LC_weight_t;    
#line 303
typedef struct {

    char         *ce_sym;	 
    _LC_weight_t ce_wgt;	 

} _LC_collel_t;
#line 315
typedef struct {
    _LC_weight_t   ct_wgt;     
#line 319
    _LC_collel_t   *ct_collel; 

} _LC_coltbl_t;
#line 334
typedef struct {
    char *tgt_wgt_str[4+1];
#line 338
} _LC_subs_t;
#line 346
typedef struct {

    _LC_core_collate_t core;

    unsigned			             
	char    co_nord;	             

    _LC_weight_t co_sort;	             
#line 356
    wchar_t     co_wc_min;		     
    wchar_t     co_wc_max;		     

    wchar_t     co_col_min;		     
    wchar_t     co_col_max;		     

    _LC_coltbl_t *co_coltbl;		     

    unsigned
	int     co_nsubs;		     
    _LC_subs_t  *co_subs;		     

    unsigned
	short	co_special;		     
#line 374
    struct __LC_locale	                     
                *loc_rec;	             

    void        *__meth_ptr;                 
    void        *__data_ptr;                 

} _LC_collate_t;

typedef struct _LC_collate_objhdl _LC_collate_objhdl_t;
struct _LC_collate_objhdl {
	_LC_collate_t *obj;
#line 387
	void *(**meth)();
#line 390
struct _LC_locale_objhdl *loc_hdl;	 
#line 393
};
#line 407
typedef struct {

    char    *name;
    unsigned
	int mask;

} _LC_classnm_t;
#line 421
typedef struct {

  _LC_core_ctype_t core;
#line 426
  wchar_t      min_wc;
  wchar_t      max_wc;
#line 430
  wchar_t      *upper;
  wchar_t      *lower;
#line 434
  unsigned
      int      *mask;         
  unsigned
      int      *qmask;	      
  unsigned
      char     *qidx;	      
#line 442
  unsigned
      char     nclasses;
 _LC_classnm_t *classnms;

    struct __LC_locale	      
               *loc_rec;      

    void       *__meth_ptr;   
    void       *__data_ptr;   

} _LC_ctype_t;

typedef struct _LC_ctype_objhdl _LC_ctype_objhdl_t;
struct _LC_ctype_objhdl {
	_LC_ctype_t *obj;
#line 459
	void *(**meth)();
#line 462
struct _LC_locale_objhdl *loc_hdl;	 
#line 465
};
#line 480
typedef struct __LC_locale {

    _LC_core_locale_t core;

    char           *nl_info[63];
    struct lconv   *nl_lconv;

    _LC_charmap_objhdl_t  lc_charmap;
    _LC_collate_objhdl_t  lc_collate;
    _LC_ctype_objhdl_t    lc_ctype;
    _LC_monetary_objhdl_t lc_monetary;
    _LC_numeric_objhdl_t  lc_numeric;
    _LC_resp_objhdl_t     lc_resp;
    _LC_time_objhdl_t     lc_time;

    struct __LC_locale    *loc_rec;        
#line 498
    void                  *__meth_ptr;     
    void                  *__data_ptr;     

    char		  *__nl_yesstr;    
    char		  *__nl_nostr;     
    char		  *__nl_crncystr;  

} _LC_locale_t;

typedef struct _LC_locale_objhdl _LC_locale_objhdl_t;
struct _LC_locale_objhdl {
	_LC_locale_t *obj;
#line 512
	void *(**meth)();
#line 515
struct _LC_locale_objhdl *loc_hdl;	 
#line 518
};
#line 527
typedef struct _LC_object_handle _LC_object_handle_t;
struct _LC_object_handle {
    union {
	_LC_object_t	      lc_object;
	_LC_locale_objhdl_t   lc_locale;
        _LC_charmap_objhdl_t  lc_charmap;
        _LC_collate_objhdl_t  lc_collate;
        _LC_ctype_objhdl_t    lc_ctype;
        _LC_monetary_objhdl_t lc_monetary;
        _LC_numeric_objhdl_t  lc_numeric;
        _LC_resp_objhdl_t     lc_resp;
        _LC_time_objhdl_t     lc_time;
    } obj;
#line 542
    void    *(**meth)();
#line 545
struct _LC_locale_objhdl *loc_hdl;	 
#line 548
};
#line 551
typedef struct {
    _LC_object_t	hdr;		   
    _LC_locale_objhdl_t handle;		   
} _LC_load_object_t;
#line 562
extern _LC_charmap_objhdl_t  *__lc_charmap_ptr;
extern _LC_collate_objhdl_t  *__lc_collate_ptr;
extern _LC_ctype_objhdl_t    *__lc_ctype_ptr;
extern _LC_monetary_objhdl_t *__lc_monetary_ptr;
extern _LC_numeric_objhdl_t  *__lc_numeric_ptr;
extern _LC_resp_objhdl_t     *__lc_resp_ptr;
extern _LC_time_objhdl_t     *__lc_time_ptr;
extern _LC_locale_objhdl_t   *__lc_locale_ptr;
#line 572
extern _LC_charmap_objhdl_t  __lc_charmap;
extern _LC_collate_objhdl_t  __lc_collate;
extern _LC_ctype_objhdl_t    __lc_ctype;
extern _LC_monetary_objhdl_t __lc_monetary;
extern _LC_numeric_objhdl_t  __lc_numeric;
extern _LC_resp_objhdl_t     __lc_resp;
extern _LC_time_objhdl_t     __lc_time;
extern _LC_locale_objhdl_t   __lc_locale;
}
extern "C" {
#line 578 "/usr/include/stdlib.h"
extern char *optarg;
extern int optind;
extern int opterr;
#line 595
	extern float    ____atoff(char *);
	extern void     imul_dbl(long, long, long *);
	extern void     umul_dbl(unsigned long, unsigned long, unsigned long *);
	extern int	on_exit(void (*)(int, void *), void *);
	extern int      unatexit(void (*)(void));
#line 624
	extern double	 		wcstod(const wchar_t *, wchar_t **);
	extern long int	 		wcstol(const wchar_t *, wchar_t **, int);
	extern unsigned long int 	wcstoul(const wchar_t *, wchar_t **, int);

	extern int			rpmatch(const char *);
	extern int			clearenv(void);
	extern int			getopt(int, char* const*, const char*);
	extern char			*getpass(const char *);

        extern int  			ttyslot(void);
        extern void 			*valloc(size_t);
#line 673
extern void *vec_malloc(size_t);
extern void *vec_calloc(size_t, size_t);
#line 704
}
#line 710
      extern "builtin" char *__alloca (size_t);
#line 716
    extern "C" {
      float atoff(char *);
      float strtof(const char *, char**);
    }
#line 724
      extern "builtin" div_t   __div(int, int);
      extern "builtin" ldiv_t   __ldiv(long, long);

        inline div_t div (int __numer, int __denom) { return __div(__numer, __denom); }
        extern "C++" inline ldiv_t div (long __numer, long __denom) { return __ldiv(__numer, __denom); }
        inline ldiv_t ldiv (long __numer, long __denom) { return __ldiv(__numer, __denom); }
#line 735
      extern "builtin" int   __abs(int);
      extern "builtin" long   __labs(long);

      inline int abs (int __n) { return __abs(__n);}
#line 742
      inline long labs (long __n) { return __labs(__n);}
#line 746
      extern "builtin" long long  __llabs(long long);

      inline long long llabs(long long __n) { return __llabs(__n);}
#line 754
      extern "builtin" void __imul_dbl(long,long,long *);
      extern "builtin" void __umul_dbl(unsigned long,unsigned long,unsigned long *);
      inline void imul_dbl(long __a,long __b,long *__c)
        { __imul_dbl(__a,__b,__c); }
      inline void umul_dbl(unsigned long __a,unsigned long __b,
                    unsigned long *__c)
        { __umul_dbl(__a,__b,__c); }
}
#line 241 "/usr/vacpp/include/stdlib.h"
# pragma info(restore)
#line 71 "/usr/vacpp/include/cstdlib"
  extern "builtin" long __labs(long);
  inline long abs (long __n) { return __labs(__n);}
#line 75
namespace std {
using ::size_t; using ::div_t; using ::ldiv_t;
using ::abort; using ::abs; using ::atexit;
using ::atof; using ::atoi; using ::atol;
using ::bsearch; using ::calloc; using ::div;
using ::exit; using ::free; using ::getenv;
using ::labs; using ::ldiv; using ::malloc;
using ::mblen; using ::mbstowcs; using ::mbtowc;
using ::qsort; using ::rand; using ::realloc;
using ::srand; using ::strtod; using ::strtol;
using ::strtoul; using ::system;
using ::wcstombs; using ::wctomb;
};
#line 108
#pragma namemangling()
#pragma object_model(pop)
#line 115
#pragma info(none)

#  pragma report(pop)

#pragma info(restore)
#line 13 "/usr/vacpp/include/streambuf"
#pragma info(none)

#  pragma report(level, E)

#pragma info(restore)
#line 46
#pragma object_model(compat)
#line 51
  #pragma namemangling(v7)
#line 13 "/usr/vacpp/include/xiosbase"
#pragma info(none)

#  pragma report(level, E)

#pragma info(restore)
#line 46
#pragma object_model(compat)
#line 51
  #pragma namemangling(v7)
#line 13 "/usr/vacpp/include/xlocale"
#pragma info(none)

#  pragma report(level, E)

#pragma info(restore)
#line 46
#pragma object_model(compat)
#line 51
  #pragma namemangling(v7)
#line 13 "/usr/vacpp/include/cstring"
#pragma info(none)

#  pragma report(level, E)

#pragma info(restore)
#line 39
#pragma object_model(compat)
#line 43
  #pragma namemangling(v7)
#line 20 "/usr/vacpp/include/string.h"
# pragma info(none)
extern "C" {
#line 33 "/usr/include/string.h"
    inline char *strcpy(char *, const char *);
    inline int   strcmp(const char *, const char *);

     inline size_t strlen(const char *);
     inline char  *strchr(const char *, int );
     inline char  *strrchr(const char *, int );
     inline char  *strcat(char *, const char *);
     inline void  *memchr(const void *, int , size_t);
     inline void  *memcpy(void *, const void *, size_t);
     inline void  *memmove(void *s1, const void *, size_t );
     inline int    memcmp(const void *, const void *, size_t );
     inline void  *memset(void *, int , size_t );

     inline void  *memccpy(void *, const void *, int , size_t);
     inline char  *strncat(char *, const char *, size_t );
     inline int   strncmp(const char *, const char *, size_t );
     inline char  *strncpy(char *, const char *, size_t);
#line 52
      inline char  *index(const char *, int );
      inline char  *rindex(const char *, int );
#line 69
extern "C" {
#line 116
        extern void     	*memchr(const void *, int, size_t);

	extern void     *memcpy(void * restrict, const void * restrict, size_t);
        extern void     *memset(void *, int, size_t);
        extern size_t   strcspn(const char *, const char *);
        extern size_t   strlen(const char *);
        extern size_t   strspn(const char *, const char *);
#line 159
	extern char		*strchr(const char *, int);
	extern char		*strpbrk(const char *, const char *);
	extern char		*strrchr(const char *, int);
	extern char		*strstr(const char *, const char *);
#line 165
        extern void     *memmove(void *, const void *, size_t);
        extern char     *strcpy(char * restrict, const char * restrict);
        extern char     *strncpy(char * restrict, const char * restrict, size_t);
        extern char     *strcat(char * restrict, const char * restrict);
        extern char     *strncat(char * restrict, const char * restrict, size_t);
        extern int      memcmp(const void *, const void *,size_t);
        extern int      strcmp(const char *, const char *);
        extern int      strncmp(const char *,const char *,size_t);
        extern int      strncollen(const char *, const int );
        extern char     *strtok(char * restrict, const char * restrict);
        extern char     *strerror(int);
        extern int      strcoll(const char *, const char *);
        extern size_t strxfrm(char * restrict, const char * restrict, size_t);
	extern char *strtok_r(char *, const char *, char **);

	    extern int	strerror_r(int, char *, size_t);
#line 192
        extern void     *memccpy(void * restrict, const void * restrict, int, size_t);
#line 201
extern char *strdup(const char *);
#line 258
	extern wchar_t		*wcschr(const wchar_t *, wchar_t);
	extern wchar_t		*wcspbrk(const wchar_t *, const wchar_t *);
	extern wchar_t		*wcsrchr(const wchar_t *, wchar_t);
#line 263
        extern char     *index(const char *, int);
        extern char     *rindex(const char *, int);

	extern void     swab(const void *, void *, ssize_t); 
        extern wchar_t  *wcscat(wchar_t *, const wchar_t *);
        extern int      wcscmp(const wchar_t *, const wchar_t *);
        extern wchar_t  *wcscpy(wchar_t *, const wchar_t *);
        extern size_t   wcscspn(const wchar_t *, const wchar_t *);
        extern size_t   wcslen(const wchar_t *);
        extern wchar_t  *wcsncat(wchar_t *, const wchar_t *, size_t);
        extern int      wcsncmp(const wchar_t *, const wchar_t *, size_t);
        extern wchar_t  *wcsncpy(wchar_t *, const wchar_t *, size_t);
        extern size_t   wcsspn(const wchar_t *, const wchar_t *);
        extern wchar_t  *wcswcs(const wchar_t *, const wchar_t *);
        extern int      wcswidth(const wchar_t *, size_t);
        extern int      wcwidth(wchar_t);
        extern int      wcscoll(const wchar_t *, const wchar_t *);
        extern size_t	wcsxfrm(wchar_t *, const wchar_t *, size_t);
	extern char	*__linux_strerror_r(int, char *, size_t);
	extern char *	strndup(const char *, size_t);
	extern size_t	strnlen(const char *, size_t);
	extern char *	strsep(char **, const char *);
	extern void *	memmem(const void *, size_t, const void *, size_t);
	extern char *	stpcpy(char *, const char *);
	extern char *	stpncpy(char *, const char *, size_t);
	extern char *	strsignal(int);
#line 294
	extern int	strcasecmp(const char *, const char *);
	extern int	strncasecmp(const char *, const char *, size_t);
#line 350
}
#line 357
   extern "builtin" char *__strcpy(char *, const char *);
   extern "builtin" int   __strcmp(const char *, const char *);

   inline char *strcpy(char *__s1, const char *__s2)
     { return __strcpy (__s1, __s2);}
   inline int   strcmp(const char *__s1, const char *__s2)
     { return __strcmp (__s1, __s2);}
#line 366
    extern "builtin" size_t __strlen(const char *);
    extern "builtin" char *__strchr(const char *, int );
    extern "builtin" char *__strrchr(const char *, int );
    extern "builtin" char  *__strcat(char *, const char *);
    extern "builtin" void  *__memchr(const void *, int , size_t );
    extern "builtin" void  *__memcpy(void *, const void *, size_t );
    extern "builtin" void  *__memmove(void *, const void *, size_t );
    extern "builtin" int __memcmp(const void *, const void *, size_t );
    extern "builtin" void  *__memset(void *, int , size_t );

    extern "builtin" void  *__memccpy(void *, const void *, int , size_t );
    extern "builtin" char  *__strncat(char *, const char *, size_t );
    extern "builtin" int  __strncmp(const char *, const char *, size_t );
    extern "builtin" char  *__strncpy(char *, const char *, size_t );

    inline size_t strlen(const char *__s)
      { return __strlen (__s); }
    inline char  *strchr(const char *__s, int __c)
      { return __strchr (__s, __c); }
    inline char  *strrchr(const char *__s, int __c)
      { return __strrchr (__s, __c); }
    inline char  *strcat(char *__s1, const char *__s2)
      { return __strcat (__s1, __s2); }
    inline void  *memchr(const void *__s, int __c, size_t __n)
      { return __memchr (__s, __c, __n); }
    inline void  *memcpy(void *__s1, const void *__s2, size_t __n)
      { return __memcpy (__s1, __s2, __n); }
    inline void  *memmove(void *__s1, const void *__s2, size_t __n)
      { return __memmove (__s1, __s2, __n); }
    inline int    memcmp(const void *__s1, const void *__s2, size_t __n)
      { return __memcmp (__s1, __s2, __n); }
    inline void  *memset(void *__s, int __c, size_t __n)
      { return __memset (__s, __c, __n); }

    inline void  *memccpy(void *__target, const void *__source, int __c, size_t __n)
      { return __memccpy (__target, __source, __c, __n); }
    inline char  *strncat(char *__s1, const char *__s2, size_t __n)
      { return __strncat (__s1, __s2, __n); }
    inline int   strncmp(const char *__s1, const char *__s2, size_t __n)
      { return __strncmp (__s1, __s2, __n); }
    inline char  *strncpy(char *__s1, const char *__s2, size_t __n)
      { return __strncpy (__s1, __s2, __n); }
#line 412
     inline char  *index(const char *__s, int __c)
       {return __strchr(__s, __c);}
     inline char  *rindex(const char *__s, int __c)
       {return __strrchr(__s, __c);}
}
#line 202 "/usr/vacpp/include/string.h"
# pragma info(restore)
#line 69 "/usr/vacpp/include/cstring"
namespace std {
using ::size_t; using ::memcmp; using ::memcpy;
using ::memmove; using ::memset; using ::strcat;
using ::strcmp; using ::strcoll; using ::strcpy;
using ::strcspn; using ::strerror; using ::strlen;
using ::strncat; using ::strncmp; using ::strncpy;
using ::strspn; using ::strtok; using ::strxfrm;
using ::strchr; using ::strpbrk; using ::strrchr;
using ::strstr; using ::memchr; 
};

#pragma namemangling()
#pragma object_model(pop)
#line 87
#pragma info(none)

#  pragma report(pop)

#pragma info(restore)
#line 21 "/usr/vacpp/include/stdexcept"
#pragma info(none)

#  pragma report(level, E)

#pragma info(restore)
#line 32
#pragma object_model(compat)
#line 37
  #pragma namemangling(v7)
#line 5 "/usr/vacpp/include/exception"
#pragma info(none)

#  pragma report(level, E)

#pragma info(restore)
#line 20
#pragma object_model (compat)
#line 30
  #pragma namemangling(v7)
#line 13 "/usr/vacpp/include/xstddef"
#pragma info(none)

#  pragma report(level, E)

#pragma info(restore)
#line 40
#pragma object_model(compat)
#line 45
  #pragma namemangling(v7)
#line 13 "/usr/vacpp/include/cstddef"
#pragma info(none)

#  pragma report(level, E)

#pragma info(restore)
#line 39
#pragma object_model(compat)
#line 43
  #pragma namemangling(v7)
extern "C" {
#line 33 "/usr/include/stddef.h"
extern "C" {
#line 86
}
}
#line 69 "/usr/vacpp/include/cstddef"
namespace std {
using ::ptrdiff_t; using ::size_t;
};

#pragma namemangling()
#pragma object_model(pop)
#line 80
#pragma info(none)

#  pragma report(pop)

#pragma info(restore)
#line 73 "/usr/vacpp/include/xstddef"
namespace std {
#line 113
enum _Uninitialized {_Noinit};
#line 116
void _Nomemory();
#line 121
extern "C" {
typedef void _Atexit_fun();
}
#line 128
template <class _T>
struct __remove_const_aux {
        typedef _T type;
};

template <class _T>
struct __remove_const_aux<_T const> {
        typedef _T type;
};

template <class _T>
struct __remove_volatile_aux {
        typedef _T type;
};

template <class _T>
struct __remove_volatile_aux<_T volatile> {
        typedef _T type;
};

template <class _T>
struct __remove_cv_aux {
        typedef typename
            __remove_const_aux<typename __remove_volatile_aux<_T>::type>::type
            type;
};
#line 156
template <class _T>
struct _Is_signed_aux {
        static const bool value = false;
};

template <>
struct _Is_signed_aux<signed char> {
        static const bool value = true;
};

template <>
struct _Is_signed_aux<short> {
        static const bool value = true;
};

template <>
struct _Is_signed_aux<int> {
        static const bool value = true;
};

template <>
struct _Is_signed_aux<long> {
        static const bool value = true;
};
#line 182
template <>
struct _Is_signed_aux<long long> {
        static const bool value = true;
};
#line 188
template <class _T>
struct _Is_unsigned_aux {
        static const bool value = false;
};

template <>
struct _Is_unsigned_aux<unsigned char> {
        static const bool value = true;
};

template <>
struct _Is_unsigned_aux<unsigned short> {
        static const bool value = true;
};

template <>
struct _Is_unsigned_aux<unsigned int> {
        static const bool value = true;
};

template <>
struct _Is_unsigned_aux<unsigned long> {
        static const bool value = true;
};
#line 214
template <>
struct _Is_unsigned_aux<unsigned long long> {
        static const bool value = true;
};
#line 220
template <class _T, class _U>
struct _Is_same_aux {
        static const bool value = false;
};

template <class _T>
struct _Is_same_aux<_T, _T> {
        static const bool value = true;
};

template <class _T>
struct _Is_integral_aux {
        static const bool value =
            _Is_signed_aux<typename __remove_cv_aux<_T>::type>::value ||
            _Is_unsigned_aux<typename __remove_cv_aux<_T>::type>::value ||
            _Is_same_aux<typename __remove_cv_aux<_T>::type, bool>::value ||
            _Is_same_aux<typename __remove_cv_aux<_T>::type, char>::value ||
            _Is_same_aux<typename __remove_cv_aux<_T>::type, wchar_t>::value;
};

template <class _T>
struct _Is_floating_point_aux {
        static const bool value = false;
};

template <>
struct _Is_floating_point_aux<float> {
        static const bool value = true;
};

template <>
struct _Is_floating_point_aux<double> {
        static const bool value = true;
};

template <>
struct _Is_floating_point_aux<long double> {
        static const bool value = true;
};
#line 261
template<class _Ty>
struct _Remove_reference {
        typedef _Ty _Type;
};

template<class _Ty>
struct _Remove_reference<_Ty&> {
        typedef _Ty _Type;
};
#line 272
template <bool _Cond, class _TrueCase, class _FalseCase>
struct _ConditionalExpression {
        static const std::size_t value = _FalseCase::value;
};

template <class _TrueCase, class _FalseCase>
struct _ConditionalExpression<true, _TrueCase, _FalseCase> {
        static const std::size_t value = _TrueCase::value;
};
#line 301
};
#line 309
#pragma namemangling()

#pragma object_model(pop)
#line 318
#pragma info(none)

#pragma report(pop)

#pragma info(restore)
#line 55 "/usr/vacpp/include/exception"
namespace std {

class exception;
typedef void (*_Prhand)(const exception&);
extern _Prhand  _Raise_handler;
void _Throw(const exception&);
class exception {
public:
        static _Prhand _Set_raise_handler(_Prhand _Pn)
                {const _Prhand _Po = _Raise_handler;
                _Raise_handler = _Pn;
                return _Po; }
        explicit exception(const char *_S =

	    "unknown" 
#line 75
	    )
                throw ()
                : _Ptr(_S) {}
        exception(const exception& _R) throw ()
                : _Ptr(_R._Ptr) {}
        exception& operator=(const exception& _R) throw ()
                {_Ptr = _R._Ptr;
                return *this; }
        virtual ~exception()
                {}
        virtual const char *what() const throw ()
                {return _Ptr; }
        void _Raise() const
                {if (_Raise_handler != 0)
                        (*_Raise_handler)(*this);
                _Doraise();
                throw (*this); }
protected:
        virtual void _Doraise() const
                {}
        const char *_Ptr;
        };

class bad_exception : public exception {
public:
        bad_exception(const char *_S =

	    "bad exception"
#line 108
	    )
                throw ()
                : exception(_S) {}
        virtual ~bad_exception() throw ()
                {}
protected:
        virtual void _Doraise() const
                {throw (*this); }
        };

typedef void (*terminate_handler)();
typedef void (*unexpected_handler)();

terminate_handler set_terminate(terminate_handler)
        throw ();
unexpected_handler set_unexpected(unexpected_handler)
        throw ();
#line 133
void terminate();
void unexpected();
bool uncaught_exception() throw ();
};

#pragma namemangling()
#line 141
#pragma object_model (pop)
#line 148
#pragma info(none)

#  pragma report(pop)

#pragma info(restore)
#line 13 "/usr/vacpp/include/xstring"
#pragma info(none)

#  pragma report(level, E)

#pragma info(restore)
#line 24
        extern "C" int __n_pthreads;               
#line 54
#pragma object_model(compat)
#line 59
  #pragma namemangling(v7)
#line 13 "/usr/vacpp/include/xmemory"
#pragma info(none)

#  pragma report(level, E)

#pragma info(restore)
#line 40
#pragma object_model(compat)
#line 45
  #pragma namemangling(v7)
#line 4 "/usr/vacpp/include/new"
#pragma info(none)

#  pragma report(level, E)

#pragma info(restore)
#line 23
#pragma object_model (compat)
#line 29
  #pragma namemangling(v7)
#line 55
namespace std {

class bad_alloc : public exception {
public:
        bad_alloc(const char *_S = "bad allocation") throw ()
                : exception(_S) {}
        virtual ~bad_alloc() throw ()
                {}
protected:
        virtual void _Doraise() const
                {throw (*this); }
        };

typedef void (*new_handler)();
struct nothrow_t {};
extern nothrow_t nothrow;
#line 81
       new_handler set_new_handler(new_handler) throw ();
#line 94
       bool __set_new_throws_exception(bool) throw ();
};
#line 99
   void *operator new(size_t) throw (std::bad_alloc);
   void *operator new(size_t, const std::nothrow_t&) throw ();
   void operator delete(void *) throw ();
   void operator delete(void *_P, const std::nothrow_t&) throw ();
   void *operator new[](size_t) throw (std::bad_alloc);
   void *operator new[](size_t, const std::nothrow_t&) throw ();
   void operator delete[](void *) throw ();
   void operator delete[](void *_P, const std::nothrow_t&) throw (); 
#line 112
   inline void *operator new(size_t, void *_P) throw () {return (_P); }
   inline void *operator new[](size_t, void *_P) throw () {return (_P); }

   inline void operator delete(void *, void *) throw () {}
   inline void operator delete[](void *, void *) throw () {}
#line 168
#pragma namemangling()
#line 171
#pragma object_model (pop)
#line 178
#pragma info(none)

#  pragma report(pop)

#pragma info(restore)
#line 13 "/usr/vacpp/include/xutility"
#pragma info(none)

#  pragma report(level, E)

#pragma info(restore)
#line 40
#pragma object_model(compat)
#line 45
  #pragma namemangling(v7)
#line 13 "/usr/vacpp/include/utility"
#pragma info(none)

#  pragma report(level, E)

#pragma info(restore)
#line 40
#pragma object_model(compat)
#line 45
  #pragma namemangling(v7)
#line 13 "/usr/vacpp/include/iosfwd"
#pragma info(none)

#  pragma report(level, E)

#pragma info(restore)
#line 46
#pragma object_model(compat)
#line 51
  #pragma namemangling(v7)
#line 13 "/usr/vacpp/include/cwchar"
#pragma info(none)

   #pragma info(none)

#pragma info(restore)
#line 39
#pragma object_model(compat)
#line 43
  #pragma namemangling(v7)
extern "C" {
}
extern "C" {
}
extern "C" {
#line 47 "/usr/include/wchar.h"
extern "C" {
}
extern "C" {
#line 44 "/usr/include/time.h"
extern "C" {
#line 92
struct	tm {	 
	int	tm_sec;
	int	tm_min;
	int	tm_hour;
	int	tm_mday;
	int	tm_mon;
	int	tm_year;
	int	tm_wday;
	int	tm_yday;
	int	tm_isdst;
};
#line 134
    extern size_t 	strftime(char *restrict, size_t, const char *restrict, const struct tm *restrict);
    extern clock_t 	clock(void);
    extern double 	difftime(time_t, time_t);
    extern time_t 	mktime(struct tm *);

    extern time_t 	time(time_t *);

    extern char 	*asctime(const struct tm *);
    extern char 	*ctime(const time_t *);
    extern struct tm *gmtime(const time_t *);
    extern struct tm *localtime(const time_t *);
#line 154
    extern char		*asctime_r(const struct tm *restrict, char *restrict);
    extern char		*ctime_r(const time_t *, char *);
    extern struct tm	*gmtime_r(const time_t *restrict, struct tm *restrict);
    extern struct tm	*localtime_r(const time_t *restrict, struct tm *restrict);
}
extern "C" {
}
extern "C" {
#line 188
extern char *tzname[];
#line 193
    extern void tzset(void);
#line 199
    extern long timezone;
    extern int daylight;
#line 204
    extern char         *strptime(const char *, const char *, struct tm *);
#line 209
    extern int getdate_err;
#line 213
    extern struct tm *getdate(const char *);
#line 226
struct itimerspec {
    struct  timespec it_interval;  
    struct  timespec it_value;     
};
#line 237
extern int clock_getres(clockid_t, struct timespec *);
extern int clock_gettime(clockid_t, struct timespec *);
extern int clock_settime(clockid_t, const struct timespec *);
extern int clock_getcpuclockid(pid_t, clockid_t *);
extern int nanosleep(const struct timespec *, struct timespec *);

extern int timer_create(clockid_t, struct sigevent *restrict, timer_t *restrict);
#line 247
extern int timer_delete(timer_t);
extern int timer_gettime(timer_t, struct itimerspec *);
extern int timer_getoverrun(timer_t);
extern int timer_settime(timer_t, int, const struct itimerspec *restrict, struct itimerspec *restrict);
#line 254
extern int clock_nanosleep(clockid_t, int, const struct timespec*, struct timespec*);		
#line 270
    extern unsigned char *NLctime(long *);
    extern unsigned char *NLasctime(struct tm *);
    extern char *NLstrtime(char *, size_t, const char *, const struct tm *);
#line 292
    extern char *ctime64(const time64_t *);
    extern struct tm *localtime64(const time64_t *);
    extern struct tm *gmtime64(const time64_t *);
    extern char *asctime64(const struct tm *);
    extern time64_t mktime64(struct tm *);
    extern double difftime64(time64_t, time64_t);

    extern char *ctime64_r(const time64_t *, char *);
    extern struct tm *localtime64_r(const time64_t *restrict, 
                                    struct tm *restrict);
    extern struct tm *gmtime64_r(const time64_t *restrict, 
                                 struct tm *restrict);
    extern char *asctime64_r(const struct tm *restrict, char *restrict);
#line 310
}
}
extern "C" {
#line 69 "/usr/include/wchar.h"
typedef char *   mbstate_t;      
#line 101
extern int	vfwscanf(FILE * restrict, const wchar_t * restrict, va_list);
extern int	vswscanf(const wchar_t * restrict, const wchar_t * restrict, va_list);
extern int	vwscanf(const wchar_t * restrict, va_list);
extern long double wcstold(const wchar_t * restrict, wchar_t ** restrict);
extern float wcstof(const wchar_t * restrict, wchar_t ** restrict);
#line 119
extern long long int wcstoll(
     const wchar_t * restrict,               
     wchar_t ** restrict,            
     int );                      
extern unsigned long long int wcstoull(
     const wchar_t * restrict,               
     wchar_t ** restrict,            
     int );                      
#line 196
extern wint_t fgetwc(FILE *);
extern wchar_t *fgetws(wchar_t * restrict, int, FILE * restrict);
extern int fputws(const wchar_t * restrict, FILE * restrict);
extern wint_t getwc(FILE *);
extern wint_t getwchar(void);
#line 203
extern int iswalnum(wint_t);
extern int iswalpha(wint_t);
extern int iswcntrl(wint_t);
extern int iswdigit(wint_t);
extern int iswgraph(wint_t);
extern int iswlower(wint_t);
extern int iswprint(wint_t);
extern int iswpunct(wint_t);
extern int iswspace(wint_t);
extern int iswupper(wint_t);
extern int iswxdigit(wint_t);
extern int iswctype (wint_t, wctype_t);
extern int towlower(wint_t);
extern int towupper(wint_t);
#line 220
extern wint_t fputwc(wchar_t, FILE *);
extern wint_t putwc(wchar_t, FILE *);
extern wint_t putwchar(wchar_t);
#line 232
extern wchar_t *wcschr(const wchar_t *,  wchar_t);

extern wint_t ungetwc(wint_t, FILE *);
extern wctype_t wctype(const char*);
extern wchar_t *wcscat(wchar_t * restrict, const wchar_t *restrict);
extern int wcscmp(const wchar_t *, const wchar_t *);
extern int wcscoll(const wchar_t *, const wchar_t *);
extern wchar_t *wcscpy(wchar_t * restrict, const wchar_t * restrict);
extern size_t wcscspn(const wchar_t *, const wchar_t *);

static size_t wcsftime(wchar_t *__wcsftime_wcs, size_t __wcsftime_maxsize,
	 const wchar_t *__wcsftime_format,
	 const struct tm *__wcsftime_timptr)
{
    extern size_t __iso_wcsftime(wchar_t *, size_t, const wchar_t *,
				 const struct tm *);
    return __iso_wcsftime(__wcsftime_wcs, __wcsftime_maxsize, __wcsftime_format,
			  __wcsftime_timptr);
}
#line 260
extern wchar_t *wcspbrk(const wchar_t *, const wchar_t *);
extern wchar_t *wcsrchr(const wchar_t *, wchar_t);

extern size_t wcslen(const wchar_t *);
extern wchar_t *wcsncat(wchar_t * restrict, const wchar_t * restrict, size_t);
extern int wcsncmp(const wchar_t *, const wchar_t *, size_t);
extern wchar_t *wcsncpy(wchar_t * restrict, const wchar_t * restrict, size_t);
extern size_t wcsspn(const wchar_t *, const wchar_t *);
extern double wcstod(const wchar_t * restrict, wchar_t ** restrict);

static wchar_t *wcstok(wchar_t *__wcstok_ws1, const wchar_t *__wcstok_ws2,
		       wchar_t **__wcstok_ptr)
{
    extern wchar_t *__iso_wcstok(wchar_t *, const wchar_t *, wchar_t **);
    return __iso_wcstok(__wcstok_ws1, __wcstok_ws2, __wcstok_ptr);
}
#line 282
extern long wcstol(const wchar_t * restrict, wchar_t ** restrict, int);
extern unsigned long wcstoul(const wchar_t * restrict, wchar_t ** restrict, int);

extern wchar_t *wcswcs(const wchar_t *, const wchar_t *);
extern int wcswidth(const wchar_t *, size_t);
extern int wcwidth(wchar_t);

extern size_t wcsxfrm(wchar_t * restrict, const wchar_t * restrict, size_t);
#line 292
extern wint_t btowc(int);
extern int fwprintf(FILE * restrict, const wchar_t * restrict, ...);
extern int fwscanf(FILE * restrict, const wchar_t * restrict, ...);
extern int fwide(FILE *, int);
extern int mbsinit(const mbstate_t *);
extern size_t mbrlen(const char * restrict, size_t, mbstate_t *restrict);
extern size_t mbrtowc(wchar_t * restrict, const char * restrict, size_t, mbstate_t * restrict);
extern size_t mbsrtowcs(wchar_t * restrict, const char ** restrict, size_t, mbstate_t * restrict);
extern int swprintf(wchar_t * restrict, size_t, const wchar_t * restrict, ...);
extern int swscanf(const wchar_t * restrict, const wchar_t * restrict, ...);

extern int vfwprintf(FILE * restrict, const wchar_t * restrict, va_list);
extern int vwprintf(const wchar_t * restrict, va_list);
extern int vswprintf(wchar_t * restrict, size_t, const wchar_t * restrict, va_list);
#line 319
extern wchar_t *wcsstr(const wchar_t *, const wchar_t *);
extern wchar_t *wmemchr(const wchar_t *, wchar_t, size_t);

extern size_t wcrtomb(char * restrict, wchar_t, mbstate_t *  restrict);
extern size_t wcsrtombs(char * restrict, const wchar_t ** restrict, size_t, mbstate_t * restrict);
extern int wctob(wint_t);
extern wctype_t wctype(const char *);
extern int wmemcmp(const wchar_t *, const wchar_t *, size_t); 
extern wchar_t *wmemcpy(wchar_t * restrict, const wchar_t * restrict, size_t); 
extern wchar_t *wmemmove(wchar_t *, const wchar_t *, size_t); 
extern wchar_t *wmemset(wchar_t *, wchar_t, size_t); 
extern int wprintf(const wchar_t * restrict, ...);
extern int wscanf(const wchar_t * restrict, ...);
#line 356
extern wchar_t *getws(wchar_t *);
extern int putws(const wchar_t *);
extern int wsprintf(wchar_t *, const char *, ...);

extern int vwsprintf(wchar_t *, const char *, va_list);
#line 366
extern int wcscasecmp(const wchar_t *, const wchar_t *);
extern wchar_t *wcsdup(const wchar_t *);
extern int wcsncasecmp(const wchar_t *, const wchar_t *, size_t);
extern size_t wcsnlen(const wchar_t *, size_t);
extern size_t wcsnrtombs(char *, const wchar_t **, size_t, size_t, mbstate_t *);
extern size_t mbsnrtowcs(wchar_t *, const char **, size_t, size_t, mbstate_t *);
extern wchar_t *wcpcpy(wchar_t *, const wchar_t *);
extern wchar_t *wcpncpy(wchar_t *, const wchar_t *, size_t);
#line 377
extern wchar_t *strtows(wchar_t *, char *);
extern char    *wstrtos(char *, wchar_t *);
#line 408
}
}
#line 75 "/usr/vacpp/include/cwchar"
namespace std {

using ::fgetwc; using ::fgetws; using ::fputwc;
using ::fputws; using ::fwide; using ::fwprintf;
using ::fwscanf; using ::getwc; using ::getwchar;
using ::putwc; using ::putwchar;
using ::swscanf; using ::ungetwc; using ::vfwprintf;
using ::vwprintf; using ::wprintf; using ::wscanf;
#line 85
using ::wcscoll; using ::wcsxfrm;
using ::swprintf; using ::vswprintf;
using ::mbrlen; using ::mbrtowc;
using ::mbsrtowcs; using ::mbsinit; using ::wcrtomb;
using ::wcsrtombs; using ::wcstol; 
using ::btowc; using ::wctob; using ::wcstod; using ::wcstoul;
using ::wcsftime;

using ::mbstate_t; using ::size_t; using ::wint_t;
using ::wcscat;
using ::wcschr; using ::wcscmp;
using ::wcscpy; using ::wcscspn; using ::wcslen;
using ::wcsncat; using ::wcsncmp; using ::wcsncpy;
using ::wcspbrk; using ::wcsrchr; using ::wcsspn;
using ::wcsstr; using ::wcstok;
using ::wmemchr; using ::wmemcmp; using ::wmemcpy;
using ::wmemmove; using ::wmemset; 
using ::tm;
};
#line 125
#pragma namemangling()
#pragma object_model(pop)
#line 132
#pragma info(none)

   #pragma info(restore)

#pragma info(restore)
#line 79 "/usr/vacpp/include/iosfwd"
namespace std {
#line 85
   typedef long streamoff;
#line 88
typedef int streamsize;
extern fpos_t _Fpz;
extern const streamoff _BADOFF;
#line 103
template<class _St>
        class fpos {
        typedef fpos<_St> _Myt;
public:
        fpos(streamoff _O = 0)
                : _Off(_O), _Fpos(_Fpz), _State(_Stz) {}
        fpos(_St _S, fpos_t _F)
                : _Off(0), _Fpos(_F), _State(_S) {}
#line 115
        _St state() const
                {return (_State); }
        void state(_St _S)
                {_State = _S; }
        fpos_t seekpos() const
                {return (_Fpos); }
        operator streamoff() const
                {return (_Off + ((long)(_Fpos))); }
        streamoff operator-(const _Myt& _R) const
                {return ((streamoff)*this - (streamoff)_R); }
        _Myt& operator+=(streamoff _O)
                {_Off += _O;
                return (*this); }
        _Myt& operator-=(streamoff _O)
                {_Off -= _O;
                return (*this); }
        _Myt operator+(streamoff _O) const
                {_Myt _Tmp = *this;
                return (_Tmp += _O); }
        _Myt operator-(streamoff _O) const
                {_Myt _Tmp = *this;
                return (_Tmp -= _O); }
        bool operator==(const _Myt& _R) const
                {return ((streamoff)*this == (streamoff)_R); }
        bool operator!=(const _Myt& _R) const
                {return (!(*this == _R)); }
private:
        static _St _Stz;
        streamoff _Off;
        fpos_t _Fpos;
        _St _State;
        };
#line 155
template<class _St>
        _St fpos<_St>::_Stz;
typedef fpos<mbstate_t> streampos;
typedef streampos wstreampos;

template<class _E>
        struct char_traits {
        typedef _E char_type;
        typedef _E int_type;
        typedef streampos pos_type;
        typedef streamoff off_type;
        typedef mbstate_t state_type;
        static void assign(_E& _X, const _E& _Y)
                {_X = _Y; }
        static bool eq(const _E& _X, const _E& _Y)
                {return (_X == _Y); }
        static bool lt(const _E& _X, const _E& _Y)
                {return (_X < _Y); }
        static int compare(const _E *_U, const _E *_V,
                size_t _N)
                {for (size_t _I = 0; _I < _N; ++_I, ++_U, ++_V)
                        if (!eq(*_U, *_V))
                                return (lt(*_U, *_V) ? -1 : +1);
                return (0); }
        static size_t length(const _E *_U)
                {size_t _N;
                for (_N = 0; !eq(*_U, _E()); ++_U)
                        ++_N;
                return (_N); }
        static _E *copy(_E *_U, const _E *_V, size_t _N)
                {_E *_S = _U;
                for (; 0 < _N; --_N, ++_U, ++_V)
                        assign(*_U, *_V);
                return (_S); }
        static const _E *find(const _E *_U, size_t _N,
                const _E& _C)
                {for (; 0 < _N; --_N, ++_U)
                        if (eq(*_U, _C))
                                return (_U);
                return (0); }
        static _E *move(_E *_U, const _E *_V, size_t _N)
                {_E *_Ans = _U;
                if (_V < _U && _U < _V + _N)
                        for (_U += _N, _V += _N; 0 < _N; --_N)
                                assign(*--_U, *--_V);
                else
                        for (; 0 < _N; --_N, ++_U, ++_V)
                                assign(*_U, *_V);
                return (_Ans); }
        static _E *assign(_E *_U, size_t _N, _E _C)
                {_E *_Ans = _U;
                for (; 0 < _N; --_N, ++_U)
                        assign(*_U, _C);
                return (_Ans); }
        static _E to_char_type(const int_type& _C)
                {return (_C); }
        static int_type to_int_type(const _E& _C)
                {return (_C); }
        static bool eq_int_type(const int_type& _X,
                const int_type& _Y)
                {return (_X == _Y); }
        static int_type eof()
                {return ((int_type)(-1)); }
        static int_type not_eof(const int_type& _C)
                {return (_C != eof() ? _C : !eof()); }
        };

template<> struct char_traits<wchar_t> {
        typedef wchar_t _E;
        typedef _E char_type;    
        typedef wint_t int_type;
        typedef streampos pos_type;
        typedef streamoff off_type;
        typedef mbstate_t state_type;
        static void assign(_E& _X, const _E& _Y)
                {_X = _Y; }
        static bool eq(const _E& _X, const _E& _Y)
                {return (_X == _Y); }
        static bool lt(const _E& _X, const _E& _Y)
                {return (_X < _Y); }
        static int compare(const _E *_U, const _E *_V,
                size_t _N)
                {return (wmemcmp(_U, _V, _N)); }
        static size_t length(const _E *_U)
                {return (wcslen(_U)); }
        static _E *copy(_E *_U, const _E *_V, size_t _N)
                {return (wmemcpy(_U, _V, _N)); }
        static const _E *find(const _E *_U, size_t _N,
                const _E& _C)
                {return ((const _E *)wmemchr(_U, _C, _N)); }
        static _E *move(_E *_U, const _E *_V, size_t _N)
                {return (wmemmove(_U, _V, _N)); }
        static _E *assign(_E *_U, size_t _N, _E _C)
                {return (wmemset(_U, _C, _N)); }
        static _E to_char_type(const int_type& _C)
                {return (_C); }
        static int_type to_int_type(const _E& _C)
                {return (_C); }
        static bool eq_int_type(const int_type& _X,
                const int_type& _Y)
                {return (_X == _Y); }
        static int_type eof()
                {return ((-1)); }
        static int_type not_eof(const int_type& _C)
                {return (_C != eof() ? _C : !eof()); }
        };

template<> struct char_traits<char> {
        typedef char _E;
        typedef _E char_type;
        typedef int int_type;
        typedef streampos pos_type;
        typedef streamoff off_type;
        typedef mbstate_t state_type;
        static void assign(_E& _X, const _E& _Y)
                {_X = _Y; }
        static bool eq(const _E& _X, const _E& _Y)
                {return (_X == _Y); }
        static bool lt(const _E& _X, const _E& _Y)
                {return (_X < _Y); }
        static int compare(const _E *_U, const _E *_V,
                size_t _N)
                {return (memcmp(_U, _V, _N)); }
        static size_t length(const _E *_U)
                {return (strlen(_U)); }
        static _E *copy(_E *_U, const _E *_V, size_t _N)
                {return ((_E *)memcpy(_U, _V, _N)); }
        static const _E *find(const _E *_U, size_t _N,
                const _E& _C)
                {return ((const _E *)memchr(_U, _C, _N)); }
        static _E *move(_E *_U, const _E *_V, size_t _N)
                {return ((_E *)memmove(_U, _V, _N)); }
        static _E *assign(_E *_U, size_t _N, _E _C)
                {return ((_E *)memset(_U, _C, _N)); }
        static _E to_char_type(const int_type& _C)
                {return ((_E)_C); }
        static int_type to_int_type(const _E& _C)
                {return ((unsigned char)_C); }
        static bool eq_int_type(const int_type& _X,
                const int_type& _Y)
                {return (_X == _Y); }
        static int_type eof()
                {return ((-1)); }
        static int_type not_eof(const int_type& _C)
                {return (_C != eof() ? _C : !eof()); }
        };
#line 303
template<class _T>
        class allocator;
#line 308
class ios_base;

template<class _E, class _Tr = char_traits<_E> >
        class basic_ios;
#line 317
template<class _E, class _Tr = char_traits<_E> >
        class istreambuf_iterator;
template<class _E, class _Tr = char_traits<_E> >
        class ostreambuf_iterator;
#line 326
template<class _E, class _Tr = char_traits<_E> >
        class basic_streambuf;
template<class _E, class _Tr = char_traits<_E> >
        class basic_istream;
template<class _E, class _Tr = char_traits<_E> >
        class basic_ostream;
template<class _E, class _Tr = char_traits<_E> >
        class basic_iostream;
template<class _E, class _Tr = char_traits<_E>,
        class _A = allocator<_E> >
        class basic_stringbuf;
template<class _E, class _Tr = char_traits<_E>,
        class _A = allocator<_E> >
        class basic_istringstream;
template<class _E, class _Tr = char_traits<_E>,
        class _A = allocator<_E> >
        class basic_ostringstream;
template<class _E, class _Tr = char_traits<_E>,
        class _A = allocator<_E> >
        class basic_stringstream;
template<class _E, class _Tr = char_traits<_E> >
        class basic_filebuf;
template<class _E, class _Tr = char_traits<_E> >
        class basic_ifstream;
template<class _E, class _Tr = char_traits<_E> >
        class basic_ofstream;
template<class _E, class _Tr = char_traits<_E> >
        class basic_fstream;
#line 356
typedef basic_ios<char, char_traits<char> > ios;
typedef basic_streambuf<char, char_traits<char> > streambuf;
typedef basic_istream<char, char_traits<char> > istream;
typedef basic_ostream<char, char_traits<char> > ostream;
typedef basic_iostream<char, char_traits<char> > iostream;
typedef basic_stringbuf<char, char_traits<char>,
        allocator<char> > stringbuf;
typedef basic_istringstream<char, char_traits<char>,
        allocator<char> > istringstream;
typedef basic_ostringstream<char, char_traits<char>,
        allocator<char> > ostringstream;
typedef basic_stringstream<char, char_traits<char>,
        allocator<char> > stringstream;
typedef basic_filebuf<char, char_traits<char> > filebuf;
typedef basic_ifstream<char, char_traits<char> > ifstream;
typedef basic_ofstream<char, char_traits<char> > ofstream;
typedef basic_fstream<char, char_traits<char> > fstream;
#line 375
typedef basic_ios<wchar_t, char_traits<wchar_t> > wios;
typedef basic_streambuf<wchar_t, char_traits<wchar_t> >
        wstreambuf;
typedef basic_istream<wchar_t, char_traits<wchar_t> > wistream;
typedef basic_ostream<wchar_t, char_traits<wchar_t> > wostream;
typedef basic_iostream<wchar_t, char_traits<wchar_t> > wiostream;
typedef basic_stringbuf<wchar_t, char_traits<wchar_t>,
        allocator<wchar_t> > wstringbuf;
typedef basic_istringstream<wchar_t, char_traits<wchar_t>,
        allocator<wchar_t> > wistringstream;
typedef basic_ostringstream<wchar_t, char_traits<wchar_t>,
        allocator<wchar_t> > wostringstream;
typedef basic_stringstream<wchar_t, char_traits<wchar_t>,
        allocator<wchar_t> > wstringstream;
typedef basic_filebuf<wchar_t, char_traits<wchar_t> > wfilebuf;
typedef basic_ifstream<wchar_t, char_traits<wchar_t> > wifstream;
typedef basic_ofstream<wchar_t, char_traits<wchar_t> > wofstream;
typedef basic_fstream<wchar_t, char_traits<wchar_t> > wfstream;
#line 397
};

#pragma namemangling()

#pragma object_model(pop)
#line 408
#pragma info(none)

#  pragma report(pop)

#pragma info(restore)
#line 70 "/usr/vacpp/include/utility"
namespace std {

template<class _T1, class _T2> struct pair {
        typedef _T1 first_type;
        typedef _T2 second_type;
        pair()
                : first(_T1()), second(_T2()) {}
        pair(const _T1& _V1, const _T2& _V2)
                : first(_V1), second(_V2) {}
        template<class _U1, class _U2>
                pair(const pair<_U1, _U2>& _X)
                : first(_X.first), second(_X.second) {}
        _T1 first;
        _T2 second;
        };
template<class _T1, class _T2> inline
        bool operator==(const pair<_T1, _T2>& _X,
                const pair<_T1, _T2>& _Y)
        {return (_X.first == _Y.first && _X.second == _Y.second); }
template<class _T1, class _T2> inline
        bool operator!=(const pair<_T1, _T2>& _X,
                const pair<_T1, _T2>& _Y)
        {return (!(_X == _Y)); }
template<class _T1, class _T2> inline
        bool operator<(const pair<_T1, _T2>& _X,
                const pair<_T1, _T2>& _Y)
        {return (_X.first < _Y.first ||
                !(_Y.first < _X.first) && _X.second < _Y.second); }
template<class _T1, class _T2> inline
        bool operator>(const pair<_T1, _T2>& _X,
                const pair<_T1, _T2>& _Y)
        {return (_Y < _X); }
template<class _T1, class _T2> inline
        bool operator<=(const pair<_T1, _T2>& _X,
                const pair<_T1, _T2>& _Y)
        {return (!(_Y < _X)); }
template<class _T1, class _T2> inline
        bool operator>=(const pair<_T1, _T2>& _X,
                const pair<_T1, _T2>& _Y)
        {return (!(_X < _Y)); }
template<class _T1, class _T2> inline
        pair<_T1, _T2> make_pair(_T1 _X, _T2 _Y)
        {return (pair<_T1, _T2>(_X, _Y)); }

        namespace rel_ops {
template<class _Ty> inline
        bool operator!=(const _Ty& _X, const _Ty& _Y)
        {return (!(_X == _Y)); }
template<class _Ty> inline
        bool operator>(const _Ty& _X, const _Ty& _Y)
        {return (_Y < _X); }
template<class _Ty> inline
        bool operator<=(const _Ty& _X, const _Ty& _Y)
        {return (!(_Y < _X)); }
template<class _Ty> inline
        bool operator>=(const _Ty& _X, const _Ty& _Y)
        {return (!(_X < _Y)); }
        }
#line 277
};
#line 371
#pragma namemangling()

#pragma object_model(pop)
#line 380
#pragma info(none)

#  pragma report(pop)

#pragma info(restore)
#line 70 "/usr/vacpp/include/xutility"
namespace std {
#line 75
struct input_iterator_tag {};
struct output_iterator_tag {};
struct forward_iterator_tag
        : public input_iterator_tag {};
struct bidirectional_iterator_tag
        : public forward_iterator_tag {};
struct random_access_iterator_tag
        : public bidirectional_iterator_tag  {};
struct _Int_iterator_tag {};
#line 86
template<class _C, class _Ty, class _D = ptrdiff_t,
        class _Pt = _Ty *, class _Rt = _Ty&>
        struct iterator {
        typedef _C iterator_category;
        typedef _Ty value_type;
        typedef _D difference_type;
        typedef _Pt pointer;
        typedef _Rt reference;
        };

template<class _Ty, class _D, class _Pt, class _Rt>
        struct _Bidit : public iterator<bidirectional_iterator_tag,
                _Ty, _D, _Pt, _Rt> {};
template<class _Ty, class _D, class _Pt, class _Rt>
        struct _Ranit : public iterator<random_access_iterator_tag,
                _Ty, _D, _Pt, _Rt> {};
struct _Outit : public iterator<output_iterator_tag,
        void, void, void, void> {};
#line 106
template<class _It>
        struct iterator_traits {
        typedef typename _It::iterator_category iterator_category;
        typedef typename _It::value_type value_type;
        typedef typename _It::difference_type difference_type;
        typedef typename _It::pointer pointer;
        typedef typename _It::reference reference;
        };

template<class _Ty>
        struct iterator_traits<_Ty *> {
        typedef random_access_iterator_tag iterator_category;
        typedef _Ty value_type;
        typedef ptrdiff_t difference_type;
        typedef _Ty *pointer;
        typedef _Ty& reference;
        };
template<class _Ty>
        struct iterator_traits<const _Ty *> {
        typedef random_access_iterator_tag iterator_category;
        typedef _Ty value_type;
        typedef ptrdiff_t difference_type;
        typedef const _Ty *pointer;
        typedef const _Ty& reference;
        };

template<> struct iterator_traits<_Bool>
        {        
        typedef _Int_iterator_tag iterator_category;
        };

template<> struct iterator_traits<char>
        {        
        typedef _Int_iterator_tag iterator_category;
        };

template<> struct iterator_traits<signed char>
        {        
        typedef _Int_iterator_tag iterator_category;
        };

template<> struct iterator_traits<unsigned char>
        {        
        typedef _Int_iterator_tag iterator_category;
        };

template<> struct iterator_traits<wchar_t>
        {        
        typedef _Int_iterator_tag iterator_category;
        };

template<> struct iterator_traits<short>
        {        
        typedef _Int_iterator_tag iterator_category;
        };

template<> struct iterator_traits<unsigned short>
        {        
        typedef _Int_iterator_tag iterator_category;
        };

template<> struct iterator_traits<int>
        {        
        typedef _Int_iterator_tag iterator_category;
        };

template<> struct iterator_traits<unsigned int>
        {        
        typedef _Int_iterator_tag iterator_category;
        };

template<> struct iterator_traits<long>
        {        
        typedef _Int_iterator_tag iterator_category;
        };

template<> struct iterator_traits<unsigned long>
        {        
        typedef _Int_iterator_tag iterator_category;
        };
#line 188
template<> struct iterator_traits<long long>
        {        
        typedef _Int_iterator_tag iterator_category;
        };

template<> struct iterator_traits<unsigned long long>
        {        
        typedef _Int_iterator_tag iterator_category;
        };
#line 200
template<class _Iter> inline
        typename iterator_traits<_Iter>::iterator_category
                _Iter_cat(const _Iter&)
        {        
        typename iterator_traits<_Iter>::iterator_category _Cat;
        return (_Cat); }
template<class _C, class _Ty, class _D,
        class _Pt, class _Rt> inline
        _C _Iter_cat(const iterator<_C, _Ty, _D, _Pt, _Rt>&)
        {_C _X;
        return (_X); }
#line 213
template<class _II, class _D> inline
        void _Distance2(_II _F, _II _L, _D& _N,
                input_iterator_tag)
        {for (; _F != _L; ++_F)
                ++_N; }
template<class _II, class _D> inline
        void _Distance2(_II _F, _II _L, _D& _N,
                forward_iterator_tag)
        {for (; _F != _L; ++_F)
                ++_N; }
template<class _II, class _D> inline
        void _Distance2(_II _F, _II _L, _D& _N,
                bidirectional_iterator_tag)
        {for (; _F != _L; ++_F)
                ++_N; }
template<class _RI, class _D> inline
        void _Distance2(_RI _F, _RI _L, _D& _N,
                random_access_iterator_tag)
        {_N += _L - _F; }
template<class _II, class _D> inline
        void _Distance(_II _F, _II _L, _D& _N)
        {_Distance2(_F, _L, _N, _Iter_cat(_F)); }
template<class _II> inline
        typename iterator_traits<_II>::difference_type distance(_II _F, _II _L)
        {typename iterator_traits<_II>::difference_type _N = 0;
        _Distance2(_F, _L, _N, _Iter_cat(_F));
        return (_N); }
#line 242
template<class _Ty, class _D, class _Pt, class _Rt,
        class _Pt2, class _Rt2>
        class _Ptrit : public iterator<random_access_iterator_tag,
                _Ty, _D, _Pt, _Rt> {
public:
        typedef _Ptrit<_Ty, _D, _Pt, _Rt, _Pt2, _Rt2> _Myt;
        _Ptrit()
                {}
        explicit _Ptrit(_Pt _P)
                : current(_P) {}
        _Ptrit(const _Ptrit<_Ty, _D, _Pt2, _Rt2, _Pt2, _Rt2>& _X)
                : current(_X.base()) {}
        _Pt base() const
                {return (current); }
        _Rt operator*() const
                {return (*current); }
        _Pt operator->() const
                {return (&**this); }
        _Myt& operator++()
                {++current;
                return (*this); }
        _Myt operator++(int)
                {_Myt _Tmp = *this;
                ++current;
                return (_Tmp); }
        _Myt& operator--()
                {--current;
                return (*this); }
        _Myt operator--(int)
                {_Myt _Tmp = *this;
                --current;
                return (_Tmp); }
        bool operator==(int _Y) const
                {return (current == (_Pt)_Y); }
        bool operator==(const _Myt& _Y) const
                {return (current == _Y.current); }
        bool operator!=(const _Myt& _Y) const
                {return (!(*this == _Y)); }
        _Myt& operator+=(_D _N)
                {current += _N;
                return (*this); }
        _Myt operator+(_D _N) const
                {return (_Myt(current + _N)); }
        _Myt& operator-=(_D _N)
                {current -= _N;
                return (*this); }
        _Myt operator-(_D _N) const
                {return (_Myt(current - _N)); }
        _Rt operator[](_D _N) const
                {return (*(*this + _N)); }
        bool operator<(const _Myt& _Y) const
                {return (current < _Y.current); }
        bool operator>(const _Myt& _Y) const
                {return (_Y < *this); }
        bool operator<=(const _Myt& _Y) const
                {return (!(_Y < *this)); }
        bool operator>=(const _Myt& _Y) const
                {return (!(*this < _Y)); }
        _D operator-(const _Myt& _Y) const
                {return (current - _Y.current); }
protected:
        _Pt current;
        };

template<class _Ty>
_Ty _GetRawPtr(_Ty _P)
        {return _P; }

template<class _Ty, class _D, class _Pt, class _Rt,
         class _Pt2, class _Rt2>
_Pt _GetRawPtr(const _Ptrit<_Ty, _D, _Pt, _Rt, _Pt2, _Rt2> & _P)
        {return _P.base(); }

template<class _Ty, class _D, class _Pt, class _Rt, class _Pt2, class _Rt2> inline
        bool operator==(const _Ptrit<_Ty, _D, _Pt, _Rt, _Pt, _Rt> &lhs,
                const _Ptrit<_Ty, _D, _Pt2, _Rt2, _Pt, _Rt> &rhs)
        {return (lhs.base() == rhs.base()); }

template<class _Ty, class _D, class _Pt, class _Rt, class _Pt2, class _Rt2> inline
        bool operator!=(const _Ptrit<_Ty, _D, _Pt, _Rt, _Pt, _Rt> &lhs,
                const _Ptrit<_Ty, _D, _Pt2, _Rt2, _Pt, _Rt> &rhs)
        {return (!(lhs == rhs)); }

template<class _Ty, class _D, class _Pt, class _Rt, class _Pt2, class _Rt2> inline
        bool operator<(const _Ptrit<_Ty, _D, _Pt, _Rt, _Pt, _Rt> &lhs,
                const _Ptrit<_Ty, _D, _Pt2, _Rt2, _Pt, _Rt> &rhs)
        {return (lhs.base() < rhs.base()); }

template<class _Ty, class _D, class _Pt, class _Rt, class _Pt2, class _Rt2> inline
        bool operator>(const _Ptrit<_Ty, _D, _Pt, _Rt, _Pt, _Rt> &lhs,
                const _Ptrit<_Ty, _D, _Pt2, _Rt2, _Pt, _Rt> &rhs)
        {return (rhs < lhs); }

template<class _Ty, class _D, class _Pt, class _Rt, class _Pt2, class _Rt2> inline
        bool operator<=(const _Ptrit<_Ty, _D, _Pt, _Rt, _Pt, _Rt> &lhs,
                const _Ptrit<_Ty, _D, _Pt2, _Rt2, _Pt, _Rt> &rhs)
        {return !(rhs < lhs); }

template<class _Ty, class _D, class _Pt, class _Rt, class _Pt2, class _Rt2> inline
        bool operator>=(const _Ptrit<_Ty, _D, _Pt, _Rt, _Pt, _Rt> &lhs,
                const _Ptrit<_Ty, _D, _Pt2, _Rt2, _Pt, _Rt> &rhs)
        {return !(lhs < rhs); }

template<class _Ty, class _D, class _Pt, class _Rt, class _Pt2, class _Rt2> inline
        _D operator-(const _Ptrit<_Ty, _D, _Pt, _Rt, _Pt, _Rt> &lhs,
                const _Ptrit<_Ty, _D, _Pt2, _Rt2, _Pt, _Rt> &rhs)
        {return (lhs.base() - rhs.base()); }

template<class _Ty, class _D, class _Pt, class _Rt,
        class _Pt2, class _Rt2> inline
        _Ptrit<_Ty, _D, _Pt, _Rt, _Pt2, _Rt2>
                operator+(_D _N,
                        const _Ptrit<_Ty, _D, _Pt, _Rt, _Pt2, _Rt2>& _Y)
        {return (_Y + _N); }
#line 358
template<class _RI>
        class reverse_iterator : public iterator<
                typename iterator_traits<_RI>::iterator_category,
                typename iterator_traits<_RI>::value_type,
                typename iterator_traits<_RI>::difference_type,
                typename iterator_traits<_RI>::pointer,
                typename iterator_traits<_RI>::reference> {
public:
        typedef reverse_iterator<_RI> _Myt;
        typedef typename iterator_traits<_RI>::difference_type _D;
        typedef typename iterator_traits<_RI>::pointer _Pt;
        typedef typename iterator_traits<_RI>::reference _Rt;
        typedef _RI iterator_type;
        reverse_iterator()
                {}
        explicit reverse_iterator(_RI _X)
                : current(_X) {}
        template<class _U>
                reverse_iterator(const reverse_iterator<_U>& _X)
                : current(_X.base()) {}
        _RI base() const
                {return (current); }
        _Rt operator*() const
                {_RI _Tmp = current;
                return (*--_Tmp); }
        _Pt operator->() const
                {return (&**this); }
        _Myt& operator++()
                {--current;
                return (*this); }
        _Myt operator++(int)
                {_Myt _Tmp = *this;
                --current;
                return (_Tmp); }
        _Myt& operator--()
                {++current;
                return (*this); }
        _Myt operator--(int)
                {_Myt _Tmp = *this;
                ++current;
                return (_Tmp); }
        bool _Eq(const _Myt& _Y) const
                {return (current == _Y.current); }

        _Myt& operator+=(_D _N)
                {current -= _N;
                return (*this); }
        _Myt operator+(_D _N) const
                {return (_Myt(current - _N)); }
        _Myt& operator-=(_D _N)
                {current += _N;
                return (*this); }
        _Myt operator-(_D _N) const
                {return (_Myt(current + _N)); }
        _Rt operator[](_D _N) const
                {return (*(*this + _N)); }
        bool _Lt(const _Myt& _Y) const
                {return (_Y.current < current); }
        _D _Mi(const _Myt& _Y) const
                {return (_Y.current - current); }
protected:
        _RI current;
        };
#line 423
template<class _RI, class _D> inline
        reverse_iterator<_RI> operator+(_D _N,
                const reverse_iterator<_RI>& _Y)
        {return (_Y + _N); }
template<class _RI> inline
        typename reverse_iterator<_RI>::_D
                operator-(const reverse_iterator<_RI>& _X,
                const reverse_iterator<_RI>& _Y)
        {return (_X._Mi(_Y)); }
template<class _RI> inline
        bool operator==(const reverse_iterator<_RI>& _X,
                const reverse_iterator<_RI>& _Y)
        {return (_X._Eq(_Y)); }
template<class _RI> inline
        bool operator!=(const reverse_iterator<_RI>& _X,
                const reverse_iterator<_RI>& _Y)
        {return (!(_X == _Y)); }
template<class _RI> inline
        bool operator<(const reverse_iterator<_RI>& _X,
                const reverse_iterator<_RI>& _Y)
        {return (_X._Lt(_Y)); }
template<class _RI> inline
        bool operator>(const reverse_iterator<_RI>& _X,
                const reverse_iterator<_RI>& _Y)
        {return (_Y < _X); }
template<class _RI> inline
        bool operator<=(const reverse_iterator<_RI>& _X,
                const reverse_iterator<_RI>& _Y)
        {return (!(_Y < _X)); }
template<class _RI> inline
        bool operator>=(const reverse_iterator<_RI>& _X,
                const reverse_iterator<_RI>& _Y)
        {return (!(_X < _Y)); }
#line 458
  template<class _BI>
        class _Revbidit : public iterator<
                typename iterator_traits<_BI>::iterator_category,
                typename iterator_traits<_BI>::value_type,
                typename iterator_traits<_BI>::difference_type,
                typename iterator_traits<_BI>::pointer,
                typename iterator_traits<_BI>::reference> {
  public:
        typedef _Revbidit<_BI> _Myt;
        typedef typename iterator_traits<_BI>::difference_type _D;
        typedef typename iterator_traits<_BI>::pointer _Pt;
        typedef typename iterator_traits<_BI>::reference _Rt;
        typedef _BI iterator_type;
        _Revbidit()
                {}
        explicit _Revbidit(_BI _X)
                : current(_X) {}
        _BI base() const
                {return (current); }
        _Rt operator*() const
                {_BI _Tmp = current;
                return (*--_Tmp); }
        _Pt operator->() const
                {_Rt _Tmp = **this;
                return (&_Tmp); }
        _Myt& operator++()
                {--current;
                return (*this); }
        _Myt operator++(int)
                {_Myt _Tmp = *this;
                --current;
                return (_Tmp); }
        _Myt& operator--()
                {++current;
                return (*this); }
        _Myt operator--(int)
                {_Myt _Tmp = *this;
                ++current;
                return (_Tmp); }
        bool operator==(const _Myt& _Y) const
                {return (current == _Y.current); }
        bool operator!=(const _Myt& _Y) const
                {return (!(*this == _Y)); }
  protected:
        _BI current;
        };
#line 506
template<class _E, class _Tr>
        class istreambuf_iterator
                : public iterator<input_iterator_tag,
                        _E, typename _Tr::off_type, _E *, _E&> {
public:
        typedef istreambuf_iterator<_E, _Tr> _Myt;
        typedef _E char_type;
        typedef _Tr traits_type;
        typedef basic_streambuf<_E, _Tr> streambuf_type;
        typedef basic_istream<_E, _Tr> istream_type;
        typedef typename traits_type::int_type int_type;

        istreambuf_iterator(streambuf_type *_Sb = 0) throw ()
                : _Sbuf(_Sb), _Got(_Sb == 0) {}
        istreambuf_iterator(istream_type& _I) throw ()
                : _Sbuf(_I.rdbuf()), _Got(_I.rdbuf() == 0) {}
        const _E& operator*() const
                {if (!_Got)
                        ((_Myt *)this)->_Peek();
                return (_Val); }
        const _E *operator->() const
                {return (&**this); }
        _Myt& operator++()
                {_Inc();
                return (*this); }
        _Myt operator++(int)
                {if (!_Got)
                        _Peek();
                _Myt _Tmp = *this;
                _Inc();
                return (_Tmp); }
        bool equal(const _Myt& _X) const;
private:
        void _Inc();
        _E _Peek();
        streambuf_type *_Sbuf;
        bool _Got;
        _E _Val;
        };
#line 547
template<class _E, class _Tr> inline
        bool operator==(const istreambuf_iterator<_E, _Tr>& _X,
                const istreambuf_iterator<_E, _Tr>& _Y)
        {return (_X.equal(_Y)); }
template<class _E, class _Tr> inline
        bool operator!=(const istreambuf_iterator<_E, _Tr>& _X,
                const istreambuf_iterator<_E, _Tr>& _Y)
        {return (!(_X == _Y)); }
#line 557
template<class _E, class _Tr>
        class ostreambuf_iterator
                : public _Outit {
        typedef ostreambuf_iterator<_E, _Tr> _Myt;
public:
        typedef _E char_type;
        typedef _Tr traits_type;
        typedef basic_streambuf<_E, _Tr> streambuf_type;
        typedef basic_ostream<_E, _Tr> ostream_type;

        ostreambuf_iterator(streambuf_type *_Sb) throw ()
                : _Failed(false), _Sbuf(_Sb) {}
        ostreambuf_iterator(ostream_type& _O) throw ()
                : _Failed(false), _Sbuf(_O.rdbuf()) {}
        _Myt& operator=(_E _X)
                {if (_Sbuf == 0
                        || traits_type::eq_int_type(_Tr::eof(),
                                _Sbuf->sputc(_X)))
                        _Failed = true;
                return (*this); }
        _Myt& operator*()
                {return (*this); }
        _Myt& operator++()
                {return (*this); }
        _Myt& operator++(int)
                {return (*this); }
        bool failed() const throw ()
                {return (_Failed); }
private:
        bool _Failed;
        streambuf_type *_Sbuf;
        };
#line 593
template<class _II, class _OI> inline
        _OI copy(_II _F, _II _L, _OI _X)
        {for (; _F != _L; ++_X, ++_F)
                *_X = *_F;
        return (_X); }
#line 600
template<class _BI1, class _BI2> inline
        _BI2 copy_backward(_BI1 _F, _BI1 _L, _BI2 _X)
        {while (_F != _L)
                *--_X = *--_L;
        return (_X); }
#line 607
template<class _II1, class _II2> inline
        bool equal(_II1 _F, _II1 _L, _II2 _X)
        {return (mismatch(_F, _L, _X).first == _L); }
#line 612
template<class _II1, class _II2, class _Pr> inline
        bool equal(_II1 _F, _II1 _L, _II2 _X, _Pr _P)
        {return (mismatch(_F, _L, _X, _P).first == _L); }
#line 617
template<class _FI, class _Ty> inline
        void fill(_FI _F, _FI _L, const _Ty& _X)
        {for (; _F != _L; ++_F)
                *_F = _X; }
#line 623
template<class _OI, class _Sz, class _Ty> inline
        void fill_n(_OI _F, _Sz _N, const _Ty& _X)
        {for (; 0 < _N; --_N, ++_F)
                *_F = _X; }
#line 629
template<class _II1, class _II2>
        bool lexicographical_compare(_II1 _F1, _II1 _L1,
                _II2 _F2, _II2 _L2);
#line 634
template<class _II1, class _II2, class _Pr>
        bool lexicographical_compare(_II1 _F1, _II1 _L1,
                _II2 _F2, _II2 _L2, _Pr _P);
#line 644
template<class _Ty> inline
        const _Ty& max(const _Ty& _X, const _Ty& _Y)
        {return (_X < _Y ? _Y : _X); }

template<class _Ty> inline
        const _Ty& min(const _Ty& _X, const _Ty& _Y)
        {return (_Y < _X ? _Y : _X); }
#line 654
template<class _Ty, class _Pr> inline
        const _Ty& max(const _Ty& _X, const _Ty& _Y, _Pr _P)
        {return (_P(_X, _Y) ? _Y : _X); }

template<class _Ty, class _Pr> inline
        const _Ty& min(const _Ty& _X, const _Ty& _Y, _Pr _P)
        {return (_P(_Y, _X) ? _Y : _X); }
#line 663
template<class _II1, class _II2> inline
        pair<_II1, _II2> mismatch(_II1 _F, _II1 _L, _II2 _X)
        {for (; _F != _L && *_F == *_X; ++_F, ++_X)
                ;
        return (pair<_II1, _II2>(_F, _X)); }
#line 670
template<class _II1, class _II2, class _Pr> inline
        pair<_II1, _II2> mismatch(_II1 _F, _II1 _L, _II2 _X, _Pr _P)
        {for (; _F != _L && _P(*_F, *_X); ++_F, ++_X)
                ;
        return (pair<_II1, _II2>(_F, _X)); }
#line 677
template<class _Ty> inline
        void swap(_Ty& _X, _Ty& _Y)
        {_Ty _Tmp = _X;
        _X = _Y, _Y = _Tmp; }
#line 683
template<class _RanIt,
        class _Base>
        class _Revranit
                : public _Base
        {         
public:
        typedef _Revranit<_RanIt, _Base> _Myt;
         typedef typename _Base::difference_type difference_type;
        typedef typename _Base::pointer pointer;
        typedef typename _Base::reference reference;
        typedef _RanIt iterator_type;

        _Revranit()
                {         
                }

        explicit _Revranit(_RanIt _Right)
                : current(_Right)
                {         
                }

        template<class _RanIt2,
                class _Base2>
                _Revranit(const _Revranit<_RanIt2, _Base2>& _Right)
                : current(_Right.base())
                {         
                }

        _RanIt base() const
                {         
                return (current);
                }

        reference operator*() const
                {         
                _RanIt _Tmp = current;
                return (*--_Tmp);
                }

        pointer operator->() const
                {         
                return (&**this);
                }

        _Myt& operator++()
                {         
                --current;
                return (*this);
                }

        _Myt operator++(int)
                {         
                _Myt _Tmp = *this;
                --current;
                return (_Tmp);
                }

        _Myt& operator--()
                {         
                ++current;
                return (*this);
                }

        _Myt operator--(int)
                {         
                _Myt _Tmp = *this;
                ++current;
                return (_Tmp);
                }

        template<class _RanIt2,
                class _Base2>
                bool _Equal(const _Revranit<_RanIt2, _Base2>& _Right) const
                {         
                return (current == _Right.base());
                }
#line 762
        _Myt& operator+=(difference_type _Off)
                {         
                current -= _Off;
                return (*this);
                }

        _Myt operator+(difference_type _Off) const
                {         
                return (_Myt(current - _Off));
                }

        _Myt& operator-=(difference_type _Off)
                {         
                current += _Off;
                return (*this);
                }

        _Myt operator-(difference_type _Off) const
                {         
                return (_Myt(current + _Off));
                }

        reference operator[](difference_type _Off) const
                {         
                return (*(*this + _Off));
                }

        template<class _RanIt2,
                class _Base2>
                bool _Less(const _Revranit<_RanIt2, _Base2>& _Right) const
                {         
                return (_Right.base() < current);
                }

        template<class _RanIt2,
                class _Base2>
                difference_type _Minus(const _Revranit<_RanIt2, _Base2>& _Right) const
                {         
                return (_Right.base() - current);
                }

protected:
        _RanIt current;         
        };
#line 896
};

#pragma implementation("xutility.t")
#line 32 "/usr/vacpp/include/xutility.t"
namespace std {
template<class _E, class _Tr>
inline
bool istreambuf_iterator<_E, _Tr>::equal(const _Myt& _X) const
        {if (!_Got)
                ((_Myt *)this)->_Peek();
        if (!_X._Got)
                ((_Myt *)&_X)->_Peek();
        return (_Sbuf == 0 && _X._Sbuf == 0
                || _Sbuf != 0 && _X._Sbuf != 0); }

template<class _E, class _Tr>
inline
void istreambuf_iterator<_E, _Tr>::_Inc()
         {if (_Sbuf == 0
                 || traits_type::eq_int_type(traits_type::eof(),
                         _Sbuf->sbumpc()))
                 _Sbuf = 0, _Got = true;
         else
                 _Got = false; }

template<class _E, class _Tr>
inline
_E istreambuf_iterator<_E, _Tr>::_Peek()
        {int_type _C;
        if (_Sbuf == 0
                || traits_type::eq_int_type(traits_type::eof(),
                        _C = _Sbuf->sgetc()))
                _Sbuf = 0;
        else
                _Val = traits_type::to_char_type(_C);
        _Got = true;
        return (_Val); }

template<class _II1, class _II2>
inline
bool lexicographical_compare(_II1 _F1, _II1 _L1, _II2 _F2, _II2 _L2)
        {for (; _F1 != _L1 && _F2 != _L2; ++_F1, ++_F2)
                if (*_F1 < *_F2)
                        return (true);
                else if (*_F2 < *_F1)
                        return (false);
        return (_F1 == _L1 && _F2 != _L2); }

template<class _II1, class _II2, class _Pr>
inline
bool lexicographical_compare(_II1 _F1, _II1 _L1, _II2 _F2, _II2 _L2, _Pr _P)
        {for (; _F1 != _L1 && _F2 != _L2; ++_F1, ++_F2)
                if (_P(*_F1, *_F2))
                        return (true);
                else if (_P(*_F2, *_F1))
                        return (false);
        return (_F1 == _L1 && _F2 != _L2); }

};
#line 904 "/usr/vacpp/include/xutility"
#pragma namemangling()

#pragma object_model(pop)
#line 913
#pragma info(none)

#  pragma report(pop)

#pragma info(restore)
#line 90 "/usr/vacpp/include/xmemory"
extern "C" int __n_pthreads;               
#line 93
namespace std {
#line 96
        inline bool _IsThreaded() {return __n_pthreads != -1; }
        inline bool _IsPotentiallyThreaded() {return __n_pthreads != -1; }
#line 105
class _Pool {
public:
        enum { _BLOCK_SIZE=4096 };
        enum { _ARRAY_SIZE = 128 };

        enum { _ALIGNMENT = sizeof (void *) };
        enum { _MAX_SIZE = _ARRAY_SIZE * _ALIGNMENT };
#line 119
        struct _PoolObj {
                _PoolObj *_Next;
        };
#line 125
        class _Block {
        public:
                _Block() {_Init(); }
                _Block(_Block * _Next, size_t _N) {_Init(_Next, _N); }
                ~_Block() {delete(_NextBlock); }

                _PoolObj * _GetNextFree(size_t _N)
                        {if (_NextFree >= _N)
                                {_NextFree -= _N;
                                return (_PoolObj *)(_Data + _NextFree); }
                        else
                                {return (0); }}

        private:
                _Block(const _Block &);
                _Block & operator=(const _Block &);

                void _Init(_Block * _Next = (0), size_t _N = 1)
                        {_NextFree = _BLOCK_SIZE;
                        _NextBlock = _Next; }

                _PoolObj _Data[_BLOCK_SIZE];

                int             _NextFree;
                _Block          * _NextBlock;
        };
#line 154
        class _BlockList {
        public:
                _BlockList() : _Data((0)) { }
                ~_BlockList() {delete _Data; }

                _PoolObj * _GetNextFree(size_t _N)
                        {_PoolObj * _Ret = (_Data == (0)) ? (0)
                                           : _Data->_GetNextFree(_N);
                        if (_Ret == (0))
                                {_Data = new _Block(_Data, _N);
                                 if (_Data != (0))
                                        {_Ret = _Data->_GetNextFree(_N); }
                                 else
                                        {throw bad_alloc(); }}
                        return _Ret; }
        private:
                _BlockList(const _BlockList &);
                _BlockList & operator=(const _BlockList &);

                _Block * _Data;
        };
#line 178
        class _ObjStack {
        public:
                _ObjStack() : _NextObj((0)) { }

                void _Push(_PoolObj * _Obj)
                        {if (_Obj != (0))
                                {_Obj->_Next = _NextObj;
                                _NextObj = _Obj; }}

                _PoolObj * _Pop()
                         {_PoolObj * _Ret = _NextObj;
                         if (_NextObj != (0))
                                 {_NextObj = _NextObj->_Next; }
                         return _Ret; }

        private:
                _ObjStack(const _ObjStack &);
                _ObjStack & operator=(const _ObjStack &);

                _PoolObj * _NextObj;
        };

        _Pool(size_t _Sz) : _Size(_Sz) { }
        ~_Pool() { }

        void *_Allocate()
                {_PoolObj * _Ret = _FreeStack._Pop();
                if (_Ret == (0))
                        {const size_t _Idx = (_Size + sizeof(_PoolObj) - 1)
                                                     / sizeof(_PoolObj);
                        _Ret = _Data._GetNextFree(_Idx); }
                return _Ret; }

        void _Deallocate(void *_P)
                {_FreeStack._Push((_PoolObj *)_P); }

private:
        _Pool(const _Pool &);
        _Pool & operator=(const _Pool &);

        const size_t _Size;
        _BlockList _Data;
        _ObjStack _FreeStack;
        };
#line 226
class _PoolAllocators {
public:
        static void *_Allocate(size_t _N)
                {void *_Ret;
                if ((_N > _Pool::_MAX_SIZE) ||
                    _IsPotentiallyThreaded())
                        {_Ret = operator new(_N); }
                else
                        {const size_t _Index = (_N - 1) / _Pool::_ALIGNMENT;

                        if (_PoolAllocatorArray[_Index] == (0))
                               {_PoolAllocatorArray[_Index] = new _Pool(_N);
                               if (_PoolAllocatorArray[_Index] == (0))
                                       {throw bad_alloc(); }}

                        _Ret = _PoolAllocatorArray[_Index]->_Allocate(); }

                return _Ret; }

        static void _Deallocate(void *_P, size_t _N)
                {if ((_N > _Pool::_MAX_SIZE) || _IsPotentiallyThreaded())
                        {operator delete(_P); }
                else
                        {const static bool _DeletePtrInitialized =
                                ((_DeletePtr = &::operator delete), true);
                        const size_t _Idx = (_N - 1) / _Pool::_ALIGNMENT;
                        _PoolAllocatorArray[_Idx]->_Deallocate(_P); }}

        ~_PoolAllocators()
                {if (_DeletePtr != (0))
                        {for(int i=0; i<_Pool::_ARRAY_SIZE; ++i)
                                {_DeletePtr(_PoolAllocatorArray[i]); }}}

private:
        _PoolAllocators()
                {for(int i=0; i<_Pool::_ARRAY_SIZE; ++i)
                        {_PoolAllocatorArray[i] = (0); }}

        _PoolAllocators(const _PoolAllocators &);
        _PoolAllocators & operator=(const _PoolAllocators &);

        static _PoolAllocators _PoolAllocatorDestroyer;
        static _Pool *_PoolAllocatorArray[_Pool::_ARRAY_SIZE];

        typedef void (* _Delete_t) (void *);
        static _Delete_t _DeletePtr;
        };
#line 275
template<class _Ty> inline
        _Ty *_Allocate(size_t _N, _Ty *)
        {
#line 281
        _Ty * _Ret = ((_Ty *)operator new(_N * sizeof (_Ty)));

        if (_Ret == (0))
                {throw bad_alloc(); }

        return _Ret;
        }
#line 290
template<class _T1, class _T2> inline
        void _Construct(_T1 *_P, const _T2& _V)
        {new ((void *)_P) _T1(_V); }
template<> inline
       void _Construct(char  *_P, const char & _V)
        { *_P=_V;}
template<> inline
       void _Construct(signed char  *_P, const signed char & _V)
        { *_P=_V;}
template<> inline
       void _Construct(unsigned char  *_P, const unsigned char & _V)
        { *_P=_V;}
template<> inline
       void _Construct(short  *_P, const short & _V)
        { *_P=_V;}
template<> inline
       void _Construct(unsigned short  *_P, const unsigned short& _V)
        { *_P=_V;}
template<> inline
       void _Construct(int  *_P, const int & _V)
        { *_P=_V;}
template<> inline
       void _Construct(unsigned int  *_P, const unsigned int & _V)
        { *_P=_V;}
template<> inline
       void _Construct(long  *_P, const long & _V)
        { *_P=_V;}
template<> inline
       void _Construct(unsigned long  *_P, const unsigned long & _V)
        { *_P=_V;}

template<> inline
       void _Construct(long long  *_P, const long long & _V)
        { *_P=_V;}
template<> inline
       void _Construct(unsigned long long  *_P, const unsigned long long & _V)
        { *_P=_V;}

template<> inline
       void _Construct(float  *_P, const float & _V)
        { *_P=_V;}
template<> inline
       void _Construct(double  *_P, const double & _V)
        { *_P=_V;}
template<> inline
       void _Construct(long double  *_P, const long double & _V)
        { *_P=_V;}
#line 339
template<class _Ty> inline
        void _Destroy(_Ty *_P)
        {_P->_Ty::~_Ty(); }
template<> inline void _Destroy(char *_P)
        {}
template<> inline void _Destroy(signed char *_P)
        {}
template<> inline void _Destroy(unsigned char *_P)
        {}
template<> inline void _Destroy(wchar_t *_P)
        {}
template<> inline void _Destroy(short *_P)
        {}
template<> inline void _Destroy(unsigned short *_P)
        {}
template<> inline void _Destroy(int *_P)
        {}
template<> inline void _Destroy(unsigned int *_P)
        {}
template<> inline void _Destroy(long *_P)
        {}
template<> inline void _Destroy(unsigned long *_P)
        {}

template<> inline void _Destroy(long long *_P)
        {}
template<> inline void _Destroy(unsigned long long  *_P)
        {}

template<> inline void _Destroy(float *_P)
        {}
template<> inline void _Destroy(double *_P)
        {}
template<> inline void _Destroy(long double *_P)
        {}
#line 376
template<class _Ty>
        class allocator {
public:
        typedef size_t size_type;
        typedef ptrdiff_t difference_type;
        typedef _Ty * pointer;
        typedef const _Ty * const_pointer;
        typedef _Ty & reference;
        typedef const _Ty & const_reference;
        typedef _Ty value_type;
        template<class _U>
                struct rebind {
                        typedef allocator<_U> other;
                };
        pointer address(reference _X) const
                {return (&_X); }
        const_pointer address(const_reference _X) const
                {return (&_X); }
        allocator()
                {}
        allocator(const allocator<_Ty>&)
                {}
        template<class _U>
                allocator(const allocator<_U>&)
                {}
        template<class _U>
                allocator<_Ty>& operator=(const allocator<_U>&)
                {return (*this); }
        template<class _U>
                pointer allocate(size_type _N, const _U *)
                {return (_Allocate(_N, (pointer)0)); }
        pointer allocate(size_type _N)
                {return (_Allocate(_N, (pointer)0)); }
        pointer allocate(size_type _N, const void *)
                {return (_Allocate(_N, (pointer)0)); }
        void deallocate(pointer _P, size_type _N)
                {
#line 416
                operator delete(_P);

                }
        void construct(pointer _P, const _Ty& _V)
                {_Construct(_P, _V); }
        void destroy(pointer _P)
                {_Destroy(_P); }
        size_t max_size() const
                {size_t _N = (size_t)(-1) / sizeof (_Ty);
                return (0 < _N ? _N : 1); }
        };
#line 429
template<class _Ty, class _U> inline
        bool operator==(const allocator<_Ty>&, const allocator<_U>&) throw()
        {return (true); }
template<class _Ty, class _U> inline
        bool operator!=(const allocator<_Ty>&, const allocator<_U>&) throw()
        {return (false); }
#line 437
template<> class allocator<void> {
public:
        typedef void _Ty;
        typedef _Ty * pointer;
        typedef const _Ty * const_pointer;
        typedef _Ty value_type;
        template<class _U>
                struct rebind {
                        typedef allocator<_U> other;
                };

        allocator()
                {}
        allocator(const allocator<_Ty>&)
                {}
        template<class _U>
                allocator(const allocator<_U>&)
                {}
        template<class _U>
                allocator<_Ty>& operator=(const allocator<_U>&)
                {return (*this); }
        };
};

#pragma namemangling()

#pragma object_model(pop)
#line 470
#pragma info(none)

#  pragma report(pop)

#pragma info(restore)
#line 84 "/usr/vacpp/include/xstring"
namespace std {

class _String_base {
public:
        void _Xlen() const;
        void _Xran() const;
        };
#line 97
template<class _Ty, class _A>
        class _String_val : public _String_base {
protected:
        typedef typename _A::template
                rebind<_Ty>::other _Alty;
        _String_val(_Alty _Al = _Alty())
                : _Alval(_Al) {}
        _Alty _Alval;
        };
#line 118
template<class _E,
        class _Tr = char_traits<_E>,
        class _Ax = allocator<_E> >
        class basic_string : public _String_val<_E, _Ax> {
public:
        typedef basic_string<_E, _Tr, _Ax> _Myt;
        typedef _String_val<_E, _Ax> _Mybase;
        typedef typename _Mybase::_Alty _A;
        typedef typename _A::size_type size_type;
        typedef typename _A::difference_type difference_type;
        typedef typename _A::pointer _Tptr;
        typedef typename _A::const_pointer _Ctptr;
        typedef _Tptr pointer;
        typedef _Ctptr const_pointer;
        typedef typename _A::reference reference;
        typedef typename _A::const_reference const_reference;
        typedef typename _A::value_type value_type;
        typedef _Ptrit<value_type, difference_type, _Tptr,
                reference, _Tptr, reference> iterator;
        typedef _Ptrit<value_type, difference_type, _Ctptr,
                const_reference, _Tptr, reference> const_iterator;
        typedef typename std::reverse_iterator<iterator>
                reverse_iterator;
        typedef typename std::reverse_iterator<const_iterator>
                const_reverse_iterator;

        basic_string()
                : _Mybase()
                {_Tidy(); }
        explicit basic_string(const _A& _Al)
                : _Mybase(_Al)
                {_Tidy(); }
        basic_string(const _Myt& _X)
                : _Mybase(_X._Alval)
                {_Tidy(), assign(_X, 0, npos); }
        basic_string(const _Myt& _X, size_type _P,
                size_type _M = npos)
                : _Mybase(_X.get_allocator())
                {_Tidy(), assign(_X, _P, _M); }
        basic_string(const _Myt& _X, size_type _P, size_type _M,
                const _A& _Al)
                : _Mybase(_Al)
                {_Tidy(), assign(_X, _P, _M); }
        basic_string(const _E *_S, size_type _N)
                : _Mybase()
                {_Tidy(), assign(_S, _N); }
        basic_string(const _E *_S, size_type _N, const _A& _Al)
                : _Mybase(_Al)
                {_Tidy(), assign(_S, _N); }
        basic_string(const _E *_S)
                : _Mybase()
                {_Tidy(), assign(_S); }
        basic_string(const _E *_S, const _A& _Al)
                : _Mybase(_Al)
                {_Tidy(), assign(_S); }
        basic_string(size_type _N, _E _C)
                : _Mybase()
                {_Tidy(), assign(_N, _C); }
        basic_string(size_type _N, _E _C, const _A& _Al)
                : _Mybase(_Al)
                {_Tidy(), assign(_N, _C); }
        basic_string(iterator _F, iterator _L)
                : _Mybase()
                {_Tidy();
                if (_F != _L)
                        assign(&*_F, _L - _F); }
        basic_string(iterator _F, iterator _L, const _A& _Al)
                : _Mybase(_Al)
                {_Tidy();
                if (_F != _L)
                        assign(&*_F, _L - _F); }
        template<class _It>
                basic_string(_It _F, _It _L)
                : _Mybase()
                {_Construct(_F, _L, _Iter_cat(_F)); }
        template<class _It>
                basic_string(_It _F, _It _L, const _A& _Al)
                : _Mybase(_Al)
                {_Construct(_F, _L, _Iter_cat(_F)); }
        template<class _It>
                void _Construct(_It _F, _It _L, _Int_iterator_tag)
                {_Tidy(), assign((size_type)_F, (_E)_L); }
        template<class _It>
                void _Construct(_It _F, _It _L, input_iterator_tag)
                {_Tidy();
                for (; _F != _L; ++_F)
                        append((size_type)1, (_E)*_F); }
        template<class _It>
                void _Construct(_It _F, _It _L, forward_iterator_tag)
                {_Tidy();
                size_type _M = 0;
                _Distance(_F, _L, _M);
                reserve(_M);
                for (; _F != _L; ++_F)
                        append((size_type)1, (_E)*_F); }
        typedef const_pointer _It;
        basic_string(_It _F, _It _L)
                : _Mybase()
                {_Tidy();
                if (_F != _L)
                        assign(&*_F, _L - _F); }
        basic_string(_It _F, _It _L, const _A& _Al)
                : _Mybase(_Al)
                {_Tidy();
                if (_F != _L)
                        assign(&*_F, _L - _F); }
        ~basic_string()
                {_Tidy(true); }
        typedef _Tr traits_type;
        typedef _A allocator_type;

        enum _Mref {_FROZEN = 255, _MAX_REFS = 254};
#line 238
        static const size_type npos;
        _Myt& operator=(const _Myt& _X)
                {return (assign(_X)); }
        _Myt& operator=(const _E *_S)
                {return (assign(_S)); }
        _Myt& operator=(_E _C)
                {return (assign(1, _C)); }
        _Myt& operator+=(const _Myt& _X)
                {return (append(_X)); }
        _Myt& operator+=(const _E *_S)
                {return (append(_S)); }
        _Myt& operator+=(_E _C)
                {return (append((size_type)1, _C)); }
        _Myt& append(const _Myt& _X)
                {return (append(_X, 0, npos)); }
        _Myt& append(const _Myt& _X, size_type _P, size_type _M);
        _Myt& append(const _E *_S, size_type _M);
        _Myt& append(const _E *_S)
                {return (append(_S, _Tr::length(_S))); }
        _Myt& append(size_type _M, _E _C);
        template<class _It>
                _Myt& append(_It _F, _It _L)
                {return (_Append(_F, _L, _Iter_cat(_F))); }
        template<class _It>
                _Myt& _Append(_It _F, _It _L, _Int_iterator_tag)
                {return (append((size_type)_F, (_E)_L)); }
        template<class _It>
                _Myt& _Append(_It _F, _It _L, input_iterator_tag)
                {return (replace(end(), end(), _F, _L)); }
        _Myt& assign(const _Myt& _X)
                {return (assign(_X, 0, npos)); }
        _Myt& assign(const _Myt& _X, size_type _P, size_type _M);
        _Myt& assign(const _E *_S, size_type _N);
        _Myt& assign(const _E *_S)
                {return (assign(_S, _Tr::length(_S))); }
        _Myt& assign(size_type _N, _E _C);
        template<class _It>
                _Myt& assign(_It _F, _It _L)
                {return (_Assign(_F, _L, _Iter_cat(_F))); }
        template<class _It>
                _Myt& _Assign(_It _F, _It _L, _Int_iterator_tag)
                {return (assign((size_type)_F, (_E)_L)); }
        template<class _It>
                _Myt& _Assign(_It _F, _It _L, input_iterator_tag)
                {return (replace(begin(), end(), _F, _L)); }
        _Myt& insert(size_type _P0, const _Myt& _X)
                {return (insert(_P0, _X, 0, npos)); }
        _Myt& insert(size_type _P0, const _Myt& _X, size_type _P,
                size_type _M);
        _Myt& insert(size_type _P0, const _E *_S, size_type _M);
        _Myt& insert(size_type _P0, const _E *_S)
                {return (insert(_P0, _S, _Tr::length(_S))); }
        _Myt& insert(size_type _P0, size_type _M, _E _C);
        iterator insert(iterator _P)
                {return (insert(_P, _E())); }
        iterator insert(iterator _P, _E _C)
                {size_type _P0 = _Pdif(_P, begin());
                insert(_P0, 1, _C);
                return (begin() + _P0); }
        void insert(iterator _P, size_type _M, _E _C)
                {size_type _P0 = _Pdif(_P, begin());
                insert(_P0, _M, _C); }
        template<class _It>
                void insert(iterator _P, _It _F, _It _L)
                {_Insert(_P, _F, _L, _Iter_cat(_F)); }
        template<class _It>
                void _Insert(iterator _P, _It _F, _It _L,
                        _Int_iterator_tag)
                {insert(_P, (size_type)_F, (_E)_L); }
        template<class _It>
                void _Insert(iterator _P, _It _F, _It _L,
                        input_iterator_tag)
                {replace(_P, _P, _F, _L); }
        _Myt& erase(size_type _P0 = 0, size_type _M = npos);
        iterator erase(iterator _P)
                {size_type _M = _Pdif(_P, begin());
                erase(_M, 1);
                return (iterator(_Psum(_Ptr, _M))); }
        iterator erase(iterator _F, iterator _L)
                {size_type _M = _Pdif(_F, begin());
                erase(_M, _Pdif(_L, _F));
                return (iterator(_Psum(_Ptr, _M))); }
        void clear()
                {erase(begin(), end()); }
        _Myt& replace(size_type _P0, size_type _N0, const _Myt& _X)
                {return (replace(_P0, _N0, _X, 0, npos)); }
        _Myt& replace(size_type _P0, size_type _N0, const _Myt& _X,
                size_type _P, size_type _M);
        _Myt& replace(size_type _P0, size_type _N0, const _E *_S,
                size_type _M);
        _Myt& replace(size_type _P0, size_type _N0, const _E *_S)
                {return (replace(_P0, _N0, _S, _Tr::length(_S))); }
        _Myt& replace(size_type _P0, size_type _N0,
                size_type _M, _E _C);
        _Myt& replace(iterator _F, iterator _L, const _Myt& _X)
                {return (replace(
                        _Pdif(_F, begin()), _Pdif(_L, _F), _X)); }
        _Myt& replace(iterator _F, iterator _L, const _E *_S,
                size_type _M)
                {return (replace(
                        _Pdif(_F, begin()), _Pdif(_L, _F), _S, _M)); }
        _Myt& replace(iterator _F, iterator _L, const _E *_S)
                {return (replace(
                        _Pdif(_F, begin()), _Pdif(_L, _F), _S)); }
        _Myt& replace(iterator _F, iterator _L, size_type _M, _E _C)
                {return (replace(
                        _Pdif(_F, begin()), _Pdif(_L, _F), _M, _C)); }
        template<class _It>
                _Myt& replace(iterator _F1, iterator _L1,
                        _It _F2, _It _L2)
                {return (_Replace(_F1, _L1, _F2, _L2, _Iter_cat(_F2))); }
        template<class _It>
                _Myt& _Replace(iterator _F1, iterator _L1,
                        _It _F2, _It _L2, _Int_iterator_tag)
                {return (replace(_F1, _L1, (size_type)_F2, (_E)_L2)); }
        template<class _It>
                _Myt& _Replace(iterator _F1, iterator _L1,
                        _It _F2, _It _L2, input_iterator_tag)
                {_Myt _X;
                for (; _F2 != _L2; ++_F2)
                        _X.append((size_type)1, (_E)*_F2);
                replace(_F1, _L1, _X);
                return (*this); }
        _Myt& replace(iterator _F1, iterator _L1,
                iterator _F2, iterator _L2);
        _Myt& replace(iterator _F1, iterator _L1,
                _It _F2, _It _L2);
        iterator begin()
                {_Freeze();
                return (iterator(_Ptr)); }
        const_iterator begin() const
                {return (const_iterator(_Ptr)); }
        iterator end()
                {_Freeze();
                return (iterator(_Psum(_Ptr, _Len))); }
        const_iterator end() const
                {return (const_iterator(_Psum(_Ptr, _Len))); }
        reverse_iterator rbegin()
                {return (reverse_iterator(end())); }
        const_reverse_iterator rbegin() const
                {return (const_reverse_iterator(end())); }
        reverse_iterator rend()
                {return (reverse_iterator(begin())); }
        const_reverse_iterator rend() const
                {return (const_reverse_iterator(begin())); }
        reference at(size_type _P0)
                {if (_Len <= _P0)
                        _String_base::_Xran();
                _Freeze();
                return (_Ptr[_P0]); }
        const_reference at(size_type _P0) const
                {if (_Len <= _P0)
                        _String_base::_Xran();
                return (_Ptr[_P0]); }
        reference operator[](size_type _P0)
                {if (_Len < _P0 || _Ptr == 0)
                        return ((reference)*_Nullstr());
                _Freeze();
                return (_Ptr[_P0]); }
        const_reference operator[](size_type _P0) const
                {if (_Ptr == 0)
                        return (*_Nullstr());
                else
                        return (_Ptr[_P0]); }
        void push_back(_E _C)
                {insert(end(), _C); }
        const _E *c_str() const
                {return (_Ptr == 0 ? _Nullstr() : _Ptr); }
        const _E *data() const
                {return (c_str()); }
        size_type length() const
                {return (_Len); }
        size_type size() const
                {return (_Len); }
        size_type max_size() const
                {size_type _N = _Mybase::_Alval.max_size();
                return (_N <= 2 ? 1 : _N - 2); }
        void resize(size_type _N)
                {resize(_N, _E()); }
        void resize(size_type _N, _E _C)
                {_N <= _Len ? erase(_N) : append(_N - _Len, _C); }
        size_type capacity() const
                {return (_Res); }
        void reserve(size_type _N = 0)
                {if (_Res < _N)
                        _Grow(_N); }
        bool empty() const
                {return (_Len == 0); }
        size_type copy(_E *_S, size_type _N, size_type _P0 = 0) const;
        void swap(_Myt& _X);
        size_type find(const _Myt& _X, size_type _P = 0) const
                {return (find(_X.c_str(), _P, _X.size())); }
        size_type find(const _E *_S, size_type _P,
                size_type _N) const;
        size_type find(const _E *_S, size_type _P = 0) const
                {return (find(_S, _P, _Tr::length(_S))); }
        size_type find(_E _C, size_type _P = 0) const
                {return (find((const _E *)&_C, _P, 1)); }
        size_type rfind(const _Myt& _X, size_type _P = npos) const
                {return (rfind(_X.c_str(), _P, _X.size())); }
        size_type rfind(const _E *_S, size_type _P,
                size_type _N) const;
        size_type rfind(const _E *_S, size_type _P = npos) const
                {return (rfind(_S, _P, _Tr::length(_S))); }
        size_type rfind(_E _C, size_type _P = npos) const
                {return (rfind((const _E *)&_C, _P, 1)); }
        size_type find_first_of(const _Myt& _X,
                size_type _P = 0) const
                {return (find_first_of(_X.c_str(), _P, _X.size())); }
        size_type find_first_of(const _E *_S, size_type _P,
                size_type _N) const;
        size_type find_first_of(const _E *_S, size_type _P = 0) const
                {return (find_first_of(_S, _P, _Tr::length(_S))); }
        size_type find_first_of(_E _C, size_type _P = 0) const
                {return (find((const _E *)&_C, _P, 1)); }
        size_type find_last_of(const _Myt& _X,
                size_type _P = npos) const
                {return (find_last_of(_X.c_str(), _P, _X.size())); }
        size_type find_last_of(const _E *_S, size_type _P,
                size_type _N) const;
        size_type find_last_of(const _E *_S,
                size_type _P = npos) const
                {return (find_last_of(_S, _P, _Tr::length(_S))); }
        size_type find_last_of(_E _C, size_type _P = npos) const
                {return (rfind((const _E *)&_C, _P, 1)); }
        size_type find_first_not_of(const _Myt& _X,
                size_type _P = 0) const
                {return (find_first_not_of(_X.c_str(), _P,
                        _X.size())); }
        size_type find_first_not_of(const _E *_S, size_type _P,
                size_type _N) const;
        size_type find_first_not_of(const _E *_S,
                size_type _P = 0) const
                {return (find_first_not_of(_S, _P, _Tr::length(_S))); }
        size_type find_first_not_of(_E _C, size_type _P = 0) const
                {return (find_first_not_of((const _E *)&_C, _P, 1)); }
        size_type find_last_not_of(const _Myt& _X,
                size_type _P = npos) const
                {return (find_last_not_of(_X.c_str(), _P, _X.size())); }
        size_type find_last_not_of(const _E *_S, size_type _P,
                 size_type _N) const;
        size_type find_last_not_of(const _E *_S,
                size_type _P = npos) const
                {return (find_last_not_of(_S, _P, _Tr::length(_S))); }
        size_type find_last_not_of(_E _C, size_type _P = npos) const
                {return (find_last_not_of((const _E *)&_C, _P, 1)); }
        _Myt substr(size_type _P = 0, size_type _M = npos) const
                {return (_Myt(*this, _P, _M)); }
        int compare(const _Myt& _X) const
                {return (compare(0, _Len, _X.c_str(), _X.size())); }
        int compare(size_type _P0, size_type _N0,
                const _Myt& _X) const
                {return (compare(_P0, _N0, _X, 0, npos)); }
        int compare(size_type _P0, size_type _N0, const _Myt& _X,
                size_type _P, size_type _M) const
                {if (_X.size() < _P)
                        _String_base::_Xran();
                if (_X._Len - _P < _M)
                        _M = _X._Len - _P;
                return (compare(_P0, _N0, _X.c_str() + _P, _M)); }
        int compare(const _E *_S) const
                {return (compare(0, _Len, _S, _Tr::length(_S))); }
        int compare(size_type _P0, size_type _N0, const _E *_S) const
                {return (compare(_P0, _N0, _S, _Tr::length(_S))); }
        int compare(size_type _P0, size_type _N0, const _E *_S,
                size_type _M) const;
        allocator_type get_allocator() const
                {return (_Mybase::_Alval); }
private:
        enum {_MIN_SIZE = sizeof (_E) <= 32 ? 31 : 7};
        void _Copy(size_type _N);
        void _Eos(size_type _N)
                {_Tr::assign(_Ptr[_Len = _N], _E()); }
        void _Freeze()
                {if (_Ptr != 0
                        && _Refcnt(_Ptr) != 0 && !__is_frozen(_Ptr))
                        _Grow(_Len);
                if (_Ptr != 0)
                        _Refcnt(_Ptr) = _FROZEN; 
#line 521
		}
        bool _Grow(size_type _N, bool _Trim = false);
        bool _Inside(const _E *_S)
                {return (_Ptr != 0 && _Ptr <= _S && _S <= _Ptr + _Len); }
        static const _E *_Nullstr()
                {static const _E _C = _E();
                return (&_C); }
        static size_type _Pdif(const_iterator _P2,
                const_iterator _P1)
                {return (_P2.base() == 0 ? 0 : _P2 - _P1); }
        static const_pointer _Psum(const_pointer _P, size_type _N)
                {return (_P == 0 ? 0 : _P + _N); }
        static pointer _Psum(pointer _P, size_type _N)
                {return (_P == 0 ? 0 : _P + _N); }
        unsigned char& _Refcnt(const _E *_U)
                {return (((unsigned char *)_U)[-1]); }
        bool  __is_frozen(const _E * _P) {

                    return (__n_pthreads != -1) ? true : (_Refcnt(_P) == _FROZEN);
#line 543
                }
        bool __hasMaxRefs(const _E * _P) {
                    return (_Refcnt(_P) == _MAX_REFS);
                }
        void _Tidy(bool _Built = false);
        void _InitPtr() {

                    _Refcnt(_Ptr) = (__n_pthreads != -1) ? _FROZEN : 0;
#line 561
                }
#line 568
        _E *_Ptr;
        size_type _Len, _Res;
        };

template<class _E, class _Tr, class _A>
        const typename basic_string<_E, _Tr, _A>::size_type
                basic_string<_E, _Tr, _A>::npos =
                        (basic_string<_E, _Tr, _A>::size_type)(-1);

template<class _E, class _Tr, class _A> inline
        void swap(basic_string<_E, _Tr, _A>& _X,
                basic_string<_E, _Tr, _A>& _Y)
        {_X.swap(_Y); }

typedef basic_string<char, char_traits<char>, allocator<char> >
        string;
typedef basic_string<wchar_t, char_traits<wchar_t>,
        allocator<wchar_t> > wstring;
#line 592
};

#pragma implementation("xstring.t")
#line 32 "/usr/vacpp/include/xstring.t"
namespace std {
#line 36
template<class _E, class _Tr, class _Ax>
inline
typename basic_string<_E, _Tr, _Ax>::_Myt&
basic_string<_E, _Tr, _Ax>::append(const _Myt& _X, size_type _P, size_type _M)
        {if (_X.size() < _P)
                _String_base::_Xran();
        size_type _N = _X.size() - _P;
        if (_N < _M)
                _M = _N;
        if (max_size() - _Len < _M)
                _String_base::_Xlen();
        if (0 < _M && _Grow(_N = _Len + _M))
                {_Tr::copy(_Ptr + _Len, &_X.c_str()[_P], _M);
                _Eos(_N); }
        return (*this); }

template<class _E, class _Tr, class _Ax>
inline
typename basic_string<_E, _Tr, _Ax>::_Myt&
basic_string<_E, _Tr, _Ax>::append(const _E *_S, size_type _M)
        {if (_Inside(_S))
                return (append(*this, _S - _Ptr, _M));
        if (max_size() - _Len < _M)
                _String_base::_Xlen();
        size_type _N;
        if (0 < _M && _Grow(_N = _Len + _M))
                {_Tr::copy(_Ptr + _Len, _S, _M);
                _Eos(_N); }
        return (*this); }

template<class _E, class _Tr, class _Ax>
inline
typename basic_string<_E, _Tr, _Ax>::_Myt&
basic_string<_E, _Tr, _Ax>::append(size_type _M, _E _C)
        {
        if (max_size() - _Len < _M)
                _String_base::_Xlen();
        size_type _N;
        if (0 < _M && _Grow(_N = _Len + _M))
                {_Tr::assign(_Ptr + _Len, _M, _C);
                _Eos(_N); }
        return (*this); }

template<class _E, class _Tr, class _Ax>
inline
typename basic_string<_E, _Tr, _Ax>::_Myt&
basic_string<_E, _Tr, _Ax>::assign(const _Myt& _X, size_type _P, size_type _M)
        {if (_X.size() < _P)
                _String_base::_Xran();
        size_type _N = _X.size() - _P;
        if (_M < _N)
                _N = _M;
        if (this == &_X)
                erase((size_type)(_P + _N)), erase(0, _P);
        else if (0 < _N && _N == _X.size()
                && !__is_frozen(_X.c_str())
                && !__hasMaxRefs(_X.c_str())
                && _Mybase::_Alval == _X._Alval)
                {_Tidy(true);
                _Ptr = (_E *)_X.c_str();
                _Len = _X.size();
                _Res = _X.capacity();
                ++_Refcnt(_Ptr); }
        else if (_Ptr && _Refcnt(_Ptr)) 
                {_Tidy(true);
                if (_Grow(_N, true))
                        {_Tr::copy(_Ptr, &_X.c_str()[_P], _N);
                        _Eos(_N); } }
        else if (_Grow(_N, true))
                {_Tr::copy(_Ptr, &_X.c_str()[_P], _N);
                _Eos(_N); }
        return (*this); }

template<class _E, class _Tr, class _Ax>
inline
typename basic_string<_E, _Tr, _Ax>::_Myt&
basic_string<_E, _Tr, _Ax>::assign(const _E *_S, size_type _N)
        {if (_Inside(_S))
                return (assign(*this, _S - _Ptr, _N));
        if (_Ptr && _Refcnt(_Ptr)) 
                {_Tidy(true);
                if (_Grow(_N, true))
                        {_Tr::copy(_Ptr, _S, _N);
                        _Eos(_N); } }
        else if (_Grow(_N, true))
                {_Tr::copy(_Ptr, _S, _N);
                _Eos(_N); }
        return (*this); }

template<class _E, class _Tr, class _Ax>
inline
typename basic_string<_E, _Tr, _Ax>::_Myt&
basic_string<_E, _Tr, _Ax>::assign(size_type _N, _E _C)
        {if (_N == max_size())
                _String_base::_Xlen();
        if (_Grow(_N, true))
                {_Tr::assign(_Ptr, _N, _C);
                _Eos(_N); }
        return (*this); }

template<class _E, class _Tr, class _Ax>
inline
typename basic_string<_E, _Tr, _Ax>::_Myt& basic_string<_E, _Tr, _Ax>
        ::insert(size_type _P0, const _Myt& _X, size_type _P, size_type _M)
        {if (_Len < _P0 || _X.size() < _P)
                _String_base::_Xran();
        size_type _N = _X.size() - _P;
        if (_N < _M)
                _M = _N;
        if (max_size() - _Len < _M)
                _String_base::_Xlen();
        if (0 < _M && _Grow(_N = _Len + _M))
                {_Tr::move(_Ptr + _P0 + _M, _Ptr + _P0, _Len - _P0);
                if (this == &_X)
                        _Tr::move(_Ptr + _P0,
                                _Ptr + (_P0 < _P ? _P + _M : _P), _M);
                else
                        _Tr::copy(_Ptr + _P0, &_X.c_str()[_P], _M);
                _Eos(_N); }
        return (*this); }

template<class _E, class _Tr, class _Ax>
inline
typename basic_string<_E, _Tr, _Ax>::_Myt&
basic_string<_E, _Tr, _Ax>::insert(size_type _P0, const _E *_S, size_type _M)
        {if (_Inside(_S))
                return (insert(_P0, *this, _S - _Ptr, _M));
        if (_Len < _P0)
                _String_base::_Xran();
        if (max_size() - _Len < _M)
                _String_base::_Xlen();
        size_type _N;
        if (0 < _M && _Grow(_N = _Len + _M))
                {_Tr::move(_Ptr + _P0 + _M, _Ptr + _P0, _Len - _P0);
                _Tr::copy(_Ptr + _P0, _S, _M);
                _Eos(_N); }
        return (*this); }
#line 175
template<class _E, class _Tr, class _Ax>
inline
typename basic_string<_E, _Tr, _Ax>::_Myt&
basic_string<_E, _Tr, _Ax>::insert(size_type _P0, size_type _M, _E _C)
        {if (_Len < _P0)
                _String_base::_Xran();
        if (max_size() - _Len < _M)
                _String_base::_Xlen();
        size_type _N;
        if (0 < _M && _Grow(_N = _Len + _M))
                {_Tr::move(_Ptr + _P0 + _M, _Ptr + _P0, _Len - _P0);
                _Tr::assign(_Ptr + _P0, _M, _C);
                _Eos(_N); }
        return (*this); }

template<class _E, class _Tr, class _Ax>
inline
typename basic_string<_E, _Tr, _Ax>::_Myt&
basic_string<_E, _Tr, _Ax>::erase(size_type _P0, size_type _M)
        {if (_Len < _P0)
                _String_base::_Xran();
        if (_Len - _P0 < _M)
                _M = _Len - _P0;
        if (0 < _M)
                {_Freeze();
                _Tr::move(_Ptr + _P0, _Ptr + _P0 + _M,
                        _Len - _P0 - _M);
                size_type _N = _Len - _M;
                if (_Grow(_N))
                        _Eos(_N); }
        return (*this); }

template<class _E, class _Tr, class _Ax>
inline
typename basic_string<_E, _Tr, _Ax>::_Myt&
basic_string<_E, _Tr, _Ax>::replace(size_type _P0, size_type _N0, const _Myt& _X,
        size_type _P, size_type _M)
        {if (_Len < _P0 || _X.size() < _P)
                _String_base::_Xran();
        if (_Len - _P0 < _N0)
                _N0 = _Len - _P0;
        size_type _N = _X.size() - _P;
        if (_N < _M)
                _M = _N;
        if ((_M > max_size() ? 0 : max_size() - _M) < _Len - _N0)
                _String_base::_Xlen();
        size_type _Nm = _Len - _N0 - _P0;
        _N = _Len + _M - _N0;
        if (_Len < _N)
                _Grow(_N);
        else if (0 < _M || 0 < _N0)
                _Freeze();
        if (this != &_X)
                {_Tr::move(_Ptr + _P0 + _M, _Ptr + _P0 + _N0, _Nm);
                _Tr::copy(_Ptr + _P0, &_X.c_str()[_P], _M); }
        else if (_M <= _N0)
                {_Tr::move(_Ptr + _P0, _Ptr + _P, _M);
                _Tr::move(_Ptr + _P0 + _M, _Ptr + _P0 + _N0, _Nm); }
        else if (_P <= _P0)
                {_Tr::move(_Ptr + _P0 + _M, _Ptr + _P0 + _N0, _Nm);
                _Tr::move(_Ptr + _P0, _Ptr + _P, _M); }
        else if (_P0 + _N0 <= _P)
                {_Tr::move(_Ptr + _P0 + _M, _Ptr + _P0 + _N0, _Nm);
                _Tr::move(_Ptr + _P0, _Ptr + (_P + _M - _N0), _M); }
        else
                {_Tr::move(_Ptr + _P0, _Ptr + _P, _N0);
                _Tr::move(_Ptr + _P0 + _M, _Ptr + _P0 + _N0, _Nm);
                _Tr::move(_Ptr + _P0 + _N0, _Ptr + _P + _M,
                        _M - _N0); }
        if (_Len < _N || _Grow(_N))
                _Eos(_N);
        return (*this); }

template<class _E, class _Tr, class _Ax>
inline
typename basic_string<_E, _Tr, _Ax>::_Myt&
basic_string<_E, _Tr, _Ax>::replace(size_type _P0, size_type _N0, const _E *_S,
        size_type _M)
        {if (_Inside(_S))
                return (replace(_P0, _N0, *this, _S - _Ptr, _M));
        if (_Len < _P0)
                _String_base::_Xran();
        if (_Len - _P0 < _N0)
                _N0 = _Len - _P0;
        if ((_M > max_size() ? 0 : max_size() - _M) < _Len - _N0)
                _String_base::_Xlen();
        size_type _Nm = _Len - _N0 - _P0;
        if (_M < _N0)
                {_Freeze();
                _Tr::move(_Ptr + _P0 + _M, _Ptr + _P0 + _N0, _Nm); }
        size_type _N;
        if ((0 < _M || 0 < _N0) && _Grow(_N = _Len + _M - _N0))
                {if (_N0 < _M)
                        _Tr::move(_Ptr + _P0 + _M, _Ptr + _P0 + _N0, _Nm);
                _Tr::copy(_Ptr + _P0, _S, _M);
                _Eos(_N); }
        return (*this); }

template<class _E, class _Tr, class _Ax>
inline
typename basic_string<_E, _Tr, _Ax>::_Myt&
basic_string<_E, _Tr, _Ax>::replace(size_type _P0, size_type _N0,
                size_type _M, _E _C)
        {if (_Len < _P0)
                _String_base::_Xran();
        if (_Len - _P0 < _N0)
                _N0 = _Len - _P0;
        if ((_M > max_size() ? 0 : max_size() - _M) < _Len - _N0)
                _String_base::_Xlen();
        size_type _Nm = _Len - _N0 - _P0;
        if (_M < _N0)
                {_Freeze();
                _Tr::move(_Ptr + _P0 + _M, _Ptr + _P0 + _N0, _Nm); }
        size_type _N;
        if ((0 < _M || 0 < _N0) && _Grow(_N = _Len + _M - _N0))
                {if (_N0 < _M)
                        _Tr::move(_Ptr + _P0 + _M, _Ptr + _P0 + _N0, _Nm);
                _Tr::assign(_Ptr + _P0, _M, _C);
                _Eos(_N); }
        return (*this); }

template<class _E, class _Tr, class _Ax>
inline
typename basic_string<_E, _Tr, _Ax>::_Myt&
basic_string<_E, _Tr, _Ax>::replace(iterator _F1, iterator _L1,
        iterator _F2, iterator _L2)
        {if (_F2 == _L2)
                erase(_Pdif(_F1, begin()), _Pdif(_L1, _F1));
        else
                replace(_Pdif(_F1, begin()), _Pdif(_L1, _F1),
                        &*_F2, _L2 - _F2);
        return (*this); }

template<class _E, class _Tr, class _Ax>
inline
typename basic_string<_E, _Tr, _Ax>::_Myt&
basic_string<_E, _Tr, _Ax>::replace(iterator _F1, iterator _L1,
        _It _F2, _It _L2)
        {if (_F2 == _L2)
                erase(_Pdif(_F1, begin()), _Pdif(_L1, _F1));
        else
                replace(_Pdif(_F1, begin()), _Pdif(_L1, _F1),
                        &*_F2, _L2 - _F2);
        return (*this); }
#line 321
template<class _E, class _Tr, class _Ax>
inline
typename basic_string<_E, _Tr, _Ax>::size_type
basic_string<_E, _Tr, _Ax>::copy(_E *_S, size_type _N, size_type _P0) const
        {if (_Len < _P0)
                _String_base::_Xran();
        if (_Len - _P0 < _N)
                _N = _Len - _P0;
        if (0 < _N)
                _Tr::copy(_S, _Ptr + _P0, _N);
        return (_N); }

template<class _E, class _Tr, class _Ax>
inline
void basic_string<_E, _Tr, _Ax>::swap(_Myt& _X)
        {if (_Mybase::_Alval == _X._Alval)
                {_E *_Tptr = _Ptr;
                _Ptr = _X._Ptr, _X._Ptr = _Tptr;
                size_type _Tlen = _Len;
                _Len = _X._Len, _X._Len = _Tlen;
                size_type _Tres = _Res;
                _Res = _X._Res, _X._Res = _Tres; }
        else
                {_Myt _Ts = *this; *this = _X, _X = _Ts; }}

template<class _E, class _Tr, class _Ax>
inline
typename basic_string<_E, _Tr, _Ax>::size_type
basic_string<_E, _Tr, _Ax>::find(const _E *_S, size_type _P,
        size_type _N) const
        {if (_N == 0 && _P <= _Len)
                return (_P);
        size_type _Nm;
        if (_P < _Len && _N <= (_Nm = _Len - _P))
                {const _E *_U, *_V;
                for (_Nm -= _N - 1, _V = _Ptr + _P;
                        (_U = _Tr::find(_V, _Nm, *_S)) != 0;
                        _Nm -= _U - _V + 1, _V = _U + 1)
                        if (_Tr::compare(_U, _S, _N) == 0)
                                return (_U - _Ptr); }
        return (npos); }

template<class _E, class _Tr, class _Ax>
inline
typename basic_string<_E, _Tr, _Ax>::size_type
basic_string<_E, _Tr, _Ax>::rfind(const _E *_S, size_type _P,
        size_type _N) const
        {if (_N == 0)
                return (_P < _Len ? _P : _Len);
        if (_N <= _Len)
                for (const _E *_U = _Ptr +
                        + (_P < _Len - _N ? _P : _Len - _N); ; --_U)
                        if (_Tr::eq(*_U, *_S)
                                && _Tr::compare(_U, _S, _N) == 0)
                                return (_U - _Ptr);
                        else if (_U == _Ptr)
                                break;
        return (npos); }

template<class _E, class _Tr, class _Ax>
inline
typename basic_string<_E, _Tr, _Ax>::size_type
basic_string<_E, _Tr, _Ax>::find_first_of(const _E *_S, size_type _P,
        size_type _N) const
        {if (_N == max_size())
          _String_base::_Xlen();
        if (0 < _N && _P < _Len)
                {const _E *const _V = _Ptr + _Len;
                for (const _E *_U = _Ptr + _P; _U < _V; ++_U)
                        if (_Tr::find(_S, _N, *_U) != 0)
                                return (_U - _Ptr); }
        return (npos); }

template<class _E, class _Tr, class _Ax>
inline
typename basic_string<_E, _Tr, _Ax>::size_type
basic_string<_E, _Tr, _Ax>::find_last_of(const _E *_S, size_type _P,
        size_type _N) const
        {if (_N == max_size())
          _String_base::_Xlen();
        if (0 < _N && 0 < _Len)
                for (const _E *_U = _Ptr
                        + (_P < _Len ? _P : _Len - 1); ; --_U)
                        if (_Tr::find(_S, _N, *_U) != 0)
                                return (_U - _Ptr);
                        else if (_U == _Ptr)
                                break;
        return (npos); }

template<class _E, class _Tr, class _Ax>
inline
typename basic_string<_E, _Tr, _Ax>::size_type
basic_string<_E, _Tr, _Ax>::find_first_not_of(const _E *_S, size_type _P,
        size_type _N) const
        {if (_P < _Len)
                {const _E *const _V = _Ptr + _Len;
                for (const _E *_U = _Ptr + _P; _U < _V; ++_U)
                        if (_Tr::find(_S, _N, *_U) == 0)
                                return (_U - _Ptr); }
        return (npos); }

template<class _E, class _Tr, class _Ax>
inline
typename basic_string<_E, _Tr, _Ax>::size_type
basic_string<_E, _Tr, _Ax>::find_last_not_of(const _E *_S, size_type _P,
         size_type _N) const
        {if (0 < _Len)
                for (const _E *_U = _Ptr
                        + (_P < _Len ? _P : _Len - 1); ; --_U)
                        if (_Tr::find(_S, _N, *_U) == 0)
                                return (_U - _Ptr);
                        else if (_U == _Ptr)
                                break;
        return (npos); }

template<class _E, class _Tr, class _Ax>
inline
int basic_string<_E, _Tr, _Ax>::compare(size_type _P0, size_type _N0, const _E *_S,
                size_type _M) const
        {if (_Len < _P0)
                _String_base::_Xran();
        if (_Len - _P0 < _N0)
                _N0 = _Len - _P0;
        size_type _Ans = _Tr::compare(_Psum(_Ptr, _P0), _S,
                _N0 < _M ? _N0 : _M);
        return (_Ans != 0 ? _Ans : _N0 < _M ? -1
                : _N0 == _M ? 0 : +1); }

template<class _E, class _Tr, class _Ax>
inline
void basic_string<_E, _Tr, _Ax>::_Copy(size_type _N)
        {size_type _Ns = _N | _MIN_SIZE;
        if (max_size() < _Ns)
                _Ns = _N;
        _E *_S;
        try {
                _S = _Mybase::_Alval.allocate(_Ns + 2, (void *)0);
        } catch (...) {
                _Ns = _N;
                _S = _Mybase::_Alval.allocate(_Ns + 2, (void *)0);
        }
        if (0 < _Len)
                _Tr::copy(_S + 1, _Ptr, _Len);
        size_type _Olen = _Len;
        _Tidy(true);
        _Ptr = _S + 1;
        _InitPtr();
        _Res = _Ns;
        _Eos(_Olen); }

template<class _E, class _Tr, class _Ax>
inline
bool basic_string<_E, _Tr, _Ax>::_Grow(size_type _N, bool _Trim)
        {if (max_size() < _N)
                _String_base::_Xlen();
        if (_Trim)
                _Len = 0;
        else if (_N < _Len)
                _Len = _N;
        if (_Ptr != 0
                && _Refcnt(_Ptr) != 0 && !__is_frozen(_Ptr) && !__hasMaxRefs(_Ptr))
                if (_N == 0)
                        {_Tidy(true);
                        return (false); }
                else
                        {_Copy(_N);
                        return (true); }
        if (_N == 0)
                {if (_Trim)
                        _Tidy(true);
                else if (_Ptr != 0)
                        _Eos(0);
                return (false); }
        else
                {if (_Trim && (_MIN_SIZE < _Res || _Res < _N))
                        {_Tidy(true);
                        _Copy(_N); }
                else if (!_Trim && _Res < _N)
                        {size_type _Inc = _Res / 2;
                        _Copy(_N - _Inc < _Res
                                && _Res <= max_size() - _Inc
                                        ? _Res + _Inc : _N); }
                return (true); }}

template<class _E, class _Tr, class _Ax>
inline
void basic_string<_E, _Tr, _Ax>::_Tidy(bool _Built)
        {if (!_Built || _Ptr == 0)
                ;
        else if (_Refcnt(_Ptr) == 0 || __is_frozen(_Ptr))
                _Mybase::_Alval.deallocate(_Ptr - 1, _Res + 2);
        else
                --_Refcnt(_Ptr);
        _Ptr = 0, _Len = 0, _Res = 0; }
#line 522
};
#line 600 "/usr/vacpp/include/xstring"
#pragma namemangling()

#pragma object_model (pop)
#line 609
#pragma info(none)

#  pragma report(pop)

#pragma info(restore)
#line 63 "/usr/vacpp/include/stdexcept"
namespace std {

class logic_error : public exception {
public:
        explicit logic_error(const string& _S)
                : exception("logic error"), _Str(_S) {}
        virtual ~logic_error()
                {}
        virtual const char *what() const throw ()
                {return (_Str.c_str()); }
protected:
        virtual void _Doraise() const
                {throw (*this); }
private:
        string _Str;
        };

class domain_error : public logic_error {
public:
        explicit domain_error(const string& _S)
                : logic_error(_S) {}
        virtual ~domain_error()
                {}
protected:
        virtual void _Doraise() const
                {throw (*this); }
        };

class invalid_argument : public logic_error {
public:
        explicit invalid_argument(const string& _S)
                : logic_error(_S) {}
        virtual ~invalid_argument()
                {}
protected:
        virtual void _Doraise() const
                {throw (*this); }
        };

class length_error : public logic_error {
public:
        explicit length_error(const string& _S)
                : logic_error(_S) {}
        virtual ~length_error()
                {}
protected:
        virtual void _Doraise() const
                {throw (*this); }
        };

class out_of_range : public logic_error {
public:
        explicit out_of_range(const string& _S)
                : logic_error(_S) {}
        virtual ~out_of_range()
                {}
protected:
        virtual void _Doraise() const
                {throw (*this); }
        };

class runtime_error : public exception {
public:
        explicit runtime_error(const string& _S)
                : exception("runtime error"), _Str(_S) {}
        virtual ~runtime_error()
                {}
        virtual const char *what() const throw ()
                {return (_Str.c_str()); }
protected:
        virtual void _Doraise() const
                {throw (*this); }
private:
        string _Str;
        };

class overflow_error : public runtime_error {
public:
        explicit overflow_error(const string& _S)
                : runtime_error(_S) {}
        virtual ~overflow_error()
                {}
protected:
        virtual void _Doraise() const
                {throw (*this); }
        };

class underflow_error : public runtime_error {
public:
        explicit underflow_error(const string& _S)
                : runtime_error(_S) {}
        virtual ~underflow_error()
                {}
protected:
        virtual void _Doraise() const
                {throw (*this); }
        };

class range_error : public runtime_error {
public:
        explicit range_error(const string& _S)
                : runtime_error(_S) {}
        virtual ~range_error()
                {}
protected:
        virtual void _Doraise() const
                {throw (*this); }
        };
};

#pragma namemangling()

#pragma object_model(pop)
#line 178
#pragma info(none)

#  pragma report(pop)

#pragma info(restore)
#line 4 "/usr/vacpp/include/typeinfo"
#pragma info(none)

#  pragma report(level, E)

#pragma info(restore)
#line 19
#pragma object_model (compat)
#line 29
  #pragma namemangling(v7)
#line 56
namespace std {
class type_info {
  public:
    virtual             ~type_info();
    bool                operator==(const type_info&) const;
    bool                operator!=(const type_info&) const;
    bool                before(const type_info&) const;
    const char*         name() const;

  private:
                        type_info(const type_info&);
    type_info&          operator=(const type_info&);

  protected:
    char *              typeName;

    char *              mangledName;

};

inline const char * type_info::name() const {
  return typeName;
}

inline bool type_info::operator==(const type_info&x) const {
#line 84
  return (&x==this) || (strcmp(x.mangledName,this->mangledName)==0);

}

inline bool type_info::operator!=(const type_info&x) const {
#line 92
  return (&x!=this) && (strcmp(x.mangledName,this->mangledName)!=0);

}

inline bool type_info::before(const type_info&x) const {
#line 100
  return (&x!=this) && (strcmp(x.mangledName,this->mangledName)>=0);

}
#line 105
class bad_cast : public exception {
public:
        bad_cast(const char *_S =

	    "bad cast"
#line 115
	    ) throw ()
                : exception(_S) {}
        virtual ~bad_cast() throw ()
                {}
protected:
        virtual void _Doraise() const
                {throw (*this); }
        };

class bad_typeid : public exception {
public:
        bad_typeid(const char *_S =

	    "bad typeid"
#line 134
	    ) throw ()
                : exception(_S) {}
        virtual ~bad_typeid() throw ()
                {}
protected:
        virtual void _Doraise() const
                {throw (*this); }
        };

class __non_rtti_object : public bad_typeid{
public:
        __non_rtti_object( const char *_S =

	    "non rtti object"
#line 153
	    ) throw ()
                : bad_typeid( _S ) {}
        };
};

#pragma namemangling()
#line 161
#pragma object_model (pop)
#line 168
#pragma info(none)

#  pragma report(pop)

#pragma info(restore)
#line 13 "/usr/vacpp/include/xlocinfo"
#pragma info(none)

#  pragma report(level, E)

#pragma info(restore)
#line 46
#pragma object_model(compat)
#line 51
  #pragma namemangling(v7)
#line 13 "/usr/vacpp/include/xlocinfo.h"
#pragma info(none)

#  pragma report(level, E)

#pragma info(restore)
#line 46
#pragma object_model(compat)
#line 51
  #pragma namemangling(v7)
extern "C" {
#line 73 "/usr/include/ctype.h"
	extern int	isalpha(int);
	extern int	isalnum(int);

	extern int      isblank(int);

	extern int	iscntrl(int);
	extern int	isdigit(int);
	extern int	isgraph(int);
	extern int	islower(int);
	extern int	isprint(int);
	extern int	ispunct(int);
	extern int	isspace(int);
	extern int	isupper(int);
	extern int	isxdigit(int);
	extern int	toupper(int);
	extern int	tolower(int);
#line 118
	extern int	isascii(int);
	extern int	toascii(int);
#line 137
	extern int	is_wctype(wint_t, wctype_t);
	extern wctype_t	get_wctype(char *);
}
#line 142 "/usr/vacpp/include/xlocinfo.h"
typedef struct _Collvec {
#line 145
        __xlocale_ptr _Ptr;
#line 149
        } _Collvec;

typedef struct _Ctypevec {
#line 154
        __xlocale_ptr _Ptr;
#line 158
        const short *_Table;
        int _Delfl;

        } _Ctypevec;

typedef struct _Cvtvec {
#line 166
        __xlocale_ptr _Ptr;
#line 171
        } _Cvtvec;
#line 174
_Collvec _Getcoll(const char *);
_Ctypevec _Getctype(const char *);
_Cvtvec _Getcvt(const char *);
void *_Gettnames(const char *);
lconv *_Getmonpunct(const char *);
lconv *_Getnumpunct(const char *);

extern "C" {
        _Collvec _Getcoll();
        _Ctypevec _Getctype();
        _Cvtvec _Getcvt();
        char *_Getdays();
        char *_Getmonths();
        void *_Gettnames();
        int _Mbrtowc(wchar_t *, const char *, size_t,
                mbstate_t *, const _Cvtvec *);
        extern float _Stof(const char *, char **, long);
        extern double _Stod(const char *, char **, long);
        extern long double _Stold(const char *, char **, long);
        int _Strcoll(const char *, const char *,
                const char *, const char *, const _Collvec *);
        size_t _Strftime(char *, size_t, const char *,
                const struct tm *, void *);
        size_t _Strxfrm(char *, char *,
                const char *, const char *, const _Collvec *);
        int _Tolower(int, const _Ctypevec *);
        int _Toupper(int, const _Ctypevec *);
        int _Towlower(int, const _Ctypevec *);
        int _Towupper(int, const _Ctypevec *);
        int _Wcrtomb(char *, wchar_t, mbstate_t *,
                const _Cvtvec *);
        int _Wcscoll(const wchar_t *, const wchar_t *,
                const wchar_t *, const wchar_t *, const _Collvec *);
        size_t _Wcsxfrm(wchar_t *, wchar_t *,
                const wchar_t *, const wchar_t *, const _Collvec *);
        bool _DoIs(short, char, const _Ctypevec *);
        bool _DoIsW(short, wchar_t, const _Ctypevec *);
}

#pragma namemangling()

#pragma object_model(pop)
#line 222
#pragma info(none)

#  pragma report(pop)

#pragma info(restore)
#line 78 "/usr/vacpp/include/xlocinfo"
namespace std {
#line 83
class _Timevec {
public:
        _Timevec(void *_P = 0)
                : _Ptr(_P) {}
        _Timevec(const _Timevec& _Rhs)
                {*this = _Rhs; }
        ~_Timevec() {}
        _Timevec& operator=(const _Timevec& _Rhs)
                {_Ptr = _Rhs._Ptr;
                ((_Timevec *)&_Rhs)->_Ptr = 0;
                return (*this); }
        void *_Getptr() const
                {return (_Ptr); }
private:
        void *_Ptr;
        };
#line 101
class _Locinfo {
public:
        typedef :: _Collvec _Collvec;
        typedef :: _Ctypevec _Ctypevec;
        typedef :: _Cvtvec _Cvtvec;
        typedef std::_Timevec _Timevec;

        _Locinfo(const char * = "C", int = 0);
#line 115
        _Locinfo(int, const char *);
        ~_Locinfo();
        _Locinfo& _Addcats(int, const char *);
        _Locinfo& _Addcats2(int, const char *);
        string _Getname() const
                {return (_Nname.c_str()); }
        _Collvec _Getcoll() const
                {return (::_Getcoll(_Nname.c_str())); }
        _Ctypevec _Getctype() const
                {return (::_Getctype(_Nname.c_str())); }
        _Cvtvec _Getcvt() const
                {return (::_Getcvt(_Nname.c_str())); }
        _Timevec _Gettnames() const
                {return (_Timevec(::_Gettnames(_Nname.c_str()))); }
        const lconv *_Getmonpunct() const
                {return (::_Getmonpunct(_Nname.c_str())); }
        const lconv *_Getnumpunct() const
                {return (::_Getnumpunct(_Nname.c_str())); }
        const char *_Getdays() const;
        const char *_Getmonths() const;
        const char *_Getfalse() const
                {return ("false"); }
        const char *_Gettrue() const
                {return ("true"); }

        const lconv *_Getlconv() const
                {return (localeconv()); }
private:
        _Lockit _Lk;
        string _Days, _Months, _Oname, _Nname;
        static bool _usesLocaleCache;
        };
#line 149
template<class _E>
        int _LStrcoll(const _E *_F1, const _E *_L1,
                const _E *_F2, const _E *_L2, const _Locinfo::_Collvec *);
template<> inline int _LStrcoll(
        const char *_F1, const char *_L1,
        const char *_F2, const char *_L2,
        const _Locinfo::_Collvec *_V)
        {return (_Strcoll(_F1, _L1, _F2, _L2, _V)); }
#line 159
template<class _E> inline
        size_t _LStrxfrm(_E *_F1, _E *_L1,
                const _E *_F2, const _E *_L2, const _Locinfo::_Collvec *)
        {size_t _N = _L2 - _F2;
        if (_N <= (size_t)(_L1 - _F1))
                memcpy(_F1, _F2, _N * sizeof (_E));
        return (_N); }
template<> inline size_t _LStrxfrm(
        char *_F1, char *_L1,
        const char *_F2, const char *_L2,
        const _Locinfo::_Collvec *_V)
        {return (_Strxfrm(_F1, _L1, _F2, _L2, _V)); }
#line 177
};

std::string _GetCatName(int, const char *);

#pragma implementation("xlocinfo.t")
#line 32 "/usr/vacpp/include/xlocinfo.t"
namespace std {
#line 36
inline
const char * _Locinfo::_Getdays() const
        {char *_S = :: _Getdays();
        if (_S != 0)
                {((_Locinfo *)this)->_Days = _S, free(_S); }
        return (_Days.size() != 0 ? _Days.c_str()
                        : ":Sun:Sunday:Mon:Monday:Tue:Tuesday"
                        ":Wed:Wednesday:Thu:Thursday:Fri:Friday"
                        ":Sat:Saturday"); }
#line 47
inline
const char * _Locinfo::_Getmonths() const
        {char *_S = :: _Getmonths();
        if (_S != 0)
                {((_Locinfo *)this)->_Months = _S, free(_S); }
        return (_Months.size() != 0 ? _Months.c_str()
                        : ":1:01:Jan:January:2:02:Feb:February:3:03:Mar:March"
                        ":4:04:Apr:April:5:05:May:May:6:06:Jun:June"
                        ":7:07:Jul:July:8:08:Aug:August:9:09:Sep:September"
                        ":10:10:Oct:October:11:11:Nov:November:12:12:Dec:December"); }

template<class _E>
inline
int _LStrcoll(const _E *_F1, const _E *_L1,
                const _E *_F2, const _E *_L2, const _Locinfo::_Collvec *)
        {for (; _F1 != _L1 && _F2 != _L2; ++_F1, ++_F2)
                if (*_F1 < *_F2)
                        return (-1);
                else if (*_F2 < *_F1)
                        return (+1);
        return (_F2 != _L2 ? -1 : _F1 != _L1 ? +1 : 0); }

template<>
inline
int _LStrcoll(const wchar_t *_F1, const wchar_t *_L1,
                const wchar_t *_F2, const wchar_t *_L2,
                const _Locinfo::_Collvec * _Coll)
        { return _Wcscoll(_F1, _L1, _F2, _L2, _Coll); }
#line 82
};
#line 187 "/usr/vacpp/include/xlocinfo"
#pragma namemangling()

#pragma object_model(pop)
#line 196
#pragma info(none)

#  pragma report(pop)

#pragma info(restore)
#line 91 "/usr/vacpp/include/xlocale"
namespace std {
#line 96
template <class _T>
struct _IsStandardFacet
        { enum { value = false }; };
#line 101
class  locale {
public:
        typedef int category;
        static const category collate  = (1 << (0));
        static const category ctype    = (1 << (1));
        static const category monetary = (1 << (2));
        static const category numeric  = (1 << (3));
        static const category time     = (1 << (4));
        static const category messages = (1 << (6));
        static const category all      = ((1 << ((6 + 1))) - 1);
        static const category none     = 0;
#line 114
        class  id {
        public:
                id(size_t _X = 0)
                        : _Id(_X) {}
                operator size_t()
                        {_Lockit _Lk(_Lockit::_Loc);
                        if (_Id == 0)
                                _Id = ++_Id_cnt;
                        return (_Id); }
        private:
                id(const id&);   
                id& operator=(const id&);        
                size_t _Id;
                static int _Id_cnt;
                };

        class _Locimp;
#line 133
        class facet {
                friend class locale;
                friend class _Locimp;
        public:
                static size_t _Getcat(const facet **_Ppf = 0)
                        {return ((size_t)(-1)); }
                void _Incref()
                        {
                        if (_Refs < (size_t)(-1))
                                ++_Refs; }
                facet *_Decref()
                        {
                        if (0 < _Refs && _Refs < (size_t)(-1))
                                --_Refs;
                        return (_Refs == 0 ? this : 0); }

                virtual ~facet()
                        {}
        protected:
                explicit facet(size_t _R = 0)
                        : _Refs(_R) {}
        private:
                facet(const facet&);     
                facet& operator=(const facet&);  
                size_t _Refs;
                };
#line 161
        class  _Locimp : public facet {
        protected:
                ~_Locimp();
        private:
                friend class locale;
                _Locimp(bool _Xp = false);
                _Locimp(const _Locimp&);
                void _Addfac(facet *, size_t);
                static _Locimp *_Makeloc(const _Locinfo&,
                        category, _Locimp *, const locale *);
                static void _Makewloc(const _Locinfo&,
                        category, _Locimp *, const locale *);
                static void _Makexloc(const _Locinfo&,
                        category, _Locimp *, const locale *);
                facet **_Fv;
                size_t _Nfv;
                category _Cat;
                bool _Xpar;
                string _Name;
                static _Locimp *_Clocptr, *_Global;
                };

        template<class _E, class _Tr, class _A>
                bool operator()(const basic_string<_E, _Tr, _A>&,
                        const basic_string<_E, _Tr, _A>&) const;
        template<class _F>
                locale combine(const locale& _X) const;
        template<class _F>
                locale(const locale& _X, _F *_Fac)
                        : _Ptr(new _Locimp(*(_X._Ptr)))
                {if ((_Fac != 0) && (_Ptr != 0))
                        {_Ptr->_Addfac(_Fac, _F::id);
                        if (_IsStandardFacet<_F>::value)
                                _Ptr->_Cat = 0, _Ptr->_Name = "*"; }}
        locale() throw ()
                {_Lockit _Lk(_Lockit::_Loc);
                _Ptr=_Init();
                if (_Ptr != 0)
                         _Ptr->_Incref(); }
        locale(_Uninitialized)
                : _Ptr(0)
                {}
        locale(const locale& _X) throw ()
                {_Lockit _Lk(_Lockit::_Loc);
                _Ptr=_X._Ptr;
                if (_Ptr != 0)
                         _Ptr->_Incref(); }
        locale(const locale&, const locale&, category);
        explicit locale(const char *, category = all);
        locale(const locale&, const char *, category);
        ~locale() throw ()
                {_Lockit _Lk(_Lockit::_Loc);
                if (_Ptr != 0)
                        delete _Ptr->_Decref(); }
        locale& operator=(const locale& _X) throw ()
                {_Lockit _Lk(_Lockit::_Loc);
                if ((_Ptr != 0) && (_Ptr != _X._Ptr))
                        {delete _Ptr->_Decref();
                        _Ptr = _X._Ptr;
                        _Ptr->_Incref(); }
                return (*this); }
        string name() const
                {return (_Ptr == 0 ? string() : _Ptr->_Name); }
        const facet *_Getfacet(size_t _Id) const;
        bool operator==(const locale& _X) const;
        bool operator!=(const locale& _X) const
                {return (!(*this == _X)); }
        static const locale& classic();
        static locale global(const locale&);
        static locale empty();
private:
        locale(_Locimp *_P)
                : _Ptr(_P) {}
        static _Locimp *_Init();
        static void  _Tidy();
        _Locimp *_Ptr;
        };
#line 240
template<class _F>
        class _Tidyfac {
public:
        typedef void (*PFV)();
        static _F *_Save(_F *_Fac)
                {_Lockit _Lk(_Lockit::_Loc);
                _Facsav = _Fac;
                _Facsav->_Incref();
                PFV _Tidy_rtn = &_Tidy;
                return (_Fac); }
        static void _Tidy()
                {_Lockit _Lk(_Lockit::_Loc);
                if (_Facsav != 0)
                        {delete _Facsav->_Decref();
                        _Facsav = 0; }}
private:
        static _F *_Facsav;
        };

template<class _F>
        _F *_Tidyfac<_F>::_Facsav = 0;
#line 266
template<class _F, bool _IsStdFac>
struct _UseFacet {
        static const _F& _Use(const locale & _L,
                              const locale::facet *& _Psave,
                              const locale::facet * _Pf)
                {if (_Pf == 0)
                        {if (_Psave != 0)
                                {_Pf = _Psave; }
                        else if (_F::_Getcat(&_Psave) != (size_t)(-1))
                                {_Pf = _Tidyfac<_F>::_Save((_F *)_Psave); }
                        else
                                {throw bad_cast(""); }}
                return static_cast<const _F&>(*_Pf);}
        };

template<class _F>
struct _UseFacet<_F, false> {
        static const _F& _Use(const locale& _L,
                              const locale::facet *&,
                              const locale::facet * _Pf)
                {if (_Pf == 0)
                        {throw bad_cast(""); }
                try
                        {return dynamic_cast<const _F&>(*_Pf); }
                catch (__non_rtti_object)
                        {}
                catch(...)
                        { throw; }
                return static_cast<const _F&>(*_Pf);}
        };

template<class _F> inline
        const _F& use_facet(const locale& _L)
                {static const locale::facet *_Psave = 0;
                const locale::facet *_Pf = _L._Getfacet(_F::id);
                typedef _UseFacet<_F, _IsStandardFacet<_F>::value> _UseFac;
                return _UseFac::_Use(_L, _Psave, _Pf); }
#line 306
template<class _E> inline
        char _Narrow(_E _C)  
        {return ((char)_C); }

template<> inline char _Narrow(wchar_t _C)
        {return ((char)wctob(_C)); }
#line 316
template<class _E> inline
        _E _Widen(char _Ch, _E *)  
        {return ((unsigned char)_Ch); }

template<> inline wchar_t _Widen(char _Ch, wchar_t *)
        {return (btowc(_Ch)); }
#line 325
template<class _E, class _II> inline
        int _Getloctxt(_II& _F, _II& _L, size_t _N,
                const _E *_S)
        {for (size_t _I = 0; _S[_I] != (_E)0; ++_I)
                if (_S[_I] == _S[0])
                        ++_N;
        string _Str(_N, '\0');
        int _Ans = -2;
        for (size_t _J = 1; ; ++_J, ++_F, _Ans = -1)
                {bool  _Pfx;
                size_t _I, _K;
                for (_I = 0, _K = 0, _Pfx = false; _K < _N; ++_K)
                        {for (; _S[_I] != (_E)0 && _S[_I] != _S[0]; ++_I)
                                ;
                        if (_Str[_K] != '\0')
                                _I += _Str[_K];
                        else if (_S[_I += _J] == _S[0] || _S[_I] == (_E)0)
                                {_Str[_K] = _J < 127 ? _J : 127;
                                _Ans = _K; }
                        else if (_F == _L || _S[_I] != *_F)
                                _Str[_K] = _J < 127 ? _J : 127;
                        else
                                _Pfx = true; }
                if (!_Pfx || _F == _L)
                        break; }
        return (_Ans); }
#line 355
template<class _E> inline
        _E *_Maklocstr(const char *_S, _E *)
        {size_t _L = strlen(_S) + 1;
        _E *_X = new _E[_L];
        for (_E *_P = _X; 0 < _L; --_L, ++_P, ++_S)
                if (_S != 0)
                        *_P = _Widen(*_S, (_E *)0);
                else
                        *_P = _Widen(0, (_E *)0);
        return (_X); }
#line 368
class  codecvt_base : public locale::facet {
public:
        enum _Result {ok, partial, error, noconv};
        typedef int result;
        codecvt_base(size_t _R = 0)
                : locale::facet(_R) {}
        bool always_noconv() const throw ()
                {return (do_always_noconv()); }
        int max_length() const throw ()
                {return (do_max_length()); }
        int encoding() const throw ()
                {return (do_encoding()); }
        ~codecvt_base() {}
protected:
        virtual bool do_always_noconv() const throw ()
                {return (true); }
        virtual int do_max_length() const throw ()
                {return (1); }
        virtual int do_encoding() const throw ()
                {return (1); }
        };
#line 393
template<class _E, class _To, class _St>
class codecvt : public codecvt_base {
public:
        typedef _E intern_type;
        typedef _To extern_type;
        typedef _St state_type;
        result in(_St& _State,
                const _To *_F1, const _To *_L1, const _To *& _Mid1,
                _E *_F2, _E *_L2, _E *& _Mid2) const
                {return (do_in(_State,
                        _F1, _L1, _Mid1, _F2, _L2, _Mid2)); }
        result out(_St& _State,
                const _E *_F1, const _E *_L1, const _E *& _Mid1,
                _To *_F2, _To *_L2, _To *& _Mid2) const
                {return (do_out(_State,
                        _F1, _L1, _Mid1, _F2, _L2, _Mid2)); }
        result unshift(_St& _State,
                _To *_F2, _To *_L2, _To *& _Mid2) const
                {return (do_unshift(_State,
                        _F2, _L2, _Mid2)); }
        int length(_St& _State, const _To *_F1,
                const _To *_L1, size_t _N2) const
                {return (do_length(_State, _F1, _L1, _N2)); }
        static locale::id id;

        explicit codecvt(size_t _R = 0)
                : codecvt_base(_R) {_Init(_Locinfo()); }
#line 424
        codecvt(const _Locinfo& _Lobj, size_t _R = 0)
                : codecvt_base(_R) {_Init(_Lobj); }
        static size_t _Getcat(const locale::facet **_Ppf = 0)
                {if (_Ppf != 0 && *_Ppf == 0)
                        *_Ppf = new codecvt<_E, _To, _St>;
                return (1); }
protected:
        virtual ~codecvt()
                {};
protected:
        void _Init(const _Locinfo& _Lobj)
                {_Cvt = _Lobj._Getcvt(); }
        virtual result do_in(_St& _State,
                const _To *_F1, const _To *, const _To *& _Mid1,
                _E *_F2, _E *, _E *& _Mid2) const
                {_Mid1 = _F1, _Mid2 = _F2;
                return (noconv); }
        virtual result do_out(_St& _State,
                const _E *_F1, const _E *, const _E *& _Mid1,
                _To *_F2, _To *, _To *& _Mid2) const
                {_Mid1 = _F1, _Mid2 = _F2;
                return (noconv); }
        virtual result do_unshift(_St& _State,
                _To *_F2, _To *_L2, _To *& _Mid2) const
                {_Mid2 = _F2;
                return (noconv); }
        virtual int do_length(_St& _State, const _To *_F1,
                const _To *_L1, size_t _N2) const
                {return (_N2 < (size_t)(_L1 - _F1)
                        ? _N2 : _L1 - _F1); }
private:
        _Locinfo::_Cvtvec _Cvt;
        };

template<class _E, class _To, class _St>
        locale::id codecvt<_E, _To, _St>::id;

__ExternStaticData template class codecvt<char , char , mbstate_t>;
__ExternStaticData template class codecvt<wchar_t , wchar_t , mbstate_t>;

template <>
struct _IsStandardFacet<codecvt<char, char, mbstate_t> >
        { enum { value = true }; };

template <>
struct _IsStandardFacet<codecvt<wchar_t, wchar_t, mbstate_t> >
        { enum { value = true }; };
#line 473
template<>
class  codecvt<wchar_t, char, mbstate_t>
        : public codecvt_base {
public:
        typedef wchar_t _E;
        typedef char _To;
        typedef mbstate_t _St;
        typedef _E intern_type;
        typedef _To extern_type;
        typedef _St state_type;
        result in(_St& _State,
                const _To *_F1, const _To *_L1, const _To *& _Mid1,
                _E *_F2, _E *_L2, _E *& _Mid2) const
                {return (do_in(_State,
                        _F1, _L1, _Mid1, _F2, _L2, _Mid2)); }
        result out(_St& _State,
                const _E *_F1, const _E *_L1, const _E *& _Mid1,
                _To *_F2, _To *_L2, _To *& _Mid2) const
                {return (do_out(_State,
                        _F1, _L1, _Mid1, _F2, _L2, _Mid2)); }
        result unshift(_St& _State,
                _To *_F2, _To *_L2, _To *& _Mid2) const
                {return (do_unshift(_State,
                        _F2, _L2, _Mid2)); }
        int length(_St& _State, const _To *_F1,
                const _To *_L1, size_t _N2) const
                {return (do_length(_State, _F1, _L1, _N2)); }
        static locale::id id;
        explicit codecvt(size_t _R = 0)
                : codecvt_base(_R) {_Init(_Locinfo()); }
        codecvt(const _Locinfo& _Lobj, size_t _R = 0)
                : codecvt_base(_R) {_Init(_Lobj); }
        static size_t _Getcat(const locale::facet **_Ppf = 0)
                {if (_Ppf != 0 && *_Ppf == 0)
                        *_Ppf = new codecvt<_E, _To, _St>;
                return (1); }
protected:
        virtual ~codecvt()
                {};
protected:
        void _Init(const _Locinfo& _Lobj)
                {_Cvt = _Lobj._Getcvt(); }
        virtual result do_in(_St& _State,
                const _To *_F1, const _To *_L1, const _To *& _Mid1,
                _E *_F2, _E *_L2, _E *& _Mid2) const
                {_Mid1 = _F1, _Mid2 = _F2;
                result _Ans = _Mid1 == _L1 ? ok : partial;
                int _N;
                while (_Mid1 != _L1 && _Mid2 != _L2)
                        {_N = _Mbrtowc(_Mid2, _Mid1, _L1 - _Mid1,
                                &_State, &_Cvt);
                        switch (_N)
                        {case -2:
                                _Mid1 = _L1;
                                return (_Ans);
                        case -1:
                                return (error);
                        case 0:
                                _N = strlen(_Mid1) + 1;
                        default:         
                                _Mid1 += _N, ++_Mid2, _Ans = ok; }}
                return (_Ans); }
        virtual result do_out(_St& _State,
                const _E *_F1, const _E *_L1, const _E *& _Mid1,
                _To *_F2, _To *_L2, _To *& _Mid2) const
                {_Mid1 = _F1, _Mid2 = _F2;
                result _Ans = _Mid1 == _L1 ? ok : partial;
                int _N;
                while (_Mid1 != _L1 && _Mid2 != _L2)
                        if (((__lc_charmap).obj->cm_mb_cur_max) <= _L2 - _Mid2)
                                if ((_N = _Wcrtomb(_Mid2, *_Mid1,
                                        &_State, &_Cvt)) <= 0)
                                        return (error);
                                else
                                        ++_Mid1, _Mid2 += _N, _Ans = ok;
                        else
                                {_To _Buf[4];
                                _St _Stsave = _State;
                                if ((_N = _Wcrtomb(_Buf, *_Mid1,
                                        &_State, &_Cvt)) <= 0)
                                        return (error);
                                else if (_L2 - _Mid2 < _N)
                                        {_State = _Stsave;
                                        return (_Ans); }
                                else
                                        {memcpy(_Mid2, _Buf, _N);
                                        ++_Mid1, _Mid2 += _N, _Ans = ok; }}
                return (_Ans); }
        virtual result do_unshift(_St& _State,
                _To *_F2, _To *_L2, _To *& _Mid2) const
                {_Mid2 = _F2;
                result _Ans = ok;
                int _N;
                _To _Buf[4];
                _St _Stsave = _State;
                if ((_N = _Wcrtomb(_Buf, L'\0', &_State, &_Cvt)) <= 0)
                        _Ans = error;
                else if (_L2 - _Mid2 < --_N)
                        {_State = _Stsave;
                        _Ans = partial; }
                else if (0 < _N)
                        {memcpy(_Mid2, _Buf, _N);
                        _Mid2 += _N; }
                return (_Ans); }
        virtual int do_length(_St& _State, const _To *_F1,
                const _To *_L1, size_t _N2) const
                {int _N1;
                const _To *_Mid1;
                for (_N1 = 0, _Mid1 = _F1;
                        (size_t)_N1 < _N2 && _Mid1 != _L1; )
                        {int _N;
                        _E _Ch;
                        _N = _Mbrtowc(&_Ch, _Mid1, _L1 - _Mid1,
                                &_State, &_Cvt);
                        switch (_N)
                        {case -2:
                                return (_N1);
                        case -1:
                                return (_N1);
                        case 0:
                                _N = strlen(_Mid1) + 1;
                        default:         
                                _Mid1 += _N, ++_N1; }}
                return (_N1); }
        virtual bool do_always_noconv() const throw ()
                {return (false); }
        virtual int do_max_length() const throw ()
                {return (4); }
        virtual int do_encoding() const throw ()
                {return (0); }
private:
        _Locinfo::_Cvtvec _Cvt;
        };

__ExternStaticData template class codecvt<wchar_t , char , mbstate_t>;

template <>
struct _IsStandardFacet<codecvt<wchar_t, char, mbstate_t> >
        { enum { value = true }; };
#line 614
template<class _E, class _To, class _St>
        class codecvt_byname : public codecvt<_E, _To, _St> {
public:
        explicit codecvt_byname(const char *_S, size_t _R = 0)
                : codecvt<_E, _To, _St>(_Locinfo(_S), _R) {}
protected:
        virtual ~codecvt_byname()
                {}
        };
#line 625
struct ctype_base : public locale::facet {
        typedef short mask;      
#line 634
        enum _Mask {_Alnum = 0x02|0x40|0x80|0x100, _Alpha = 0x40|0x80|0x100,
                _Cntrl = 0x20, _Digit = 0x02, _Graph = 0x02|0x40|0x10|0x80|0x100,
                _Lower = 0x40, _Print = 0x02|0x40|0x10|0x04|0x80|0x100|0x01,
                _Punct = 0x10, _Space = 0x08|0x04|0x200, _Upper = 0x80,
                _Xdigit = 0x01};
        static const mask alnum = _Alnum;
        static const mask alpha = _Alpha;
        static const mask cntrl = _Cntrl;
        static const mask digit = _Digit;
        static const mask graph = _Graph;
        static const mask lower = _Lower;
        static const mask print = _Print;
        static const mask punct = _Punct;
        static const mask space = _Space;
        static const mask upper = _Upper;
        static const mask xdigit = _Xdigit;
#line 652
        ctype_base(size_t _R = 0)
                : locale::facet(_R) {}
        ~ctype_base() {}
        };
#line 658
template<class _E>
        class ctype : public ctype_base {
public:
        typedef _E char_type;
        bool is(mask _M, _E _C) const
                {return (do_is(_M, _C)); }
        const _E *is(const _E *_F, const _E *_L, mask *_V) const
                {return (do_is(_F, _L, _V)); }
        const _E *scan_is(mask _M, const _E *_F,
                const _E *_L) const
                {return (do_scan_is(_M, _F, _L)); }
        const _E *scan_not(mask _M, const _E *_F,
                const _E *_L) const
                {return (do_scan_not(_M, _F, _L)); }
        _E tolower(_E _C) const
                {return (do_tolower(_C)); }
        const _E *tolower(_E *_F, const _E *_L) const
                {return (do_tolower(_F, _L)); }
        _E toupper(_E _C) const
                {return (do_toupper(_C)); }
        const _E *toupper(_E *_F, const _E *_L) const
                {return (do_toupper(_F, _L)); }
        _E widen(char _X) const
                {return (do_widen(_X)); }
        const char *widen(const char *_F, const char *_L,
                _E *_V) const
                {return (do_widen(_F, _L, _V)); }
        char narrow(_E _C, char _D = '\0') const
                {return (do_narrow(_C, _D)); }
        const _E *narrow(const _E *_F, const _E *_L, char _D,
                char *_V) const
                {return (do_narrow(_F, _L, _D, _V)); }
        static locale::id id;

        explicit ctype(size_t _R = 0)
                : ctype_base(_R) {_Init(_Locinfo()); }
#line 698
        ctype(const _Locinfo& _Lobj, size_t _R = 0)
                : ctype_base(_R) {_Init(_Lobj); }
        static size_t _Getcat(const locale::facet **_Ppf = 0)
                {if (_Ppf != 0 && *_Ppf == 0)
                        *_Ppf = new ctype<_E>;
                return (1); }
protected:
        virtual ~ctype()
                {if (_Ctype._Delfl)
                        free((void *)_Ctype._Table); }
protected:
        void _Init(const _Locinfo& _Lobj)
                {_Ctype = _Lobj._Getctype(); }
        virtual bool do_is(mask _M, _E _C) const
                {return ((_Ctype._Table[(unsigned char)narrow(_C)]
                        & _M) != 0); }
        virtual const _E *do_is(const _E *_F, const _E *_L,
                mask *_V) const
                {for (; _F != _L; ++_F, ++_V)
                        *_V = _Ctype._Table[(unsigned char)narrow(*_F)];
                return (_F); }
        virtual const _E *do_scan_is(mask _M, const _E *_F,
                const _E *_L) const
                {for (; _F != _L && !is(_M, *_F); ++_F)
                        ;
                return (_F); }
        virtual const _E *do_scan_not(mask _M, const _E *_F,
                const _E *_L) const
                {for (; _F != _L && is(_M, *_F); ++_F)
                        ;
                return (_F); }
        virtual _E do_tolower(_E _C) const
                {return (widen((char)_Tolower((unsigned char)narrow(_C),
                        &_Ctype))); }
        virtual const _E *do_tolower(_E *_F, const _E *_L) const
                {for (; _F != _L; ++_F)
                        *_F = widen((char)_Tolower((unsigned char)narrow(*_F),
                                &_Ctype));
                return ((const _E *)_F); }
        virtual _E do_toupper(_E _C) const
                {return (widen((char)_Toupper((unsigned char)narrow(_C),
                        &_Ctype))); }
        virtual const _E *do_toupper(_E *_F, const _E *_L) const
                {for (; _F != _L; ++_F)
                        *_F = widen((char)_Toupper((unsigned char)narrow(*_F),
                        &_Ctype));
                return ((const _E *)_F); }
        virtual _E do_widen(char _X) const
                {return (_Widen(_X, (_E *)0)); }
        virtual const char *do_widen(const char *_F, const char *_L,
                _E *_V) const
                {for (; _F != _L; ++_F, ++_V)
                        *_V = _Widen(*_F, (_E *)0);
                return (_F); }
        virtual char do_narrow(_E _C, char) const
                {return (_Narrow(static_cast<_E>(_C))); }
        virtual const _E *do_narrow(const _E *_F, const _E *_L,
                char, char *_V) const
                {for (; _F != _L; ++_F, ++_V)
                        *_V = _Narrow(static_cast<_E>(*_F));
                return (_F); }
private:
        _Locinfo::_Ctypevec _Ctype;
        };

template<class _E>
        locale::id ctype<_E>::id;

__ExternStaticData template class ctype<wchar_t>;

template <>
struct _IsStandardFacet<ctype<wchar_t> >
        { enum { value = true }; };
#line 773
template<>
        bool ctype<wchar_t>::do_is(mask _M, wchar_t _C) const
                {return _DoIsW(_M, _C, &_Ctype); }
#line 779
template<>
class  ctype<char> : public ctype_base {
        typedef ctype<char> _Myt;
public:
        typedef char _E;
        typedef _E char_type;
        bool is(mask _M, _E _C) const

                {return _DoIs(_M, _C, &_Ctype); }
#line 791
        const _E *is(const _E *_F, const _E *_L, mask *_V) const
                {for (; _F != _L; ++_F, ++_V)
                        *_V = _Ctype._Table[(unsigned char)*_F];
                return (_F); }
        const _E *scan_is(mask _M, const _E *_F,
                const _E *_L) const
                {for (; _F != _L && !is(_M, *_F); ++_F)
                        ;
                return (_F); }
        const _E *scan_not(mask _M, const _E *_F,
                const _E *_L) const
                {for (; _F != _L && is(_M, *_F); ++_F)
                        ;
                return (_F); }
        _E tolower(_E _C) const
                {return (do_tolower(_C)); }
        const _E *tolower(_E *_F, const _E *_L) const
                {return (do_tolower(_F, _L)); }
        _E toupper(_E _C) const
                {return (do_toupper(_C)); }
        const _E *toupper(_E *_F, const _E *_L) const
                {return (do_toupper(_F, _L)); }
        _E widen(char _X) const
                {return (do_widen(_X)); }
        const _E *widen(const char *_F, const char *_L, _E *_V) const
                {return (do_widen(_F, _L, _V)); }
        _E narrow(_E _C, char _D = '\0') const
                {return (do_narrow(_C, _D)); }
        const _E *narrow(const _E *_F, const _E *_L, char _D,
                char *_V) const
                {return (do_narrow(_F, _L, _D, _V)); }
        static locale::id id;
        explicit ctype(const mask *_Tab = 0, bool _Df = false,
                size_t _R = 0)
                : ctype_base(_R)
                {_Init(_Locinfo());
                if (_Ctype._Delfl)
                        free((void *)_Ctype._Table), _Ctype._Delfl = false;
                if (_Tab == 0)
                        _Ctype._Table = _Cltab;
                else
                        _Ctype._Table = _Tab, _Ctype._Delfl = _Df; }
        ctype(const _Locinfo& _Lobj, size_t _R = 0)
                : ctype_base(_R) {_Init(_Lobj); }
        static size_t _Getcat(const locale::facet **_Ppf = 0)
                {if (_Ppf != 0 && *_Ppf == 0)
                        *_Ppf = new ctype<_E>;
                return (1); }
        static const size_t table_size;
protected:
        virtual ~ctype()
                {if (_Ctype._Delfl)
                        free((void *)_Ctype._Table); }
protected:
        void _Init(const _Locinfo& _Lobj)
                {_Ctype = _Lobj._Getctype();
                if (_Cltab == 0)
                        _Cltab = _Ctype._Table, _Ctype._Delfl = false; }
        virtual _E do_tolower(_E _C) const
                {return ((_E)_Tolower((unsigned char)_C, &_Ctype)); }
        virtual const _E *do_tolower(_E *_F, const _E *_L) const
                {for (; _F != _L; ++_F)
                        *_F = (_E)_Tolower((unsigned char)*_F, &_Ctype);
                return ((const _E *)_F); }
        virtual _E do_toupper(_E _C) const
                {return ((_E)_Toupper((unsigned char)_C, &_Ctype)); }
        virtual const _E *do_toupper(_E *_F, const _E *_L) const
                {for (; _F != _L; ++_F)
                        *_F = (_E)_Toupper((unsigned char)*_F, &_Ctype);
                return ((const _E *)_F); }
        virtual _E do_widen(char _X) const
                {return (_X); }
        virtual const _E *do_widen(const char *_F, const char *_L,
                _E *_V) const
                {memcpy(_V, _F, _L - _F);
                return (_L); }
        virtual _E do_narrow(_E _C, char _D) const
                {return (_C); }
        virtual const _E *do_narrow(const _E *_F, const _E *_L,
                char _D, char *_V) const
                {memcpy(_V, _F, _L - _F);
                return (_L); }
        const mask *table() const throw ()
                {return (_Ctype._Table); }
        static const mask *classic_table() throw ()
                {if (_Cltab == 0)
                        locale::classic();       
                return (_Cltab); }
private:
        _Locinfo::_Ctypevec _Ctype;
        static const mask *_Cltab;
        };

__ExternStaticData template class ctype<char>;

template <>
struct _IsStandardFacet<ctype<char> >
        { enum { value = true }; };
#line 891
template<class _E>
        class ctype_byname : public ctype<_E> {
public:
        explicit ctype_byname(const char *_S, size_t _R = 0)
                : ctype<_E>(_Locinfo(_S), _R) {}
protected:
        virtual ~ctype_byname()
                {}
        };
#line 906
};

#pragma namemangling()

#pragma object_model(pop)
#line 917
#pragma info(none)

#  pragma report(pop)

#pragma info(restore)
#line 76 "/usr/vacpp/include/xiosbase"
namespace std {
#line 81
extern const int  _NSTDSTR;
#line 84
class  ios_base {
public:

        class failure : public runtime_error {
        public:
                explicit failure(const string &_S)
                        : runtime_error(_S) {}
                virtual ~failure()
                        {}
        protected:
                virtual void _Doraise() const
                        {throw (*this); }
        };

        enum _Fmtflags {_Skipws = 0x0001, _Unitbuf = 0x0002,
                _Uppercase = 0x0004, _Showbase = 0x0008,
                _Showpoint = 0x0010, _Showpos = 0x0020,
                _Left = 0x0040, _Right = 0x0080, _Internal = 0x0100,
                _Dec = 0x0200, _Oct = 0x0400, _Hex = 0x0800,
                _Scientific = 0x1000, _Fixed = 0x2000, _Boolalpha = 0x4000,
                _Adjustfield = 0x01c0, _Basefield = 0x0e00,
                _Floatfield = 0x3000, _Fmtmask = 0x7fff, _Fmtzero = 0};
        typedef int fmtflags;
        static const fmtflags skipws = _Skipws;
        static const fmtflags unitbuf = _Unitbuf;
        static const fmtflags uppercase = _Uppercase;
        static const fmtflags showbase = _Showbase;
        static const fmtflags showpoint = _Showpoint;
        static const fmtflags showpos = _Showpos;
        static const fmtflags left = _Left;
        static const fmtflags right = _Right;
        static const fmtflags internal = _Internal;
        static const fmtflags dec = _Dec;
        static const fmtflags oct = _Oct;
        static const fmtflags hex = _Hex;
        static const fmtflags scientific = _Scientific;
        static const fmtflags fixed = _Fixed;
        static const fmtflags boolalpha = _Boolalpha;
        static const fmtflags adjustfield = _Adjustfield;
        static const fmtflags basefield = _Basefield;
        static const fmtflags floatfield = _Floatfield;

        enum _Iostate {_Goodbit = 0x0, _Eofbit = 0x1,
                _Failbit = 0x2, _Badbit = 0x4, _Statmask = 0x7};
        typedef int iostate;
        static const iostate goodbit = _Goodbit;
        static const iostate eofbit = _Eofbit;
        static const iostate failbit = _Failbit;
        static const iostate badbit = _Badbit;

        enum _Openmode {_In = 0x01, _Out = 0x02, _Ate = 0x04,
                _App = 0x08, _Trunc = 0x10, _Binary = 0x20};
        typedef int openmode;
        static const openmode in = _In;
        static const openmode out = _Out;
        static const openmode ate = _Ate;
        static const openmode app = _App;
        static const openmode trunc = _Trunc;
        static const openmode binary = _Binary;

        enum seekdir {beg = 0, cur = 1, end = 2};
        enum event {erase_event, imbue_event, copyfmt_event};
        typedef void (*event_callback)(event, ios_base&, int);
        typedef short io_state, open_mode, seek_dir;
#line 150
        class  Init {
        public:
                Init();
                ~Init();
        private:
                static int _Init_cnt;
                };
        ios_base& operator=(const ios_base& _R)
                {if (this != &_R)
                        {_State = _R._State;
                        copyfmt(_R); }
                return (*this); }
        operator void *() const
                {return (fail() ? 0 : (void *)this); }
        bool operator!() const
                {return (fail()); }
        void clear(iostate = goodbit, bool = false);
        void clear(io_state _St)
                {clear((iostate)_St); }
        iostate rdstate() const
                {return (_State); }
        void setstate(iostate _St, bool _Ex = false)
                {if (_St != goodbit)
                        clear((iostate)((int)rdstate() | (int)_St), _Ex); }
        void setstate(io_state _St)
                {setstate((iostate)_St); }
        bool good() const
                {return (rdstate() == goodbit); }
        bool eof() const
                {return ((int)rdstate() & (int)eofbit); }
        bool fail() const
                {return (((int)rdstate()
                        & ((int)badbit | (int)failbit)) != 0); }
        bool bad() const
                {return (((int)rdstate() & (int)badbit) != 0); }
        iostate exceptions() const
                {return (_Except); }
        void exceptions(iostate _Ne)
                {_Except = (iostate)((int)_Ne & (int)_Statmask);
                clear(_State); }
        void exceptions(io_state _St)
                {exceptions((iostate)_St); }
        fmtflags flags() const
                {return (_Fmtfl); }
        fmtflags flags(fmtflags _Nf)
                {fmtflags _Of = _Fmtfl;
                _Fmtfl = (fmtflags)((int)_Nf & (int)_Fmtmask);
                return (_Of); }
        fmtflags setf(fmtflags _Nf)
                {ios_base::fmtflags _Of = _Fmtfl;
                _Fmtfl = (fmtflags)((int)_Fmtfl
                        | (int)_Nf & (int)_Fmtmask);
                return (_Of); }
        fmtflags setf(fmtflags _Nf, fmtflags _M)
                {ios_base::fmtflags _Of = _Fmtfl;
                _Fmtfl = (fmtflags)(((int)_Fmtfl & (int)~_M)
                        | ((int)_Nf & (int)_M & (int)_Fmtmask));
                return (_Of); }
        void unsetf(fmtflags _M)
                {_Fmtfl = (fmtflags)((int)_Fmtfl & (int)~_M); }
        streamsize precision() const
                {return (_Prec); }
        streamsize precision(int _Np)
                {streamsize _Op = _Prec;
                _Prec = _Np;
                return (_Op); }
        streamsize width() const
                {return (_Wide); }
        streamsize width(streamsize _Nw)
                {streamsize _Ow = _Wide;
                _Wide = _Nw;
                return (_Ow); }
        locale getloc() const
                {return (_Loc); }
        locale imbue(const locale&);
        static int xalloc()
                {return (_Index++); }
        long& iword(int _Idx)
                {return (_Findarr(_Idx)._Lo); }
        void *& pword(int _Idx)
                {return (_Findarr(_Idx)._Vp); }
        void register_callback(event_callback, int);
        ios_base& copyfmt(const ios_base&);
        virtual ~ios_base();
        static bool sync_with_stdio(bool _Sfl = true)
                {const bool _Osfl = _Sync;
                _Sync = _Sfl;
                return (_Osfl); }
protected:
        ios_base()
                : _Loc(_Noinit), _Stdstr(0), _Calls(0), _Arr(0) {}
        void _Addstd();
        void _Init();
private:

        struct _Iosarray {
        public:
                _Iosarray(int _Idx, _Iosarray *_Link)
                        : _Next(_Link), _Index(_Idx), _Lo(0), _Vp(0) {}
                _Iosarray *_Next;
                int _Index;
                long _Lo;
                void *_Vp;
                };

        struct _Fnarray {
                _Fnarray(int _Idx, event_callback _P, _Fnarray *_Link)
                        : _Next(_Link), _Index(_Idx), _Pfn(_P) {}
                _Fnarray *_Next;
                int _Index;
                event_callback _Pfn;
                };
        void _Callfns(event);
        _Iosarray& _Findarr(int);
        void _Tidy();
        iostate _State, _Except;
        fmtflags _Fmtfl;
        int _Prec, _Wide;
        _Iosarray *_Arr;
        _Fnarray *_Calls;
        locale _Loc;
        size_t _Stdstr;
        static int _Index;
        static bool _Sync;
        };
#line 284
};

#pragma namemangling()

#pragma object_model(pop)
#line 295
#pragma info(none)

#  pragma report(pop)

#pragma info(restore)
#line 76 "/usr/vacpp/include/streambuf"
namespace std {
#line 81
template<class _E, class _Tr>
        class basic_streambuf {
        basic_streambuf(const basic_streambuf<_E, _Tr>&);        
        basic_streambuf<_E, _Tr>&
                operator=(const basic_streambuf<_E, _Tr>&);      
protected:
        basic_streambuf()
                : _Loc() {_Init(); }
        basic_streambuf(_Uninitialized)
                : _Loc(_Noinit) {}
public:
        typedef basic_streambuf<_E, _Tr> _Myt;
        typedef _E char_type;
        typedef _Tr traits_type;
        virtual ~basic_streambuf()
                { }
        typedef typename _Tr::int_type int_type;
        typedef typename _Tr::pos_type pos_type;
        typedef typename _Tr::off_type off_type;
        pos_type pubseekoff(off_type _O, ios_base::seekdir _W,
                ios_base::openmode _M = ios_base::in | ios_base::out)
                {return (seekoff(_O, _W, _M)); }
        pos_type pubseekoff(off_type _O, ios_base::seek_dir _W,
                ios_base::open_mode _M)
                {return (pubseekoff(_O, (ios_base::seekdir)_W,
                        (ios_base::openmode)_M)); }
        pos_type pubseekpos(pos_type _P,
                ios_base::openmode _M = ios_base::in | ios_base::out)
                {return (seekpos(_P, _M)); }
        pos_type pubseekpos(pos_type _P, ios_base::open_mode _M)
                {return (seekpos(_P, (ios_base::openmode)_M)); }
        _Myt *pubsetbuf(_E *_S, streamsize _N)
                {return (setbuf(_S, _N)); }
        locale pubimbue(const locale &_Ln)
                {locale _Lo = _Loc;
                imbue(_Ln);
                _Loc = _Ln;
                return (_Lo); }
        locale getloc()
                {return (_Loc); }
        locale getloc() const
                {return (_Loc); }
        streamsize in_avail()
                {return (gptr() != 0 && gptr() < egptr()
                        ? egptr() - gptr() : showmanyc()); }
        int pubsync()
                {return (sync()); }
        int_type sbumpc()
                {return (gptr() != 0 && gptr() < egptr()
                        ? _Tr::to_int_type(*_Gninc()) : uflow()); }
        int_type sgetc()
                {return (gptr() != 0 && gptr() < egptr()
                        ? _Tr::to_int_type(*gptr()) : underflow()); }
        streamsize sgetn(_E *_S, streamsize _N)
                {return (xsgetn(_S, _N)); }
        int_type snextc()
                {return (_Tr::eq_int_type(_Tr::eof(), sbumpc())
                        ? _Tr::eof() : sgetc()); }
        int_type sputbackc(_E _C)
                {return (gptr() != 0 && eback() < gptr()
                        && _Tr::eq(_C, gptr()[-1])
                        ? _Tr::to_int_type(*_Gndec())
                        : pbackfail(_Tr::to_int_type(_C))); }
        void stossc()
                {if (gptr() != 0 && gptr() < egptr())
                        _Gninc();
                else
                        uflow(); }
        int_type sungetc()
                {return (gptr() != 0 && eback() < gptr()
                        ? _Tr::to_int_type(*_Gndec()) : pbackfail()); }
        int_type sputc(_E _C)
                {return (pptr() != 0 && pptr() < epptr()
                        ? _Tr::to_int_type(*_Pninc() = _C)
                        : overflow(_Tr::to_int_type(_C))); }
        streamsize sputn(const _E *_S, streamsize _N)
                {return (xsputn(_S, _N)); }

        bool doflush() const
                {return 0 != *_IPcnt; }
#line 165
protected:
        _E *eback() const
                {return (*_IGbeg); }
        _E *gptr() const
                {return (*_IGnext); }
        _E *pbase() const
                {return (*_IPbeg); }
        _E *pptr() const
                {return (*_IPnext); }

        _E *egptr() const
                {return (*_IGnext + *_IGcnt); }
        void gbump(int _N)
                {*_IGcnt -= _N;
                *_IGnext += _N; }
        void setg(_E *_B, _E *_N, _E *_L)
                {*_IGbeg = _B, *_IGnext = _N, *_IGcnt = _L - _N; }
        _E *epptr() const
                {return (*_IPnext + *_IPcnt); }
        _E *_Gndec()
                {++*_IGcnt;
                return (--*_IGnext); }
        _E *_Gninc()
                {--*_IGcnt;
                return ((*_IGnext)++); }
        void pbump(int _N)
                {*_IPcnt -= _N;
                *_IPnext += _N; }
        void setp(_E *_B, _E *_L)
                {*_IPbeg = _B, *_IPnext = _B, *_IPcnt = _L - _B; }
        void setp(_E *_B, _E *_N, _E *_L)
                {*_IPbeg = _B, *_IPnext = _N, *_IPcnt = _L - _N; }
        _E *_Pninc()
                {--*_IPcnt;
                return ((*_IPnext)++); }
        void _Init()
                {_IGbeg = &_Gbeg, _IPbeg = &_Pbeg;
                _IGnext = &_Gnext, _IPnext = &_Pnext;
                _IGcnt = &_Gcnt, _IPcnt = &_Pcnt;
                setp(0, 0), setg(0, 0, 0); }
#line 212
        void _Init(_E **_Gb, _E **_Gn, int *_Gc,
                _E **_Pb, _E **_Pn, int *_Pc)
                {_IGbeg = _Gb, _IPbeg = _Pb;
                _IGnext = _Gn, _IPnext = _Pn;
                _IGcnt = _Gc, _IPcnt = _Pc; }
#line 251
        virtual int_type overflow(int_type = _Tr::eof())
                {return (_Tr::eof()); }
        virtual int_type pbackfail(int_type = _Tr::eof())
                {return (_Tr::eof()); }
        virtual streamsize showmanyc()
                {return (0); }
        virtual int_type underflow()
                {return (_Tr::eof()); }
        virtual int_type uflow()
                {return (_Tr::eq_int_type(_Tr::eof(), underflow())
                        ? _Tr::eof() : _Tr::to_int_type(*_Gninc())); }
        virtual streamsize xsgetn(_E * _S, streamsize _N)
                {int_type _C;
                streamsize _M, _Ns;
                for (_Ns = 0; 0 < _N; )
                        if (gptr() != 0 && 0 < (_M = egptr() - gptr()))
                                {if (_N < _M)
                                        _M = _N;
                                _Tr::copy(_S, gptr(), _M);
                                _S += _M, _Ns += _M, _N -= _M, gbump(_M); }
                        else if (_Tr::eq_int_type(_Tr::eof(), _C = uflow()))
                                break;
                        else
                                *_S++ = _Tr::to_char_type(_C), ++_Ns, --_N;
                return (_Ns); }
        virtual streamsize xsputn(const _E *_S, streamsize _N)
                {streamsize _M, _Ns;
                for (_Ns = 0; 0 < _N; )
                        if (pptr() != 0 && 0 < (_M = epptr() - pptr()))
                                {if (_N < _M)
                                        _M = _N;
                                _Tr::copy(pptr(), _S, _M);
                                _S += _M, _Ns += _M, _N -= _M, pbump(_M); }
                        else if (_Tr::eq_int_type(_Tr::eof(),
                                overflow(_Tr::to_int_type(*_S))))
                                break;
                        else
                                ++_S, ++_Ns, --_N;
                return (_Ns); }
        virtual pos_type seekoff(off_type, ios_base::seekdir,
                ios_base::openmode = ios_base::in | ios_base::out)
                {return (streampos(_BADOFF)); }
        virtual pos_type seekpos(pos_type,
                ios_base::openmode = ios_base::in | ios_base::out)
                {return (streampos(_BADOFF)); }
        virtual _Myt *setbuf(_E *, streamsize)
                {return (this); }
        virtual int sync()
                {return (0); }
        virtual void imbue(const locale& _Loc)
                {}
private:
#line 309
        _E *_Gbeg, *_Pbeg;
        _E **_IGbeg, **_IPbeg;
        _E *_Gnext, *_Pnext;
        _E **_IGnext, **_IPnext;
#line 315
        int _Gcnt, _Pcnt;
        int *_IGcnt, *_IPcnt;
#line 321
        locale _Loc;
        };
#line 329
};

#pragma namemangling()

#pragma object_model(pop)
#line 340
#pragma info(none)

#  pragma report(pop)

#pragma info(restore)
#line 80 "/usr/vacpp/include/xlocnum"
namespace std {
#line 86
template<class _E>
        class numpunct : public locale::facet {
public:
        typedef basic_string<_E, char_traits<_E>, allocator<_E> >
                string_type;
        typedef _E char_type;
        static locale::id id;
        _E decimal_point() const
                {return (do_decimal_point()); }
        _E thousands_sep() const
                {return (do_thousands_sep()); }
        string grouping() const
                {return (do_grouping()); }
        string_type falsename() const
                {return (do_falsename()); }
        string_type truename() const
                {return (do_truename()); }
        explicit numpunct(size_t _R = 0)
                : locale::facet(_R) {_Init(_Locinfo()); }
        numpunct(const _Locinfo& _Lobj, size_t _R = 0)
                : locale::facet(_R) {_Init(_Lobj); }
        static size_t _Getcat(const locale::facet **_Ppf = 0)
                {if (_Ppf != 0 && *_Ppf == 0)
                        *_Ppf = new numpunct<_E>;
                return (3); }
protected:
        virtual ~numpunct()
                {delete[] _Gr;
                delete[] _Nf;
                delete[] _Nt; }
protected:
        void _Init(const _Locinfo& _Lobj);
        virtual _E do_decimal_point() const
                {return (_Dp); }
        virtual _E do_thousands_sep() const
                {return (_Ks); }
        virtual string do_grouping() const
                {return (string(_Gr)); }
        virtual string_type do_falsename() const
                {return (string_type(_Nf)); }
        virtual string_type do_truename() const
                {return (string_type(_Nt)); }
private:
        char *_Gr;
        _E _Dp, _Ks, *_Nf, *_Nt;
        };

template <class _E>
inline void numpunct<_E>::_Init(const _Locinfo& _Lobj)
	       {

                const lconv *_P = _Lobj._Getnumpunct();
#line 141
                _Dp = _Widen(_P->decimal_point[0], (_E *)0);

                if (!_GetCatName((1 << (3)), _Lobj._Getname().c_str())
                        .compare("C"))
                        {_Ks = _Widen(',', (_E *)0); }
                else

                        {_Ks = _Widen(_P->thousands_sep[0], (_E *)0); }
               _Gr = _Maklocstr(_P->grouping, (char *)0);
               _Nf = _Maklocstr(_Lobj._Getfalse(), (_E *)0);
               _Nt = _Maklocstr(_Lobj._Gettrue(), (_E *)0); }

typedef numpunct<char> _Npc;
typedef numpunct<wchar_t> _Npwc;

__ExternStaticData template class numpunct<char>;
__ExternStaticData template class numpunct<wchar_t>;

template <>
struct _IsStandardFacet<numpunct<char> >
        { enum { value = true }; };

template <>
struct _IsStandardFacet<numpunct<wchar_t> >
        { enum { value = true }; };
#line 168
template<class _E>
        class numpunct_byname : public numpunct<_E> {
public:
        explicit numpunct_byname(const char *_S, size_t _R = 0)
                : numpunct<_E>(_Locinfo(_S), _R) {}
protected:
        virtual ~numpunct_byname()
                {}
        };

template<class _E>
        locale::id numpunct<_E>::id;
#line 184
template<class _E,
        class _II = istreambuf_iterator<_E, char_traits<_E> > >
        class num_get : public locale::facet {
public:
        typedef numpunct<_E> _Mypunct;
        typedef basic_string<_E, char_traits<_E>, allocator<_E> >
                _Mystr;
        static size_t _Getcat(const locale::facet **_Ppf = 0)
                {if (_Ppf != 0 && *_Ppf == 0)
                        *_Ppf = new num_get<_E, _II>;
                return (3); }
        static locale::id id;
protected:
        virtual ~num_get()
                {}
protected:
        void _Init(const _Locinfo& _Lobj)
                {}
public:
        explicit num_get(size_t _R = 0)
                : locale::facet(_R) {_Init(_Locinfo()); }
        num_get(const _Locinfo& _Lobj, size_t _R = 0)
                : locale::facet(_R) {_Init(_Lobj); }
        typedef _E char_type;
        typedef _II iter_type;
        _II get(_II _F, _II _L, ios_base& _X, ios_base::iostate& _St,
                _Bool& _V) const
                {return (do_get(_F, _L, _X, _St, _V)); }
        _II get(_II _F, _II _L, ios_base& _X, ios_base::iostate& _St,
                unsigned short& _V) const
                {return (do_get(_F, _L, _X, _St, _V)); }
        _II get(_II _F, _II _L, ios_base& _X, ios_base::iostate& _St,
                unsigned int& _V) const
                {return (do_get(_F, _L, _X, _St, _V)); }
        _II get(_II _F, _II _L, ios_base& _X, ios_base::iostate& _St,
                long& _V) const
                {return (do_get(_F, _L, _X, _St, _V)); }
        _II get(_II _F, _II _L, ios_base& _X, ios_base::iostate& _St,
                unsigned long& _V) const
                {return (do_get(_F, _L, _X, _St, _V)); }

        _II get(_II _F, _II _L, ios_base& _X, ios_base::iostate& _St,
                long long& _V) const
                {return (do_get(_F, _L, _X, _St, _V)); }
        _II get(_II _F, _II _L, ios_base& _X, ios_base::iostate& _St,
                unsigned long long& _V) const
                {return (do_get(_F, _L, _X, _St, _V)); }

        _II get(_II _F, _II _L, ios_base& _X, ios_base::iostate& _St,
                float& _V) const
                {return (do_get(_F, _L, _X, _St, _V)); }
        _II get(_II _F, _II _L, ios_base& _X, ios_base::iostate& _St,
                double& _V) const
                {return (do_get(_F, _L, _X, _St, _V)); }
        _II get(_II _F, _II _L, ios_base& _X, ios_base::iostate& _St,
                long double& _V) const
                {return (do_get(_F, _L, _X, _St, _V)); }
        _II get(_II _F, _II _L, ios_base& _X, ios_base::iostate& _St,
                void *& _V) const
                {return (do_get(_F, _L, _X, _St, _V)); }
protected:
        virtual _II do_get(_II _F, _II _L, ios_base& _X,
                ios_base::iostate& _St, _Bool& _V) const;
        virtual _II do_get(_II _F, _II _L, ios_base& _X,
                ios_base::iostate& _St, unsigned short& _V) const;
        virtual _II do_get(_II _F, _II _L, ios_base& _X,
                ios_base::iostate& _St, unsigned int& _V) const;
        virtual _II do_get(_II _F, _II _L, ios_base& _X,
                ios_base::iostate& _St, long& _V) const;
        virtual _II do_get(_II _F, _II _L, ios_base& _X,
                ios_base::iostate& _St, unsigned long& _V) const;

         _II do_get(_II _F, _II _L, ios_base& _X,
                ios_base::iostate& _St, long long& _V) const;
         _II do_get(_II _F, _II _L, ios_base& _X,
                ios_base::iostate& _St, unsigned long long& _V) const;

        virtual _II do_get(_II _F, _II _L, ios_base& _X,
                ios_base::iostate& _St, float& _V) const;
        virtual _II do_get(_II _F, _II _L, ios_base& _X,
                ios_base::iostate& _St, double& _V) const
                {char _Ac[8 + 36 + 16], *_Ep;
                errno = 0;
                const double _Ans = _Stod(_Ac, &_Ep,
                        _Getffld(_Ac, _F, _L, _X.getloc()));
                if (_F == _L)
                        _St |= ios_base::eofbit;
                if (_Ep == _Ac || (errno != 0 && errno != 34))
                       _St |= ios_base::failbit;
                else
                        _V = _Ans;
                return (_F); }
        virtual _II do_get(_II _F, _II _L, ios_base& _X,
                ios_base::iostate& _St, long double& _V) const
                {char _Ac[8 + 36 + 16], *_Ep;
                errno = 0;
                const long double _Ans = _Stold(_Ac, &_Ep,
                        _Getffld(_Ac, _F, _L, _X.getloc()));
                if (_F == _L)
                        _St |= ios_base::eofbit;
                if (_Ep == _Ac || (errno != 0 && errno != 34))
                        _St |= ios_base::failbit;
                else
                        _V = _Ans;
                return (_F); }
        virtual _II do_get(_II _F, _II _L, ios_base& _X,
                ios_base::iostate& _St, void *& _V) const
                {union _Pvlo {
                        void *_Pv;
                        unsigned long _Lo[1 +
                                (sizeof (void *) - 1) / sizeof (unsigned long)];
                        } _U;
                const int _NL = sizeof (_U._Lo) / sizeof (unsigned long);
                for (int _I = 0; ; ++_F)
                        {char _Ac[32], * _Ep;
                        errno = 0;
                        _U._Lo[_I] = strtoul(_Ac, &_Ep,
                                _Getifld(_Ac, _F, _L,
                                        ios_base::hex, _X.getloc(),
                                        32));
                        if (_F == _L)
                                _St |= ios_base::eofbit;
                        if (_Ep == _Ac || (errno != 0 && errno != 34))
                                {_St |= ios_base::failbit;
                                break; }
                        if (_NL <= ++_I)
                                break;
                        if (_F == _L || *_F != _Widen(':', (_E *)0))
                                {_St |= ios_base::failbit;
                                break; }}
                if (!(_St & ios_base::failbit))
                        _V = _U._Pv;
                return (_F); }
private:
        static int _Getifld(char *_Ac, _II& _F, _II& _L,
                ios_base::fmtflags _Bfl, const locale& _Loc,
                unsigned int _MaxDigits);
        static int _Getffld(char *_Ac, _II& _F, _II &_L,
                const locale& _Loc);
        };
template<class _E, class _II>
        locale::id num_get<_E, _II>::id;

template<class _E, class _II>
inline _II num_get<_E,_II>::do_get(_II _F, _II _L, ios_base& _X,
                ios_base::iostate& _St, _Bool& _V) const
                {int _Ans = -1;
                if (_X.flags() & ios_base::boolalpha)
                        {const _Mypunct& _Fac = use_facet<_Mypunct >(_X.getloc());
                        _Mystr _Str((typename _Mystr::size_type)1,
                                (char_type)0);
                        _Str += _Fac.falsename();
                        _Str += (char_type)0;
                        _Str += _Fac.truename();
                        _Ans = _Getloctxt(_F, _L, (size_t)2, _Str.c_str()); }
                else
                        {char _Ac[32], * _Ep;
                        errno = 0;
                        const long _Lo = strtol(_Ac, &_Ep,
                                _Getifld(_Ac, _F, _L, _X.flags(), _X.getloc(),
                                32));
                        if (_Ep != _Ac && errno == 0 && (_Lo == 0 || _Lo == 1))
                                _Ans = (int)_Lo; }
                if (_F == _L)
                        _St |= ios_base::eofbit;
                if (_Ans < 0)
                        _St |= ios_base::failbit;
                else
                        _V = _Ans != 0;
                return (_F); }
template<class _E, class _II>
inline _II num_get<_E,_II>::do_get(_II _F, _II _L, ios_base& _X,
                ios_base::iostate& _St, unsigned short& _V) const
                {char _Ac[32], * _Ep;
                errno = 0;
                int _Base = _Getifld(_Ac, _F, _L, _X.flags(), _X.getloc(),
                                     32);
                char *_S = _Ac[0] == '-' ? _Ac + 1 : _Ac;
                const unsigned long _Ans = strtoul(_S, &_Ep, _Base);
                if (_F == _L)
                        _St |= ios_base::eofbit;
                if (_Ep == _S || (errno != 0 && errno != 34))
                        _St |= ios_base::failbit;
                else
                        {if (_Ans > (65535))
                                {_V = (65535);
                                errno = 34; }
                        else
                                _V = (unsigned short)(_Ac[0] == '-'
                                        ? 0 - _Ans : _Ans); }
                return (_F); }
template<class _E, class _II>
inline _II num_get<_E,_II>::do_get(_II _F, _II _L, ios_base& _X,
                ios_base::iostate& _St, unsigned int& _V) const
                {char _Ac[32], * _Ep;
                errno = 0;
                int _Base = _Getifld(_Ac, _F, _L, _X.flags(), _X.getloc(),
                                     32);
#line 385
                char *_S = _Ac;

                const unsigned long _Ans = strtoul(_S, &_Ep, _Base);
                if (_F == _L)
                        _St |= ios_base::eofbit;
                if (_Ep == _S || (errno != 0 && errno != 34))
                        _St |= ios_base::failbit;
                else
#line 401
                        _V = (unsigned int)_Ans;

                return (_F); }
template<class _E, class _II>
inline _II num_get<_E,_II>::do_get(_II _F, _II _L, ios_base& _X,
                ios_base::iostate& _St, long& _V) const
                {char _Ac[32], * _Ep;
                errno = 0;
                const long _Ans = strtol(_Ac, &_Ep,
                        _Getifld(_Ac, _F, _L, _X.flags(), _X.getloc(),
                                 32));
                if (_F == _L)
                        _St |= ios_base::eofbit;
                if (_Ep == _Ac || (errno != 0 && errno != 34))
                        _St |= ios_base::failbit;
                else
                        _V = _Ans;
                return (_F); }
template<class _E, class _II>
inline _II num_get<_E,_II>::do_get(_II _F, _II _L, ios_base& _X,
                ios_base::iostate& _St, unsigned long& _V) const
                {char _Ac[32], * _Ep;
                errno = 0;
                const unsigned long _Ans = strtoul(_Ac, &_Ep,
                        _Getifld(_Ac, _F, _L, _X.flags(), _X.getloc(),
                                 32));
                if (_F == _L)
                        _St |= ios_base::eofbit;
                if (_Ep == _Ac || (errno != 0 && errno != 34))
                        _St |= ios_base::failbit;
                else
                        _V = _Ans;
                return (_F); }

template<class _E, class _II>
inline _II num_get<_E,_II>::do_get(_II _F, _II _L, ios_base& _X,
                ios_base::iostate& _St, long long& _V) const
                {char _Ac[64], * _Ep;
                errno = 0;
                const long long _Ans = strtoll(_Ac, &_Ep,
                        _Getifld(_Ac, _F, _L, _X.flags(), _X.getloc(),
                                 64));
                if (_F == _L)
                        _St |= ios_base::eofbit;
                if (_Ep == _Ac || (errno != 0 && errno != 34))
                        _St |= ios_base::failbit;
                else
                        _V = _Ans;
                return (_F); }
template<class _E, class _II>
inline _II num_get<_E,_II>::do_get(_II _F, _II _L, ios_base& _X,
                ios_base::iostate& _St, unsigned long long& _V) const
                {char _Ac[64], * _Ep;
                errno = 0;
                const unsigned long long _Ans = strtoull(_Ac, &_Ep,
                        _Getifld(_Ac, _F, _L, _X.flags(), _X.getloc(),
                                 64));
                if (_F == _L)
                        _St |= ios_base::eofbit;
                if (_Ep == _Ac || (errno != 0 && errno != 34))
                        _St |= ios_base::failbit;
                else
                        _V = _Ans;
                return (_F); }

template<class _E, class _II>
inline _II num_get<_E,_II>::do_get(_II _F, _II _L, ios_base& _X,
                ios_base::iostate& _St, float& _V) const
                {char _Ac[8 + 36 + 16], *_Ep;
                errno = 0;
                const float _Ans = _Stof(_Ac, &_Ep,
                        _Getffld(_Ac, _F, _L, _X.getloc()));
                if (_F == _L)
                        _St |= ios_base::eofbit;
                if (_Ep == _Ac || (errno != 0 && errno != 34))
                        _St |= ios_base::failbit;
                else
                        _V = _Ans;
                return (_F); }

template<class _E, class _II>
inline int num_get<_E,_II>::_Getifld(char *_Ac, _II& _F, _II& _L,
                ios_base::fmtflags _Bfl, const locale& _Loc,
                unsigned int _MaxDigits)
                {const _E _E0 = _Widen('0', (_E *)0);
                const _Mypunct& _Fac = use_facet<_Mypunct >(_Loc);
                const string _Gr = _Fac.grouping();
                const _E _Ks = _Fac.thousands_sep();
                char *_P = _Ac;
                if (_F == _L)
                        ;
                else if (*_F == _Widen('+', (_E *)0))
                        *_P++ = '+', ++_F;
                else if (*_F == _Widen('-', (_E *)0))
                        *_P++ = '-', ++_F;
                _Bfl &= ios_base::basefield;
                int _Base = _Bfl == ios_base::oct ? 8
                        : _Bfl == ios_base::hex ? 16
                        : _Bfl == ios_base::_Fmtzero ? 0 : 10;
                bool _Sd = false, _Snz = false;
                if (_F != _L && *_F == _E0)
                        {_Sd = true, ++_F;
                        if (_F != _L && (*_F == _Widen('x', (_E *)0)
                                        || *_F == _Widen('X', (_E *)0))
                                && (_Base == 0 || _Base == 16))
                                _Base = 16, _Sd = false, ++_F;
                        else if (_Base == 0)
                                _Base = 8; }
                int _Dlen = _Base == 0 || _Base == 10 ? 10
                        : _Base == 8 ? 8 : 16 + 6;
                string _Grin((size_t)1, (char)_Sd);
                size_t _I = 0;
                for (char *const _Pe = &_Ac[_MaxDigits - 1];
                        _F != _L; ++_F)
                        if (memchr("0123456789abcdefABCDEF",
                                *_P = _Narrow(static_cast<_E>(*_F)), _Dlen) != 0)
                                {if ((_Snz || *_P != '0') && _P < _Pe)
                                        ++_P, _Snz = true;
                                _Sd = true;
                                if (_Grin[_I] != (255))
                                        ++_Grin[_I]; }
                        else if (_Grin[_I] == '\0' || _Ks == (_E)0
                                || *_F != _Ks || _Gr.length() == 0)
                                break;
                        else
                                _Grin.append((string::size_type)1, '\0'), ++_I;
                if (_I == 0)
                        ;
                else if ('\0' < _Grin[_I])
                        ++_I;
                else
                        _Sd = false;
                for (const char *_Pg = _Gr.c_str(); _Sd && 0 < _I; )
                        if (*_Pg == (255))
                                break;
                        else if (0 < --_I && *_Pg != _Grin[_I]
                                || 0 == _I && *_Pg < _Grin[_I])
                                _Sd = false;
                        else if ('\0' < _Pg[1])
                                ++_Pg;
                if (_Sd && !_Snz)
                        *_P++ = '0';
                else if (!_Sd)
                        _P = _Ac;
                *_P = '\0';
                return (_Base);
                }

template<class _E, class _II>
inline int num_get<_E,_II>::_Getffld(char *_Ac, _II& _F, _II &_L,
                const locale& _Loc)
                {const _E _E0 = _Widen('0', (_E *)0);
                const _Mypunct& _Fac = use_facet<_Mypunct >(_Loc);
                char *_P = _Ac;
                bool _IsHexfloat = false;
                if (_F == _L)
                        ;
                else if (*_F == _Widen('+', (_E *)0))
                        *_P++ = '+', ++_F;
                else if (*_F == _Widen('-', (_E *)0))
                        *_P++ = '-', ++_F;
                bool _Sd = false;
                for (; _F != _L && *_F == _E0; _Sd = true, ++_F)
                        ;
                if (_Sd)
                        *_P++ = '0';
                int _Ns = 0;
                int _Pten = 0;

                if (_Sd && _F != _L &&
                        (*_F == _Widen('x', (_E *)0) || *_F == _Widen('X', (_E *)0)))
                        {_IsHexfloat = true;
                        *_P++ = 'x', ++_F; }

                for (; _F != _L
                        && (_IsHexfloat ?
                            (:: isxdigit)(*_P = _Narrow(static_cast<_E>(*_F))) :
                            (:: isdigit)(*_P = _Narrow(static_cast<_E>(*_F))));
                        _Sd = true, ++_F)
                        if (_Ns < 36)
                               ++_P, ++_Ns;
                        else
                               ++_Pten;
                if (_F != _L && *_F == _Fac.decimal_point())
                        *_P++ = localeconv()->decimal_point[0], ++_F;
                if (_Ns == 0)
                        {for (; _F != _L && *_F == _E0; _Sd = true, ++_F)
                                --_Pten;
                        if (_Pten < 0)
                                *_P++ = '0', ++_Pten; }
                for (; _F != _L
                        && (_IsHexfloat ?
                            (:: isxdigit)(*_P = _Narrow(static_cast<_E>(*_F))) :
                            (:: isdigit)(*_P = _Narrow(static_cast<_E>(*_F))));
                        _Sd = true, ++_F)
                        if (_Ns < 36)
                                ++_P, ++_Ns;
                if (_Sd && _F != _L
                        && (_IsHexfloat ?
                                (*_F == _Widen('p', (_E *)0)
                                        || *_F == _Widen('P', (_E *)0)) :
                                (*_F == _Widen('e', (_E *)0)
                                        || *_F == _Widen('E', (_E *)0))))
                        {if (_IsHexfloat)
                                *_P++ = 'p', ++_F;
                        else
                                *_P++ = 'e', ++_F;
                        _Sd = false, _Ns = 0;
                        if (_F == _L)
                                ;
                        else if (*_F == _Widen('+', (_E *)0))
                                *_P++ = '+', ++_F;
                        else if (*_F == _Widen('-', (_E *)0))
                                *_P++ = '-', ++_F;
                        for (; _F != _L && *_F == _E0; _Sd = true, ++_F)
                                ;
                        if (_Sd)
                                *_P++ = '0';
                        for (; _F != _L
                                && (:: isdigit)(*_P = _Narrow(static_cast<_E>(*_F)));
                                _Sd = true, ++_F)
                                if (_Ns < 8)
                                        ++_P, ++_Ns; }
                if (!_Sd)
                        _P = _Ac;
                *_P = '\0';
                return (_Pten);
                }

typedef int __xlc1;
__ExternStaticData template class num_get<char , istreambuf_iterator<char , char_traits<char> > >;
__ExternStaticData template class num_get<wchar_t , istreambuf_iterator<wchar_t , char_traits<wchar_t> > >;

template <>
struct _IsStandardFacet<num_get<char> >
        { enum { value = true }; };

template <>
struct _IsStandardFacet<num_get<wchar_t> >
        { enum { value = true }; };
#line 643
template<class _E,
        class _OI = ostreambuf_iterator<_E, char_traits<_E> > >
        class num_put : public locale::facet {
public:
        typedef numpunct<_E> _Mypunct;
        typedef basic_string<_E, char_traits<_E>, allocator<_E> >
                _Mystr;
        static size_t _Getcat(const locale::facet **_Ppf = 0)
                {if (_Ppf != 0 && *_Ppf == 0)
                        *_Ppf = new num_put<_E, _OI>;
                return (3); }
        static locale::id id;
protected:
        virtual ~num_put()
                {}
protected:
        void _Init(const _Locinfo& _Lobj)
                {}
public:
        explicit num_put(size_t _R = 0)
                : locale::facet(_R) {_Init(_Locinfo()); }
        num_put(const _Locinfo& _Lobj, size_t _R = 0)
                : locale::facet(_R) {_Init(_Lobj); }
        typedef _E char_type;
        typedef _OI iter_type;
        _OI put(_OI _F, ios_base& _X, _E _Fill,
                _Bool _V) const
                {return (do_put(_F, _X, _Fill, _V)); }
        _OI put(_OI _F, ios_base& _X, _E _Fill,
                long _V) const
                {return (do_put(_F, _X, _Fill, _V)); }
        _OI put(_OI _F, ios_base& _X, _E _Fill,
                unsigned long _V) const
                {return (do_put(_F, _X, _Fill, _V)); }

        _OI put(_OI _F, ios_base& _X, _E _Fill,
                long long _V) const
                {return (do_put(_F, _X, _Fill, _V)); }
        _OI put(_OI _F, ios_base& _X, _E _Fill,
                unsigned long long _V) const
                {return (do_put(_F, _X, _Fill, _V)); }

        _OI put(_OI _F, ios_base& _X, _E _Fill,
                double _V) const
                {return (do_put(_F, _X, _Fill, _V)); }
        _OI put(_OI _F, ios_base& _X, _E _Fill,
                long double _V) const
                {return (do_put(_F, _X, _Fill, _V)); }
        _OI put(_OI _F, ios_base& _X, _E _Fill,
                const void *_V) const
                {return (do_put(_F, _X, _Fill, _V)); }
protected:
        virtual _OI do_put(_OI _F, ios_base& _X, _E _Fill,
                _Bool _V) const;
        virtual _OI do_put(_OI _F, ios_base& _X, _E _Fill,
                long _V) const
                {char _Buf[2 * 32], _Fmt[6];
                return (_Iput(_F, _X, _Fill, _Buf,
                        sprintf(_Buf, _Ifmt(_Fmt, 'd', _X.flags()), _V))); }
        virtual _OI do_put(_OI _F, ios_base& _X, _E _Fill,
                unsigned long _V) const
                {char _Buf[2 * 32], _Fmt[6];
                return (_Iput(_F, _X, _Fill, _Buf,
                        sprintf(_Buf, _Ifmt(_Fmt, 'u', _X.flags()), _V))); }

         _OI do_put(_OI _F, ios_base& _X, _E _Fill,
                long long _V) const
                {char _Buf[2 * 64], _Fmt[7];
                return (_Iput(_F, _X, _Fill, _Buf,
                        sprintf(_Buf, _Lfmt(_Fmt, 'd', _X.flags()), _V))); }
         _OI do_put(_OI _F, ios_base& _X, _E _Fill,
                unsigned long long _V) const
                {char _Buf[2 * 64], _Fmt[7];
                return (_Iput(_F, _X, _Fill, _Buf,
                        sprintf(_Buf, _Lfmt(_Fmt, 'u', _X.flags()), _V))); }

        virtual _OI do_put(_OI _F, ios_base& _X, _E _Fill,
                double _V) const
                { return _DoPutFloat(_F, _X, _Fill, _V, 0); }
        virtual _OI do_put(_OI _F, ios_base& _X, _E _Fill,
                long double _V) const
                { return _DoPutFloat(_F, _X, _Fill, _V, 'L'); }
        virtual _OI do_put(_OI _F, ios_base& _X, _E _Fill, const void *_V) const;
        template <class _FltType>
        _OI _DoPutFloat(_OI _F, ios_base& _X, _E _Fill, _FltType _V, const char _Spec) const;
        static char *_Ffmt(char *_Fmt, char _Spec, ios_base::fmtflags _Fl);
        static _OI _Fput(_OI _F, ios_base& _X, _E _Fill,
                const char *_S, size_t _Nz, size_t _N);
        static char *_Ifmt(char *_Fmt, char _Spec, ios_base::fmtflags _Fl);
        static _OI _Iput(_OI _F, ios_base& _X, _E _Fill, char *_S, size_t _N);

        static char *_Lfmt(char *_Fmt, char _Spec, ios_base::fmtflags _Fl);

        static _OI _Put(_OI _F, const _E *_S, size_t _N)
                {for (; 0 < _N; --_N, ++_F, ++_S)
                        *_F = *_S;
                return (_F); }
        static _OI _Putc(_OI _F, const char *_S, size_t _N)
                {for (; 0 < _N; --_N, ++_F, ++_S)
                        *_F = _Widen(*_S, (_E *)0);
                return (_F); }
        static _OI _Rep(_OI _F, _E _C, size_t _N)
                {for (; 0 < _N; --_N, ++_F)
                        *_F = _C;
                return (_F); }
        };
template<class _E, class _OI>
        locale::id num_put<_E, _OI>::id;

template<class _E, class _OI>
inline _OI num_put<_E,_OI>::do_put(_OI _F, ios_base& _X, _E _Fill,
                _Bool _V) const
                {const _Mypunct& _Fac = use_facet<_Mypunct >(_X.getloc());
                _Mystr _Str;
                if (!(_X.flags() & ios_base::boolalpha))
		    {char _Buf[2 * 32], _Fmt[6];
                    return (_Iput(_F, _X, _Fill, _Buf,
                    sprintf(_Buf, _Ifmt(_Fmt, 'd', _X.flags()), _V?1L:0L)));}
		if (_V)
                        _Str = _Fac.truename();
                else
                        _Str = _Fac.falsename();
                size_t _M = _X.width() <= 0
                        || (size_t)_X.width() <= _Str.size()
                                ? 0 : (size_t)_X.width() - _Str.size();
                ios_base::fmtflags _Afl =
                        _X.flags() & ios_base::adjustfield;
                if (_Afl != ios_base::left)
                        _F = _Rep(_F, _Fill, _M), _M = 0;
                _F = _Put(_F, _Str.c_str(), _Str.size());
                _X.width(0);
                return (_Rep(_F, _Fill, _M)); }

template<class _E, class _OI>
inline _OI num_put<_E,_OI>::do_put(_OI _F, ios_base& _X, _E _Fill,
                const void *_V) const
                {
                const int _NL = 1
                        + (sizeof (void *) - 1) / sizeof (unsigned long);
                char _Buf[(_NL + 1) * (32 + 1)];
                int _N = sprintf(_Buf, "%p", _V);
                size_t _M = _X.width() <= 0 || _X.width() <= _N
                        ? 0 : (size_t)_X.width() - _N;
                ios_base::fmtflags _Afl =
                        _X.flags() & ios_base::adjustfield;
                if (_Afl != ios_base::left)
                        _F = _Rep(_F, _Fill, _M), _M = 0;
                _F = _Putc(_F, _Buf, _N);
                _X.width(0);
                return (_Rep(_F, _Fill, _M)); }

template<class _E, class _OI>
        template <class _FltType>
inline _OI num_put<_E,_OI>::_DoPutFloat(_OI _F, ios_base& _X, _E _Fill,
                _FltType _V, const char _Spec) const
                {const size_t _BufSize = 8 + 36 + 16;
                char _Buf[_BufSize], _Fmt[8];
                char * _BufPtr = _Buf;
                streamsize _Prec = _X.precision() <= 0
                        && !(_X.flags() & ios_base::fixed) ? 6
                        : _X.precision();
                int _Mpr = 36 < _Prec ? 36 : _Prec;
                _Ffmt(_Fmt, _Spec, _X.flags());
#line 811
                int _C = snprintf(_BufPtr, _BufSize, _Fmt, _Mpr, _V);
                if (_C >= _BufSize)
                        {_BufPtr = new char[_C + 1];
                     snprintf(_BufPtr, _C + 1, _Fmt, _Mpr, _V); }
                _OI _Ret(_Fput(_F, _X, _Fill, _BufPtr, _Prec - _Mpr, _C));
                if (_BufPtr != _Buf) {delete [] _BufPtr;}

                return _Ret; }
template<class _E, class _OI>
inline char *num_put<_E,_OI>::_Ffmt(char *_Fmt, char _Spec,
                ios_base::fmtflags _Fl)
                {char *_S = _Fmt;
                *_S++ = '%';
                if (_Fl & ios_base::showpos)
                        *_S++ = '+';
                if (_Fl & ios_base::showpoint)
                        *_S++ = '#';
                *_S++ = '.';
                *_S++ = '*';
                if (_Spec != 0)
                        *_S++ = _Spec;   
                ios_base::fmtflags _Ffl = _Fl & ios_base::floatfield;
                switch(_Ffl)
                {
#line 840
                case ios_base::fixed:
                        *_S++ = 'f';
                        break;
                case ios_base::scientific:
                        *_S++ = 'e';
                        break;
                default:
                        *_S++ = 'g';
                        break; }
                *_S = '\0';
                return (_Fmt); }
template<class _E, class _OI>
inline _OI num_put<_E,_OI>::_Fput(_OI _F, ios_base& _X, _E _Fill,
                const char *_S, size_t _Nz, size_t _N)
                {size_t _M = _X.width() <= 0
                        || (size_t)_X.width() <= _N  + _Nz
                                ? 0 : (size_t)_X.width() - _N - _Nz;
                ios_base::fmtflags _Afl =
                        _X.flags() & ios_base::adjustfield;
                if (_Afl != ios_base::left && _Afl != ios_base::internal)
                        _F = _Rep(_F, _Fill, _M), _M = 0;
                else if (_Afl == ios_base::internal)
                        {if (0 < _N && (*_S == '+' || *_S == '-'))
                                _F = _Putc(_F, _S, 1), ++_S, --_N;
                        _F = _Rep(_F, _Fill, _M), _M = 0; }
                const char *_P = (const char *)memchr(_S,
                        localeconv()->decimal_point[0], _N);
                if (_P != 0)
                        {const _Mypunct& _Fac = use_facet<_Mypunct >(_X.getloc());
                        size_t _Nf = _P - _S + 1;
                        _F = _Putc(_F, _S, _Nf - 1);
                        _F = _Rep(_F, _Fac.decimal_point(), 1);
                        _S += _Nf, _N -= _Nf; }
                if ((_P = (const char *)memchr(_S, 'e', _N)) != 0)
                        {size_t _Nm = _P - _S + 1;
                        _F = _Putc(_F, _S, _Nm - 1);
                        _F = _Rep(_F, _Widen('0', (_E *)0), _Nz), _Nz = 0;
                        _F = _Putc(_F, _X.flags() & ios_base::uppercase
                                ? "E" : "e", 1);
                        _S += _Nm, _N -= _Nm; }
                _F = _Putc(_F, _S, _N);
                _F = _Rep(_F, _Widen('0', (_E *)0), _Nz);
                _X.width(0);
                return (_Rep(_F, _Fill, _M)); }

template<class _E, class _OI>
inline char *num_put<_E,_OI>::_Ifmt(char *_Fmt, char _Spec,
                ios_base::fmtflags _Fl)
                {char *_S = _Fmt;
                *_S++ = '%';
                if (_Fl & ios_base::showpos)
                        *_S++ = '+';
                if (_Fl & ios_base::showbase)
                        *_S++ = '#';
                *_S++ = 'l';
                ios_base::fmtflags _Bfl = _Fl & ios_base::basefield;
                *_S++ = _Bfl == ios_base::oct ? 'o'
                        : _Bfl != ios_base::hex ? _Spec  
                        : _Fl & ios_base::uppercase ? 'X' : 'x';
                *_S = '\0';
                return (_Fmt); }

template<class _E, class _OI>
inline _OI num_put<_E,_OI>::_Iput(_OI _F, ios_base& _X, _E _Fill,
                char *_S, size_t _N)
                {const size_t _Np = *_S == '+' || *_S == '-' ? 1
                        : *_S == '0' && (_S[1] == 'x' || _S[1] == 'X') ? 2
                        : 0;
                const _Mypunct& _Fac = use_facet<_Mypunct >(_X.getloc());
                const string _Gr = _Fac.grouping();
                const _E _Ks = _Fac.thousands_sep();
                bool _Grp = '\0' < *_Gr.c_str();
                if (_Grp)
                        {const char *_Pg = _Gr.c_str();
                        size_t _I = _N;
                        for (_Grp = false; *_Pg != (255) && '\0' < *_Pg
                                && (size_t)*_Pg < _I - _Np; _Grp = true)
                                {_I -= *_Pg;
                                memmove(&_S[_I + 1], &_S[_I], _N + 1 - _I);
                                _S[_I] = ',', ++_N;
                                if ('\0' < _Pg[1])
                                        ++_Pg; }}
                size_t _M = _X.width() <= 0
                        || (size_t)_X.width() <= _N
                                ? 0 : (size_t)_X.width() - _N;
                ios_base::fmtflags _Afl =
                        _X.flags() & ios_base::adjustfield;
                if (_Afl != ios_base::left && _Afl != ios_base::internal)
                        _F = _Rep(_F, _Fill, _M), _M = 0;
                else if (_Afl == ios_base::internal)
                        {_F = _Putc(_F, _S, _Np), _S += _Np, _N -= _Np;
                        _F = _Rep(_F, _Fill, _M), _M = 0; }
                if (!_Grp)
                        _F = _Putc(_F, _S, _N);
                else
                        for (; ; ++_S, --_N)
                                {size_t _Nd = strcspn(_S, ",");
                                _F = _Putc(_F, _S, _Nd);
                                _S += _Nd, _N -= _Nd;
                                if (_N == 0)
                                        break;
                                if (_Ks != (_E)0)
                                        _F = _Rep(_F, _Ks, 1); }
                _X.width(0);
                return (_Rep(_F, _Fill, _M)); }
#line 947
template<class _E, class _OI>
inline char *num_put<_E,_OI>::_Lfmt(char *_Fmt, char _Spec,
                ios_base::fmtflags _Fl)
                {char *_S = _Fmt;
                *_S++ = '%';
                if (_Fl & ios_base::showpos)
                        *_S++ = '+';
                if (_Fl & ios_base::showbase)
                        *_S++ = '#';

                *_S++ = 'l';
                *_S++ = 'l';
#line 962
                ios_base::fmtflags _Bfl = _Fl & ios_base::basefield;
                *_S++ = _Bfl == ios_base::oct ? 'o'
                        : _Bfl != ios_base::hex ? _Spec  
                        : _Fl & ios_base::uppercase ? 'X' : 'x';
                *_S = '\0';
                return (_Fmt); }
#line 970
typedef int __xlc2;
__ExternStaticData template class num_put<char , ostreambuf_iterator<char , char_traits<char> > >;
__ExternStaticData template class num_put<wchar_t , ostreambuf_iterator<wchar_t , char_traits<wchar_t> > >;

template <>
struct _IsStandardFacet<num_put<char> >
        { enum { value = true }; };

template <>
struct _IsStandardFacet<num_put<wchar_t> >
        { enum { value = true }; };
#line 988
};

#pragma namemangling()

#pragma object_model(pop)
#line 999
#pragma info(none)

#  pragma report(pop)

#pragma info(restore)
#line 77 "/usr/vacpp/include/ios"
namespace std {
#line 82
template<class _E, class _Tr>
        class basic_ios : public ios_base {
public:
        typedef basic_ios<_E, _Tr> _Myt;
        typedef basic_ostream<_E, _Tr> _Myos;
        typedef basic_streambuf<_E, _Tr> _Mysb;
        typedef ctype<_E> _Ctype;
        explicit basic_ios(_Mysb *_S)
                {init(_S); }
        virtual ~basic_ios()
                {}
        typedef _E char_type;
        typedef _Tr traits_type;
        typedef typename _Tr::int_type int_type;
        typedef typename _Tr::pos_type pos_type;
        typedef typename _Tr::off_type off_type;
        void clear(iostate _St, bool _Ex)
                {ios_base::clear((iostate)(_Sb == 0
                        ? (int)_St | (int)badbit : (int)_St), _Ex); }
        void clear(io_state _St)
                {clear((iostate)_St, false); }
        void clear(iostate _St = goodbit)
                {clear(_St, false); }
        void setstate(iostate _St, bool _Ex)
                {if (_St != goodbit)
                        clear((iostate)((int)rdstate() | (int)_St), _Ex); }
        void setstate(io_state _St)
                {setstate((iostate)_St, false); }
        void setstate(iostate _St)
                {setstate(_St, false); }
        _Myt& copyfmt(const _Myt& _R)
                {_Tiestr = _R.tie();
                _Fillch = _R.fill();
                ios_base::copyfmt(_R);
                return (*this); }
        _Myos *tie() const
                {return (_Tiestr); }
        _Myos *tie(_Myos *_N)
                {_Myos *_O = _Tiestr;
                _Tiestr = _N;
                return (_O); }
        _Mysb *rdbuf() const
                {return (_Sb); }
        _Mysb *rdbuf(_Mysb *_N)
                {_Mysb *_O = _Sb;
                _Sb = _N;
                clear();
                return (_O); }
        locale imbue(const locale& _Ln)
                {if (rdbuf() != 0)
                        rdbuf()->pubimbue(_Ln);
                return (ios_base::imbue(_Ln)); }
        _E fill() const
                {return (_Fillch); }
        _E fill(_E _Nf)
                {_E _Of = _Fillch;
                _Fillch = _Nf;
                return (_Of); }
        char narrow(_E _C, char _D = '\0') const
                {const _Ctype& _Fac = use_facet<_Ctype >(getloc());
                return (_Fac.narrow(_C, _D)); }
        _E widen(char _C) const
                {const _Ctype& _Fac = use_facet<_Ctype >(getloc());
                return (_Fac.widen(_C)); }
protected:
        void init(_Mysb *_S = 0,
                bool _Isstd = false)
                {_Sb = _S;
                _Tiestr = 0;
                _Fillch = _Widen(' ', (_E *)0);
                _Init();
                if (_Sb == 0)
                        setstate(badbit);
                if (_Isstd)
                        _Addstd(); }
        basic_ios()
                {}
private:
        basic_ios(const _Myt&);  
        basic_ios& operator=(const _Myt&);       
        _Mysb *_Sb;
        _Myos *_Tiestr;
        _E _Fillch;
        };

inline ios_base& boolalpha(ios_base& _I)
        {_I.setf(ios_base::boolalpha);
        return (_I); }
inline ios_base& dec(ios_base& _I)
        {_I.setf(ios_base::dec, ios_base::basefield);
        return (_I); }
inline ios_base& fixed(ios_base& _I)
        {_I.setf(ios_base::fixed, ios_base::floatfield);
        return (_I); }
inline ios_base& hex(ios_base& _I)
        {_I.setf(ios_base::hex, ios_base::basefield);
        return (_I); }
inline ios_base& internal(ios_base& _I)
        {_I.setf(ios_base::internal, ios_base::adjustfield);
        return (_I); }
inline ios_base& left(ios_base& _I)
        {_I.setf(ios_base::left, ios_base::adjustfield);
        return (_I); }
inline ios_base& noboolalpha(ios_base& _I)
        {_I.unsetf(ios_base::boolalpha);
        return (_I); }
inline ios_base& noshowbase(ios_base& _I)
        {_I.unsetf(ios_base::showbase);
        return (_I); }
inline ios_base& noshowpoint(ios_base& _I)
        {_I.unsetf(ios_base::showpoint);
        return (_I); }
inline ios_base& noshowpos(ios_base& _I)
        {_I.unsetf(ios_base::showpos);
        return (_I); }
inline ios_base& noskipws(ios_base& _I)
        {_I.unsetf(ios_base::skipws);
        return (_I); }
inline ios_base& nounitbuf(ios_base& _I)
        {_I.unsetf(ios_base::unitbuf);
        return (_I); }
inline ios_base& nouppercase(ios_base& _I)
        {_I.unsetf(ios_base::uppercase);
        return (_I); }
inline ios_base& oct(ios_base& _I)
        {_I.setf(ios_base::oct, ios_base::basefield);
        return (_I); }
inline ios_base& right(ios_base& _I)
        {_I.setf(ios_base::right, ios_base::adjustfield);
        return (_I); }
inline ios_base& scientific(ios_base& _I)
        {_I.setf(ios_base::scientific, ios_base::floatfield);
        return (_I); }
inline ios_base& showbase(ios_base& _I)
        {_I.setf(ios_base::showbase);
        return (_I); }
inline ios_base& showpoint(ios_base& _I)
        {_I.setf(ios_base::showpoint);
        return (_I); }
inline ios_base& showpos(ios_base& _I)
        {_I.setf(ios_base::showpos);
        return (_I); }
inline ios_base& skipws(ios_base& _I)
        {_I.setf(ios_base::skipws);
        return (_I); }
inline ios_base& unitbuf(ios_base& _I)
        {_I.setf(ios_base::unitbuf);
        return (_I); }
inline ios_base& uppercase(ios_base& _I)
        {_I.setf(ios_base::uppercase);
        return (_I); }
#line 248
};

#pragma namemangling()

#pragma object_model(pop)
#line 259
#pragma info(none)

#  pragma report(pop)

#pragma info(restore)
#line 78 "/usr/vacpp/include/ostream"
namespace std {
#line 95
template<class _E, class _Tr>
        class basic_ostream : virtual public basic_ios<_E, _Tr> {
public:
        typedef basic_ostream<_E, _Tr> _Myt;
        typedef basic_ios<_E, _Tr> _Myios;
        typedef basic_streambuf<_E, _Tr> _Mysb;
        typedef ostreambuf_iterator<_E, _Tr> _Iter;
        typedef num_put<_E, _Iter> _Nput;
        explicit basic_ostream(basic_streambuf<_E, _Tr> *_S,
                bool _Isstd = false)
                {_Myios::init(_S, _Isstd); }
        basic_ostream(_Uninitialized)
                {ios_base::_Addstd(); }
        virtual ~basic_ostream()
                {}

        typedef typename _Tr::int_type int_type;
        typedef typename _Tr::pos_type pos_type;
        typedef typename _Tr::off_type off_type;
        class sentry {
        public:
                explicit sentry(_Myt& _Os)
#line 120
                        : _Lk(_Lockit::_Str), _Ostr(_Os)

                        {if (_Os.good() && _Os.tie() != 0)
                                _Os.tie()->flush();
                        _Ok = _Os.good(); }
                ~sentry()
                        {if (!uncaught_exception())
                                _Ostr.osfx(); }
                operator bool() const
                        {return (_Ok); }
        private:
                sentry(const sentry&);   
                sentry& operator=(const sentry&);        
                bool _Ok;
                _Lockit _Lk;
                _Myt& _Ostr;
                };

        bool opfx()
                {if (ios_base::good() && _Myios::tie() != 0)
                        _Myios::tie()->flush();
                return (ios_base::good()); }
        void osfx()
                {if (ios_base::flags() & ios_base::unitbuf)
                        flush(); }
        _Myt& operator<<(_Myt& (*_F)(_Myt&))
                {return ((*_F)(*this)); }
        _Myt& operator<<(_Myios& (*_F)(_Myios&))
                {(*_F)(*(_Myios *)this);
                return (*this); }
#line 155
        _Myt& operator<<(ios_base& (*_F)(ios_base&))
                {(*_F)(*(ios_base *)this);
                return (*this); }
        _Myt& operator<<(_Bool _X);
        _Myt& operator<<(short _X);
        _Myt& operator<<(unsigned short _X);
        _Myt& operator<<(int _X);
        _Myt& operator<<(unsigned int _X);
        _Myt& operator<<(long _X);
        _Myt& operator<<(unsigned long _X);

        _Myt& operator<<(long long _X);
        _Myt& operator<<(unsigned long long _X);

        _Myt& operator<<(float _X);
        _Myt& operator<<(double _X);
        _Myt& operator<<(long double _X);
        _Myt& operator<<(const void *_X);
        _Myt& operator<<(_Mysb *_Pb);
        _Myt& put(_E _X);
        _Myt& write(const _E *_S, streamsize _N);
        _Myt& flush()
                {ios_base::iostate _St = ios_base::goodbit;
                if (!ios_base::fail()
                        && _Myios::rdbuf()->pubsync() == -1)
                        _St |= ios_base::badbit;
                _Myios::setstate(_St);
                return (*this); }
        _Myt& seekp(pos_type _P)
                {if (!ios_base::fail())
                        if (_Myios::rdbuf()->pubseekpos(_P, ios_base::out)
                            == streampos(_BADOFF))
                                _Myios::setstate(ios_base::failbit);
                return (*this); }
        _Myt& seekp(off_type _O, ios_base::seekdir _W)
                {if (!ios_base::fail())
                        if (_Myios::rdbuf()->pubseekoff(_O, _W, ios_base::out)
                            == streampos(_BADOFF))
                                _Myios::setstate(ios_base::failbit);
                return (*this); }
        pos_type tellp()
                {if (!ios_base::fail())
                        return (_Myios::rdbuf()->pubseekoff(0,
                                ios_base::cur, ios_base::out));
                else
                        return (pos_type(_BADOFF)); }
        };
#line 204
template<class _E, class _Tr>
        basic_ostream<_E, _Tr>& operator<<(
                basic_ostream<_E, _Tr>& _O, const char *_X);

template<class _E, class _Tr>
        basic_ostream<_E, _Tr>& operator<<(
                basic_ostream<_E, _Tr>& _O, char _C);

template<class _Tr>
        basic_ostream<char, _Tr>& operator<<(
                basic_ostream<char, _Tr>& _O,
                const char *_X);

template<class _Tr>
        basic_ostream<char, _Tr>& operator<<(
                basic_ostream<char, _Tr>& _O, char _C);

template<class _E, class _Tr>
        basic_ostream<_E, _Tr>& operator<<(
                basic_ostream<_E, _Tr>& _O, const _E *_X);

template<class _E, class _Tr>
        basic_ostream<_E, _Tr>& operator<<(
                basic_ostream<_E, _Tr>& _O, _E _C);

template<class _Tr> inline
        basic_ostream<char, _Tr>& operator<<(
                basic_ostream<char, _Tr>& _O, const signed char *_X)
        {return (_O << (const char *)_X); }
template<class _Tr> inline
        basic_ostream<char, _Tr>& operator<<(
                basic_ostream<char, _Tr>& _O, const signed char _C)
        {return (_O << (char)_C); }
template<class _Tr> inline
        basic_ostream<char, _Tr>& operator<<(
                basic_ostream<char, _Tr>& _O, const unsigned char *_X)
        {return (_O << (const char *)_X); }
template<class _Tr> inline
        basic_ostream<char, _Tr>& operator<<(
                basic_ostream<char, _Tr>& _O, const unsigned char _C)
        {return (_O << (char)_C); }
#line 247
template<class _E, class _Tr> inline
        basic_ostream<_E, _Tr>&
                endl(basic_ostream<_E, _Tr>& _O)
        {_O.put(_O.widen('\n'));
        _O.flush();
        return (_O); }
template<class _E, class _Tr> inline
        basic_ostream<_E, _Tr>&
                ends(basic_ostream<_E, _Tr>& _O)
        {_O.put(_E());
        return (_O); }
template<class _E, class _Tr> inline
        basic_ostream<_E, _Tr>&
                flush(basic_ostream<_E, _Tr>& _O)
        {_O.flush();
        return (_O); }
#line 269
};

#pragma implementation("ostream.t")
#line 32 "/usr/vacpp/include/ostream.t"
namespace std {
#line 38
template<class _E, class _Tr>
inline
typename basic_ostream<_E, _Tr>::_Myt&
basic_ostream<_E, _Tr>::operator<<(_Bool _X)
        {ios_base::iostate _St = ios_base::goodbit;
        const sentry _Ok(*this);
        if (_Ok)
                {const _Nput& _Fac = use_facet<_Nput >(ios_base::getloc());
                try {
                if (_Fac.put(_Iter(_Myios::rdbuf()), *this,
                        _Myios::fill(), _X).failed())
                        _St |= ios_base::badbit;
                } catch (...) { _Myios::setstate(ios_base::badbit, true); } }
        _Myios::setstate(_St);
        return (*this); }
#line 55
template<class _E, class _Tr>
inline
typename basic_ostream<_E, _Tr>::_Myt&
basic_ostream<_E, _Tr>::operator<<(short _X)
        {ios_base::iostate _St = ios_base::goodbit;
        const sentry _Ok(*this);
        if (_Ok)
                {const _Nput& _Fac = use_facet<_Nput >(ios_base::getloc());
                ios_base::fmtflags _Bfl =
                        ios_base::flags() & ios_base::basefield;
                long _Y = (_Bfl == ios_base::oct
                        || _Bfl == ios_base::hex)
                        ? (long)(unsigned short)_X : (long)_X;
                try {
                if (_Fac.put(_Iter(_Myios::rdbuf()), *this,
                        _Myios::fill(), _Y).failed())
                        _St |= ios_base::badbit;
                } catch (...) { _Myios::setstate(ios_base::badbit, true); } }
        _Myios::setstate(_St);
        return (*this); }
#line 77
template<class _E, class _Tr>
inline
typename basic_ostream<_E, _Tr>::_Myt&
basic_ostream<_E, _Tr>::operator<<(unsigned short _X)
        {ios_base::iostate _St = ios_base::goodbit;
        const sentry _Ok(*this);
        if (_Ok)
                {const _Nput& _Fac = use_facet<_Nput >(ios_base::getloc());
                try {
                if (_Fac.put(_Iter(_Myios::rdbuf()), *this,
                        _Myios::fill(), (unsigned long)_X).failed())
                        _St |= ios_base::badbit;
                } catch (...) { _Myios::setstate(ios_base::badbit, true); } }
        _Myios::setstate(_St);
        return (*this); }
#line 94
template<class _E, class _Tr>
inline
typename basic_ostream<_E, _Tr>::_Myt&
basic_ostream<_E, _Tr>::operator<<(int _X)
        {ios_base::iostate _St = ios_base::goodbit;
        const sentry _Ok(*this);
        if (_Ok)
                {const _Nput& _Fac = use_facet<_Nput >(ios_base::getloc());
                ios_base::fmtflags _Bfl =
                        ios_base::flags() & ios_base::basefield;
                long _Y = (_Bfl == ios_base::oct
                        || _Bfl == ios_base::hex)
                        ? (long)(unsigned int)_X : (long)_X;
                try {
                if (_Fac.put(_Iter(_Myios::rdbuf()), *this,
                        _Myios::fill(), _Y).failed())
                        _St |= ios_base::badbit;
                } catch (...) { _Myios::setstate(ios_base::badbit, true); } }
        _Myios::setstate(_St);
        return (*this); }
#line 116
template<class _E, class _Tr>
inline
typename basic_ostream<_E, _Tr>::_Myt&
basic_ostream<_E, _Tr>::operator<<(unsigned int _X)
        {ios_base::iostate _St = ios_base::goodbit;
        const sentry _Ok(*this);
        if (_Ok)
                {const _Nput& _Fac = use_facet<_Nput >(ios_base::getloc());
                try {
                if (_Fac.put(_Iter(_Myios::rdbuf()), *this,
                        _Myios::fill(), (unsigned long)_X).failed())
                        _St |= ios_base::badbit;
                } catch (...) { _Myios::setstate(ios_base::badbit, true); } }
        _Myios::setstate(_St);
        return (*this); }

template<class _E, class _Tr>
inline
typename basic_ostream<_E, _Tr>::_Myt&
basic_ostream<_E, _Tr>::operator<<(long _X)
        {ios_base::iostate _St = ios_base::goodbit;
        const sentry _Ok(*this);
        if (_Ok)
                {const _Nput& _Fac = use_facet<_Nput >(ios_base::getloc());
                try {
                if (_Fac.put(_Iter(_Myios::rdbuf()), *this,
                        _Myios::fill(), _X).failed())
                        _St |= ios_base::badbit;
                } catch (...) { _Myios::setstate(ios_base::badbit, true); } }
        _Myios::setstate(_St);
        return (*this); }
#line 149
template<class _E, class _Tr>
inline
typename basic_ostream<_E, _Tr>::_Myt&
basic_ostream<_E, _Tr>::operator<<(unsigned long _X)
        {ios_base::iostate _St = ios_base::goodbit;
        const sentry _Ok(*this);
        if (_Ok)
                {const _Nput& _Fac = use_facet<_Nput >(ios_base::getloc());
                try {
                if (_Fac.put(_Iter(_Myios::rdbuf()), *this,
                        _Myios::fill(), _X).failed())
                        _St |= ios_base::badbit;
                } catch (...) { _Myios::setstate(ios_base::badbit, true); } }
        _Myios::setstate(_St);
        return (*this); }
#line 166
template<class _E, class _Tr>
inline
typename basic_ostream<_E, _Tr>::_Myt&
basic_ostream<_E, _Tr>::operator<<(long long _X)
        {ios_base::iostate _St = ios_base::goodbit;
        const sentry _Ok(*this);
        if (_Ok)
                {const _Nput& _Fac = use_facet<_Nput >(ios_base::getloc());
                try {
                if (_Fac.put(_Iter(_Myios::rdbuf()), *this,
                        _Myios::fill(), _X).failed())
                        _St |= ios_base::badbit;
                } catch (...) { _Myios::setstate(ios_base::badbit, true); } }
        _Myios::setstate(_St);
        return (*this); }

template<class _E, class _Tr>
inline
typename basic_ostream<_E, _Tr>::_Myt&
basic_ostream<_E, _Tr>::operator<<(unsigned long long _X)
        {ios_base::iostate _St = ios_base::goodbit;
        const sentry _Ok(*this);
        if (_Ok)
                {const _Nput& _Fac = use_facet<_Nput >(ios_base::getloc());
                try {
                if (_Fac.put(_Iter(_Myios::rdbuf()), *this,
                        _Myios::fill(), _X).failed())
                        _St |= ios_base::badbit;
                } catch (...) { _Myios::setstate(ios_base::badbit, true); } }
        _Myios::setstate(_St);
        return (*this); }
#line 199
template<class _E, class _Tr>
inline
typename basic_ostream<_E, _Tr>::_Myt&
basic_ostream<_E, _Tr>::operator<<(float _X)
        {ios_base::iostate _St = ios_base::goodbit;
        const sentry _Ok(*this);
        if (_Ok)
                {const _Nput& _Fac = use_facet<_Nput >(ios_base::getloc());
                try {
                if (_Fac.put(_Iter(_Myios::rdbuf()), *this,
                        _Myios::fill(), (double)_X).failed())
                        _St |= ios_base::badbit;
                } catch (...) { _Myios::setstate(ios_base::badbit, true); } }
        _Myios::setstate(_St);
        return (*this); }

template<class _E, class _Tr>
inline
typename basic_ostream<_E, _Tr>::_Myt&
basic_ostream<_E, _Tr>::operator<<(double _X)
        {ios_base::iostate _St = ios_base::goodbit;
        const sentry _Ok(*this);
        if (_Ok)
                {const _Nput& _Fac = use_facet<_Nput >(ios_base::getloc());
                try {
                if (_Fac.put(_Iter(_Myios::rdbuf()), *this,
                        _Myios::fill(), _X).failed())
                        _St |= ios_base::badbit;
                } catch (...) { _Myios::setstate(ios_base::badbit, true); } }
        _Myios::setstate(_St);
        return (*this); }

template<class _E, class _Tr>
inline
typename basic_ostream<_E, _Tr>::_Myt&
basic_ostream<_E, _Tr>::operator<<(long double _X)
        {ios_base::iostate _St = ios_base::goodbit;
        const sentry _Ok(*this);
        if (_Ok)
                {const _Nput& _Fac = use_facet<_Nput >(ios_base::getloc());
                try {
                if (_Fac.put(_Iter(_Myios::rdbuf()), *this,
                        _Myios::fill(), _X).failed())
                        _St |= ios_base::badbit;
                } catch (...) { _Myios::setstate(ios_base::badbit, true); } }
        _Myios::setstate(_St);
        return (*this); }

template<class _E, class _Tr>
inline
typename basic_ostream<_E, _Tr>::_Myt&
basic_ostream<_E, _Tr>::operator<<(const void *_X)
        {ios_base::iostate _St = ios_base::goodbit;
        const sentry _Ok(*this);
        if (_Ok)
                {const _Nput& _Fac = use_facet<_Nput >(ios_base::getloc());
                try {
                if (_Fac.put(_Iter(_Myios::rdbuf()), *this,
                        _Myios::fill(), _X).failed())
                        _St |= ios_base::badbit;
                } catch (...) { _Myios::setstate(ios_base::badbit, true); } }
        _Myios::setstate(_St);
        return (*this); }

template<class _E, class _Tr>
inline
typename basic_ostream<_E, _Tr>::_Myt&
basic_ostream<_E, _Tr>::operator<<(_Mysb *_Pb)
        {ios_base::iostate _St = ios_base::goodbit;
        bool _Copied = false;
        const sentry _Ok(*this);
        if (_Ok && _Pb != 0)
                for (int_type _C = _Tr::eof(); ; _Copied = true)
                        {try {
                        _C = _Tr::eq_int_type(_Tr::eof(), _C)
                                ? _Pb->sgetc() : _Pb->snextc();
                        } catch (...) {
                                _Myios::setstate(ios_base::failbit);
                                throw;
                        }
                        if (_Tr::eq_int_type(_Tr::eof(),_C))
                                break;
                        try {
                                if (_Tr::eq_int_type(_Tr::eof(),
                                        _Myios::rdbuf()->sputc(
                                                _Tr::to_char_type(_C))))
                                        {_St |= ios_base::badbit;
                                        break; }
                        } catch (...) { _Myios::setstate(ios_base::badbit, true); } }
        ios_base::width(0);
        _Myios::setstate(_Pb == 0 ? ios_base::badbit :
                (!_Copied ? _St | ios_base::failbit : _St));
        return (*this); }

template<class _E, class _Tr>
inline
typename basic_ostream<_E, _Tr>::_Myt& basic_ostream<_E, _Tr>::put(_E _X)
        {ios_base::iostate _St = ios_base::goodbit;
        const sentry _Ok(*this);
        if (!_Ok)
                _St |= ios_base::badbit;
        else
                {try {
                 if (_Tr::eq_int_type(_Tr::eof(),
                        _Myios::rdbuf()->sputc(_X)))
                        _St |= ios_base::badbit;
                } catch (...) { _Myios::setstate(ios_base::badbit, true); } }
        _Myios::setstate(_St);
        return (*this); }

template<class _E, class _Tr>
inline
typename basic_ostream<_E, _Tr>::_Myt&
basic_ostream<_E, _Tr>::write(const _E *_S, streamsize _N)
        {ios_base::iostate _St = ios_base::goodbit;
        const sentry _Ok(*this);
        if (!_Ok)
                _St |= ios_base::badbit;
        else
                {try {
                if (_Myios::rdbuf()->sputn(_S, _N) != _N)
                        _St |= ios_base::badbit;
                } catch (...) { _Myios::setstate(ios_base::badbit, true); } }
        _Myios::setstate(_St);
        return (*this); }

template<class _E, class _Tr>
inline
basic_ostream<_E, _Tr>& operator<<(basic_ostream<_E, _Tr>& _O, const char *_X)
        {ios_base::iostate _St = ios_base::goodbit;
        size_t _N = strlen(_X);
        size_t _M = _O.width() <= 0
                || (size_t)_O.width() <= _N
                ? 0 : (size_t)_O.width() - _N;
        const typename basic_ostream<_E, _Tr>::sentry _Ok(_O);
        if (!_Ok)
                _St |= ios_base::badbit;
        else
                {try {
                const ctype<_E>& _Fac = use_facet<ctype<_E> >(_O.getloc());
                if ((_O.flags() & ios_base::adjustfield)
                        != ios_base::left)
                        for (; 0 < _M; --_M)
                                if (_Tr::eq_int_type(_Tr::eof(),
                                        _O.rdbuf()->sputc(_O.fill())))
                                        {_St |= ios_base::badbit;
                                        break; }
                for (; _St == ios_base::goodbit && 0 < _N; --_N, ++_X)
                        if (_Tr::eq_int_type(_Tr::eof(),
                                _O.rdbuf()->sputc(_Fac.widen(*_X))))
                                        _St |= ios_base::badbit;
                if (_St == ios_base::goodbit)
                        for (; 0 < _M; --_M)
                                if (_Tr::eq_int_type(_Tr::eof(),
                                        _O.rdbuf()->sputc(_O.fill())))
                                        {_St |= ios_base::badbit;
                                        break; }
                _O.width(0);
                } catch (...) { (_O).setstate(ios_base::badbit, true); } }
        _O.setstate(_St);
        return (_O); }
#line 370
template<class _E, class _Tr>
inline
basic_ostream<_E, _Tr>& operator<<(basic_ostream<_E, _Tr>& _O, char _C)
        {ios_base::iostate _St = ios_base::goodbit;
        const typename basic_ostream<_E, _Tr>::sentry _Ok(_O);
        if (_Ok)
                {const ctype<_E>& _Fac = use_facet<ctype<_E> >(_O.getloc());
                size_t _M = _O.width() <= 1 ? 0 : _O.width() - 1;
                try {
                if ((_O.flags() & ios_base::adjustfield)
                        != ios_base::left)
                        for (; _St == ios_base::goodbit && 0 < _M; --_M)
                                if (_Tr::eq_int_type(_Tr::eof(),
                                        _O.rdbuf()->sputc(_O.fill())))
                                        _St |= ios_base::badbit;
                if (_St == ios_base::goodbit
                        && _Tr::eq_int_type(_Tr::eof(),
                                _O.rdbuf()->sputc(_Fac.widen(_C))))
                        _St |= ios_base::badbit;
                for (; _St == ios_base::goodbit && 0 < _M; --_M)
                        if (_Tr::eq_int_type(_Tr::eof(),
                                _O.rdbuf()->sputc(_O.fill())))
                                _St |= ios_base::badbit;
                } catch (...) { (_O).setstate(ios_base::badbit, true); } }
        _O.width(0);
        _O.setstate(_St);
        return (_O); }

template<class _Tr>
inline
basic_ostream<char, _Tr>& operator<<(basic_ostream<char, _Tr>& _O,
                const char *_X)
        {typedef char _E;
        typedef basic_ostream<_E, _Tr> _Myos;
        ios_base::iostate _St = ios_base::goodbit;
        size_t _N = _Tr::length(_X);
        size_t _M = _O.width() <= 0
                || (size_t)_O.width() <= _N
                ? 0 : (size_t)_O.width() - _N;
        const typename _Myos::sentry _Ok(_O);
        if (!_Ok)
                _St |= ios_base::badbit;
        else
                {try {
                if ((_O.flags() & ios_base::adjustfield)
                        != ios_base::left)
                        for (; 0 < _M; --_M)
                                if (_Tr::eq_int_type(_Tr::eof(),
                                        _O.rdbuf()->sputc(_O.fill())))
                                        {_St |= ios_base::badbit;
                                        break; }
                if (_St == ios_base::goodbit
                        && (size_t)_O.rdbuf()->sputn(_X, _N) != _N)
                        _St |= ios_base::badbit;
                if (_St == ios_base::goodbit)
                        for (; 0 < _M; --_M)
                                if (_Tr::eq_int_type(_Tr::eof(),
                                        _O.rdbuf()->sputc(_O.fill())))
                                        {_St |= ios_base::badbit;
                                        break; }
                _O.width(0);
                } catch (...) { (_O).setstate(ios_base::badbit, true); } }
        _O.setstate(_St);
        return (_O); }
#line 444
template<class _Tr>
inline
basic_ostream<char, _Tr>& operator<<(basic_ostream<char, _Tr>& _O, char _C)
        {typedef char _E;
        typedef basic_ostream<_E, _Tr> _Myos;
        ios_base::iostate _St = ios_base::goodbit;
        const typename _Myos::sentry _Ok(_O);
        if (_Ok)
                {size_t _M = _O.width() <= 1 ? 0 : _O.width() - 1;
                try {
                if ((_O.flags() & ios_base::adjustfield)
                        != ios_base::left)
                        for (; _St == ios_base::goodbit && 0 < _M; --_M)
                                if (_Tr::eq_int_type(_Tr::eof(),
                                        _O.rdbuf()->sputc(_O.fill())))
                                        _St |= ios_base::badbit;
                if (_St == ios_base::goodbit
                        && _Tr::eq_int_type(_Tr::eof(),
                                _O.rdbuf()->sputc(_C)))
                        _St |= ios_base::badbit;
                for (; _St == ios_base::goodbit && 0 < _M; --_M)
                        if (_Tr::eq_int_type(_Tr::eof(),
                                _O.rdbuf()->sputc(_O.fill())))
                                _St |= ios_base::badbit;
                } catch (...) { (_O).setstate(ios_base::badbit, true); } }
        _O.width(0);
        _O.setstate(_St);
        return (_O); }

template<class _E, class _Tr>
inline
basic_ostream<_E, _Tr>& operator<<(basic_ostream<_E, _Tr>& _O, const _E *_X)
        {typedef basic_ostream<_E, _Tr> _Myos;
        ios_base::iostate _St = ios_base::goodbit;
        size_t _N = _Tr::length(_X);
        size_t _M = _O.width() <= 0
                || (size_t)_O.width() <= _N
                        ? 0 : (size_t)_O.width() - _N;
        const typename _Myos::sentry _Ok(_O);
        if (!_Ok)
                _St |= ios_base::badbit;
        else
                {try {
                if ((_O.flags() & ios_base::adjustfield)
                        != ios_base::left)
                        for (; 0 < _M; --_M)
                                if (_Tr::eq_int_type(_Tr::eof(),
                                        _O.rdbuf()->sputc(_O.fill())))
                                        {_St |= ios_base::badbit;
                                        break; }
                if (_St == ios_base::goodbit
                        && (size_t)_O.rdbuf()->sputn(_X, _N) != _N)
                        _St |= ios_base::badbit;
                if (_St == ios_base::goodbit)
                        for (; 0 < _M; --_M)
                                if (_Tr::eq_int_type(_Tr::eof(),
                                        _O.rdbuf()->sputc(_O.fill())))
                                        {_St |= ios_base::badbit;
                                        break; }
                _O.width(0);
                } catch (...) { (_O).setstate(ios_base::badbit, true); } }
        _O.setstate(_St);
        return (_O); }
#line 518
template<class _E, class _Tr>
inline
basic_ostream<_E, _Tr>& operator<<(basic_ostream<_E, _Tr>& _O, _E _C)
        {typedef basic_ostream<_E, _Tr> _Myos;
        ios_base::iostate _St = ios_base::goodbit;
        const typename _Myos::sentry _Ok(_O);
        if (_Ok)
                {size_t _M = _O.width() <= 1 ? 0 : _O.width() - 1;
                try {
                if ((_O.flags() & ios_base::adjustfield)
                        != ios_base::left)
                        for (; _St == ios_base::goodbit && 0 < _M; --_M)
                                if (_Tr::eq_int_type(_Tr::eof(),
                                        _O.rdbuf()->sputc(_O.fill())))
                                        _St |= ios_base::badbit;
                if (_St == ios_base::goodbit
                        && _Tr::eq_int_type(_Tr::eof(),
                                _O.rdbuf()->sputc(_C)))
                        _St |= ios_base::badbit;
                for (; _St == ios_base::goodbit && 0 < _M; --_M)
                        if (_Tr::eq_int_type(_Tr::eof(),
                                _O.rdbuf()->sputc(_O.fill())))
                                _St |= ios_base::badbit;
                } catch (...) { (_O).setstate(ios_base::badbit, true); } }
        _O.width(0);
        _O.setstate(_St);
        return (_O); }
#line 552
};
#line 277 "/usr/vacpp/include/ostream"
#pragma namemangling(pop)

#pragma object_model(pop)
#line 286
#pragma info(none)

#  pragma report(pop)

#pragma info(restore)
#line 77 "/usr/vacpp/include/istream"
namespace std {
#line 87
template<class _E, class _Tr>
        class basic_istream : virtual public basic_ios<_E, _Tr> {
public:
        typedef basic_istream<_E, _Tr> _Myt;
        typedef basic_ios<_E, _Tr> _Myios;
        typedef basic_streambuf<_E, _Tr> _Mysb;
        typedef istreambuf_iterator<_E, _Tr> _Iter;
        typedef ctype<_E> _Ctype;
        typedef num_get<_E, _Iter> _Nget;
        explicit basic_istream(_Mysb *_S, bool _Isstd = false,
                bool _Noinit = false)
                : _Chcount(0)
                {if (!_Noinit)
                        _Myios::init(_S, _Isstd); }
        basic_istream(_Uninitialized)
                {ios_base::_Addstd(); }
        virtual ~basic_istream()
                {}
        typedef typename _Tr::int_type int_type;
        typedef typename _Tr::pos_type pos_type;
        typedef typename _Tr::off_type off_type;
        class sentry {
        public:
                explicit sentry(_Myt& _Is, bool _Noskip = false)
#line 114
                        : _Lk(_Lockit::_Str)

                        { _Ok = _Is._DoTie(_Noskip, -1); }
                explicit sentry(_Myt& _Is, bool _Noskip, streamsize _N)
#line 121
                        : _Lk(_Lockit::_Str)

                        { _Ok = _Is._DoTie(_Noskip, _N); }
                operator bool() const
                        {return (_Ok); }
        private:
                sentry(const sentry&);   
                sentry& operator=(const sentry&);        
                bool _Ok;
                _Lockit _Lk;
                };
        bool ipfx(bool _Noskip = false);
        void isfx()
                {}
        _Myt& operator>>(_Myt& (*_F)(_Myt&))
                {return ((*_F)(*this)); }
        _Myt& operator>>(_Myios& (*_F)(_Myios&))
                {(*_F)(*(_Myios *)this);
                return (*this); }
        _Myt& operator>>(ios_base& (*_F)(ios_base&))
                {(*_F)(*(ios_base *)this);
                return (*this); }
        _Myt& operator>>(_Bool& _X);
        _Myt& operator>>(short& _X);
        _Myt& operator>>(unsigned short& _X);
        _Myt& operator>>(int& _X);
        _Myt& operator>>(unsigned int& _X);
        _Myt& operator>>(long& _X);
        _Myt& operator>>(unsigned long& _X);

        _Myt& operator>>(long long& _X);
        _Myt& operator>>(unsigned long long& _X);

        _Myt& operator>>(float& _X);
        _Myt& operator>>(double& _X);
        _Myt& operator>>(long double& _X);
        _Myt& operator>>(void *& _X);
        _Myt& operator>>(_Mysb *_Pb);
        int_type get();
        _Myt& get(_E *_S, streamsize _N)
                {return (get(_S, _N, _Myios::widen('\n'))); }
        _Myt& get(_E *_S, streamsize _N, _E _D);
        _Myt& get(_E& _X)
                {int_type _C = get();
                if (!_Tr::eq_int_type(_Tr::eof(), _C))
                        _X = _Tr::to_char_type(_C);
                return (*this); }
        _Myt& get(_Mysb& _Sb)
                {return (get(_Sb, _Myios::widen('\n'))); }
        _Myt& get(_Mysb& _Sb, _E _D);
        _Myt& getline(_E *_S, streamsize _N)
                {return (getline(_S, _N, _Myios::widen('\n'))); }
        _Myt& getline(_E *_S, streamsize _N, _E _D);
        _Myt& ignore(streamsize _N = 1, int_type _Di = _Tr::eof());
        _Myt& read(_E *_S, streamsize _N);
        streamsize readsome(_E *_S, streamsize _N);
        int_type peek();
        _Myt& putback(_E _X);
        _Myt& unget();
        streamsize gcount() const
                {return (_Chcount); }
        int sync();
        _Myt& seekg(pos_type _P)
                 {if ((!ios_base::fail()) && (!ios_base::eof()))
                        if (_Myios::rdbuf()->pubseekpos(_P, ios_base::in)
                            == streampos(_BADOFF))
                            _Myios::setstate(ios_base::failbit);
                return (*this); }
        _Myt& seekg(off_type _O, ios_base::seekdir _W)
                 {if ((!ios_base::fail()) && (!ios_base::eof()))
                        if (_Myios::rdbuf()->pubseekoff(_O, _W, ios_base::in)
                            == streampos(_BADOFF))
                            _Myios::setstate(ios_base::failbit);
                return (*this); }
        pos_type tellg()
               {if ((!ios_base::fail()) && (!ios_base::eof()))
                        return (_Myios::rdbuf()->pubseekoff(0,
                                ios_base::cur, ios_base::in));
                else
                        return (pos_type(_BADOFF)); }
private:
        bool _DoTie(bool _Noskip, streamsize _N);
        streamsize _Chcount;
        };
#line 207
template<class _E, class _Tr>
        class basic_iostream : public basic_istream<_E, _Tr>,
                public basic_ostream<_E, _Tr> {
public:
        explicit basic_iostream(basic_streambuf<_E, _Tr> *_S)
                : basic_istream<_E, _Tr>(_S, false, true),
                        basic_ostream<_E, _Tr>(_S)
                {}
        virtual ~basic_iostream()
                {}
        };
#line 220
template<class _E, class _Tr>
        basic_istream<_E, _Tr>& operator>>(
                basic_istream<_E, _Tr>& _I, _E *_X);

template<class _E, class _Tr>
        basic_istream<_E, _Tr>& operator>>(
                basic_istream<_E, _Tr>& _I, _E& _X);

template<class _Tr> inline
        basic_istream<char, _Tr>& operator>>(
                basic_istream<char, _Tr>& _I, signed char *_X)
        {return (_I >> (char *)_X); }
template<class _Tr> inline
        basic_istream<char, _Tr>& operator>>(
                basic_istream<char, _Tr>& _I, signed char& _C)
        {return (_I >> (char&)_C); }
template<class _Tr> inline
        basic_istream<char, _Tr>& operator>>(
                basic_istream<char, _Tr>& _I, unsigned char *_X)
        {return (_I >> (char *)_X); }
template<class _Tr> inline
        basic_istream<char, _Tr>& operator>>(
                basic_istream<char, _Tr>& _I, unsigned char& _C)
        {return (_I >> (char&)_C); }
#line 246
template<class _E, class _Tr>
        basic_istream<_E, _Tr>&
                ws(basic_istream<_E, _Tr>& _I);
#line 255
};

#pragma implementation("istream.t")
#line 32 "/usr/vacpp/include/istream.t"
namespace std {
#line 37
template<class _E, class _Tr>
inline
bool basic_istream<_E, _Tr>::_DoTie(bool _Noskip, streamsize _N)
         {if (ios_base::good())
                 {if ((_Myios::tie() != 0) &&
                      (_Myios::rdbuf()->in_avail() < _N))
                          _Myios::tie()->flush(); }
                 return ipfx(_Noskip); }

template<class _E, class _Tr>
inline
bool basic_istream<_E, _Tr>::ipfx(bool _Noskip)
         {if (ios_base::good())
                 {if (!_Noskip && ios_base::flags() & ios_base::skipws)
                         {const _Ctype& _Fac =
                                 use_facet<_Ctype >(ios_base::getloc());
                         try {
                         int_type _C = _Myios::rdbuf()->sgetc();
                         for (; ; _C = _Myios::rdbuf()->snextc())
                                 if (_Tr::eq_int_type(_Tr::eof(), _C))
                                         {_Myios::setstate(ios_base::eofbit);
                                         break; }
                                 else if (!_Fac.is(_Ctype::space,
                                         _Tr::to_char_type(_C)))
                                         break;
                         } catch (...) { _Myios::setstate(ios_base::badbit, true); } }
                 if (ios_base::good())
                         return (true); }
         _Myios::setstate(ios_base::failbit);
         return (false); }
#line 69
template<class _E, class _Tr>
inline
typename basic_istream<_E, _Tr>::_Myt&
basic_istream<_E, _Tr>::operator>>(_Bool& _X)
         {ios_base::iostate _St = ios_base::goodbit;
         const sentry _Ok(*this);
         if (_Ok)
                 {const _Nget& _Fac = use_facet<_Nget >(ios_base::getloc());
                 try {
                 _Fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
                         *this, _St, _X);
                 } catch (...) { _Myios::setstate(ios_base::badbit, true); } }
         _Myios::setstate(_St);
         return (*this); }

template<class _E, class _Tr>
inline
typename basic_istream<_E, _Tr>::_Myt&
basic_istream<_E, _Tr>::operator>>(short& _X)
         {ios_base::iostate _St = ios_base::goodbit;
         const sentry _Ok(*this);
         if (_Ok)
                 {long _Y;
                 const _Nget& _Fac = use_facet<_Nget >(ios_base::getloc());
                 try {
                 _Fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
                         *this, _St, _Y);
                 } catch (...) { _Myios::setstate(ios_base::badbit, true); }
                 if (_St & ios_base::failbit)
                         ;
                 else if (_Y > (32767))
                         {_X = (32767);
                         errno = 34; }
                 else if (_Y < (-(32767) - 1))
                         {_X = (-(32767) - 1);
                         errno = 34; }
                 else
                         _X = (short)_Y; }
         _Myios::setstate(_St);
         return (*this); }

template<class _E, class _Tr>
inline
typename basic_istream<_E, _Tr>::_Myt&
basic_istream<_E, _Tr>::operator>>(unsigned short& _X)
         {ios_base::iostate _St = ios_base::goodbit;
         const sentry _Ok(*this);
         if (_Ok)
                 {const _Nget& _Fac = use_facet<_Nget >(ios_base::getloc());
                 try {
                 _Fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
                         *this, _St, _X);
                 } catch (...) { _Myios::setstate(ios_base::badbit, true); } }
         _Myios::setstate(_St);
         return (*this); }
#line 126
template<class _E, class _Tr>
inline
typename basic_istream<_E, _Tr>::_Myt&
basic_istream<_E, _Tr>::operator>>(int& _X)
         {ios_base::iostate _St = ios_base::goodbit;
         const sentry _Ok(*this);
         if (_Ok)
                 {long _Y;
                 const _Nget& _Fac = use_facet<_Nget >(ios_base::getloc());
                 try {
                 _Fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
                         *this, _St, _Y);
                 } catch (...) { _Myios::setstate(ios_base::badbit, true); }
                 if (_St & ios_base::failbit)
                         ;
#line 149
                 else
                         _X = (int)_Y; }
         _Myios::setstate(_St);
         return (*this); }

template<class _E, class _Tr>
inline
typename basic_istream<_E, _Tr>::_Myt&
basic_istream<_E, _Tr>::operator>>(unsigned int& _X)
         {ios_base::iostate _St = ios_base::goodbit;
         const sentry _Ok(*this);
         if (_Ok)
                 {const _Nget& _Fac = use_facet<_Nget >(ios_base::getloc());
                 try {
                 _Fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
                         *this, _St, _X);
                 } catch (...) { _Myios::setstate(ios_base::badbit, true); } }
         _Myios::setstate(_St);
         return (*this); }

template<class _E, class _Tr>
inline
typename basic_istream<_E, _Tr>::_Myt&
basic_istream<_E, _Tr>::operator>>(long& _X)
         {ios_base::iostate _St = ios_base::goodbit;
         const sentry _Ok(*this);
         if (_Ok)
                 {const _Nget& _Fac = use_facet<_Nget >(ios_base::getloc());
                 try {
                 _Fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
                         *this, _St, _X);
                 } catch (...) { _Myios::setstate(ios_base::badbit, true); } }
         _Myios::setstate(_St);
         return (*this); }
#line 185
template<class _E, class _Tr>
inline
typename basic_istream<_E, _Tr>::_Myt&
basic_istream<_E, _Tr>::operator>>(unsigned long& _X)
         {ios_base::iostate _St = ios_base::goodbit;
         const sentry _Ok(*this);
         if (_Ok)
                 {const _Nget& _Fac = use_facet<_Nget >(ios_base::getloc());
                 try {
                 _Fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
                         *this, _St, _X);
                 } catch (...) { _Myios::setstate(ios_base::badbit, true); } }
         _Myios::setstate(_St);
         return (*this); }
#line 202
template<class _E, class _Tr>
inline
typename basic_istream<_E, _Tr>::_Myt&
basic_istream<_E, _Tr>::operator>>(long long& _X)
         {ios_base::iostate _St = ios_base::goodbit;
         const sentry _Ok(*this);
         if (_Ok)
                 {const _Nget& _Fac = use_facet<_Nget >(ios_base::getloc());
                 try {
                 _Fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
                         *this, _St, _X);
                 } catch (...) { _Myios::setstate(ios_base::badbit, true); } }
         _Myios::setstate(_St);
         return (*this); }

template<class _E, class _Tr>
inline
typename basic_istream<_E, _Tr>::_Myt&
basic_istream<_E, _Tr>::operator>>(unsigned long long& _X)
         {ios_base::iostate _St = ios_base::goodbit;
         const sentry _Ok(*this);
         if (_Ok)
                 {const _Nget& _Fac = use_facet<_Nget >(ios_base::getloc());
                 try {
                 _Fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
                         *this, _St, _X);
                 } catch (...) { _Myios::setstate(ios_base::badbit, true); } }
         _Myios::setstate(_St);
         return (*this); }
#line 233
template<class _E, class _Tr>
inline
typename basic_istream<_E, _Tr>::_Myt&
basic_istream<_E, _Tr>::operator>>(float& _X)
         {ios_base::iostate _St = ios_base::goodbit;
         const sentry _Ok(*this);
         if (_Ok)
                 {const _Nget& _Fac = use_facet<_Nget >(ios_base::getloc());
                 try {
                 _Fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
                         *this, _St, _X);
                 } catch (...) { _Myios::setstate(ios_base::badbit, true); } }
         _Myios::setstate(_St);
         return (*this); }

template<class _E, class _Tr>
inline
typename basic_istream<_E, _Tr>::_Myt&
basic_istream<_E, _Tr>::operator>>(double& _X)
         {ios_base::iostate _St = ios_base::goodbit;
         const sentry _Ok(*this);
         if (_Ok)
                 {const _Nget& _Fac = use_facet<_Nget >(ios_base::getloc());
                 try {
                 _Fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
                         *this, _St, _X);
                 } catch (...) { _Myios::setstate(ios_base::badbit, true); } }
         _Myios::setstate(_St);
         return (*this); }

template<class _E, class _Tr>
inline
typename basic_istream<_E, _Tr>::_Myt&
basic_istream<_E, _Tr>::operator>>(long double& _X)
         {ios_base::iostate _St = ios_base::goodbit;
         const sentry _Ok(*this);
         if (_Ok)
                 {const _Nget& _Fac = use_facet<_Nget >(ios_base::getloc());
                 try {
                 _Fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
                         *this, _St, _X);
                 } catch (...) { _Myios::setstate(ios_base::badbit, true); } }
         _Myios::setstate(_St);
         return (*this); }

template<class _E, class _Tr>
inline
typename basic_istream<_E, _Tr>::_Myt&
basic_istream<_E, _Tr>::operator>>(void *& _X)
         {ios_base::iostate _St = ios_base::goodbit;
         const sentry _Ok(*this);
         if (_Ok)
                 {const _Nget& _Fac = use_facet<_Nget >(ios_base::getloc());
                 try {
                 _Fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
                         *this, _St, _X);
                 } catch (...) { _Myios::setstate(ios_base::badbit, true); } }
         _Myios::setstate(_St);
         return (*this); }
#line 294
template<class _E, class _Tr>
inline
typename basic_istream<_E, _Tr>::_Myt&
basic_istream<_E, _Tr>::operator>>(_Mysb *_Pb)
         {ios_base::iostate _St = ios_base::goodbit;
         bool _Copied = false;
         const sentry _Ok(*this);
         if (_Ok && _Pb != 0)
                 {try {
                 int_type _C = _Myios::rdbuf()->sgetc();
                 for (; ; _C = _Myios::rdbuf()->snextc())
                         if (_Tr::eq_int_type(_Tr::eof(), _C))
                                 {_St |= ios_base::eofbit;
                                 break; }
                         else
                                 {try {
                                         if (_Tr::eq_int_type(_Tr::eof(),
                                                 _Pb->sputc(_Tr::to_char_type(_C))))
                                                 break;
                                 } catch (...) {
                                         break;
                                 }
                                 _Copied = true; }
                 } catch (...) {
                         _Myios::setstate(ios_base::badbit, true);
                         if (!_Copied &&
                             (_Myios::exceptions() & ios_base::failbit))
                         {_Myios::setstate(_St | ios_base::failbit);
                          throw; }
                 }
                 }
         _Myios::setstate(!_Copied
                 ? _St | ios_base::failbit : _St);
         return (*this); }
#line 330
template<class _E, class _Tr>
inline
typename basic_istream<_E, _Tr>::int_type basic_istream<_E, _Tr>::get()
         {int_type _C;
         ios_base::iostate _St = ios_base::goodbit;
         _Chcount = 0;
         const sentry _Ok(*this, true, 1);
         if (!_Ok)
                 _C = _Tr::eof();
         else
                 {try {
                 _C = _Myios::rdbuf()->sbumpc();
                 if (_Tr::eq_int_type(_Tr::eof(), _C))
                         _St |= ios_base::eofbit | ios_base::failbit;
                 else
                         ++_Chcount;
                 } catch (...) { _Myios::setstate(ios_base::badbit, true); } }
         _Myios::setstate(_St);
         return (_C); }

template<class _E, class _Tr>
inline
typename basic_istream<_E, _Tr>::_Myt&
basic_istream<_E, _Tr>::get(_E *_S, streamsize _N, _E _D)
         {ios_base::iostate _St = ios_base::goodbit;
         _Chcount = 0;
         const sentry _Ok(*this, true, _N);
         if (_Ok && 0 < _N)
                 {try {
                 int_type _C = _Myios::rdbuf()->sgetc();
                 for (; 0 < --_N; _C = _Myios::rdbuf()->snextc())
                         if (_Tr::eq_int_type(_Tr::eof(), _C))
                                 {_St |= ios_base::eofbit;
                                 break; }
                         else if (_Tr::to_char_type(_C) == _D)
                                 break;
                         else
                                 *_S++ = _Tr::to_char_type(_C), ++_Chcount;
                 } catch (...) { _Myios::setstate(ios_base::badbit, true); } }
         _Myios::setstate(_Chcount == 0
                 ? _St | ios_base::failbit : _St);
         *_S = _E();
         return (*this); }
#line 375
template<class _E, class _Tr>
inline
typename basic_istream<_E, _Tr>::_Myt&
basic_istream<_E, _Tr>::get(_Mysb& _Sb, _E _D)
         {ios_base::iostate _St = ios_base::goodbit;
         _Chcount = 0;
         const sentry _Ok(*this, true);
         if (_Ok)
                 {try {
                 int_type _C = _Myios::rdbuf()->sgetc();
                 for (; ; _C = _Myios::rdbuf()->snextc())
                         if (_Tr::eq_int_type(_Tr::eof(), _C))
                                 {_St |= ios_base::eofbit;
                                 break; }
                         else
                                 {try {
                                         _E _Ch = _Tr::to_char_type(_C);
                                         if (_Ch == _D
                                                 || _Tr::eq_int_type(_Tr::eof(),
                                                         _Sb.sputc(_Ch)))
                                                 break;
                                 } catch (...) {
                                         break;
                                 }
                                 ++_Chcount; }
                 } catch (...) { _Myios::setstate(ios_base::badbit, true); } }
         if (_Chcount == 0)
                 _St |= ios_base::failbit;
         _Myios::setstate(_St);
         return (*this); }
#line 407
template<class _E, class _Tr>
inline
typename basic_istream<_E, _Tr>::_Myt&
basic_istream<_E, _Tr>::getline(_E *_S, streamsize _N, _E _D)
         {ios_base::iostate _St = ios_base::goodbit;
         _Chcount = 0;
         const sentry _Ok(*this, true, _N);
         const streamsize _OriginalN = _N;
         if (_Ok)
                 {int_type _Di = _Tr::to_int_type(_D);
                 try {
                 int_type _C = _Myios::rdbuf()->sgetc();
                 for (; ; _C = _Myios::rdbuf()->snextc())
                         if (_Tr::eq_int_type(_Tr::eof(), _C))
                                 {_St |= ios_base::eofbit;
                                 break; }
                         else if (_C == _Di)
                                 {++_Chcount;
                                 _Myios::rdbuf()->sbumpc();
                                 break; }
                         else if (0 < _N)
                                 {if (--_N == 0)
                                         {_St |= ios_base::failbit;
                                         break; }
                                 else
                                         {++_Chcount;
                                         *_S++ = _Tr::to_char_type(_C); }}
                         else break;
                 } catch (...) { _Myios::setstate(ios_base::badbit, true); } }
         if (0 < _OriginalN)
                 *_S = _E();
         _Myios::setstate(_Chcount == 0
                 ? _St | ios_base::failbit : _St);
         return (*this); }
#line 443
template<class _E, class _Tr>
inline
typename basic_istream<_E, _Tr>::_Myt&
basic_istream<_E, _Tr>::ignore(streamsize _N, int_type _Di)
         {ios_base::iostate _St = ios_base::goodbit;
         _Chcount = 0;
         const sentry _Ok(*this, true, _N);
         if (_Ok && 0 < _N)
                 {try {
                 for (; ; )
                         {int_type _C;
                         if (_N != (2147483647) && --_N < 0)
                                 break;
                         else if (_Tr::eq_int_type(_Tr::eof(),
                                 _C = _Myios::rdbuf()->sbumpc()))
                                 {_St |= ios_base::eofbit;
                                 break; }
                         else
                                 {++_Chcount;
                                 if (_C == _Di)
                                         break; }}
                 } catch (...) { _Myios::setstate(ios_base::badbit, true); } }
         _Myios::setstate(_St);
         return (*this); }

template<class _E, class _Tr>
inline
typename basic_istream<_E, _Tr>::_Myt&
basic_istream<_E, _Tr>::read(_E *_S, streamsize _N)
         {ios_base::iostate _St = ios_base::goodbit;
         _Chcount = 0;
         const sentry _Ok(*this, true, _N);
         if (_Ok)
                 {try {
                 const streamsize _M = _Myios::rdbuf()->sgetn(_S, _N);
                 _Chcount += _M;
                 if (_M != _N)
                         _St |= ios_base::eofbit | ios_base::failbit;
                 } catch (...) { _Myios::setstate(ios_base::badbit, true); } }
         _Myios::setstate(_St);
         return (*this); }

template<class _E, class _Tr>
inline
streamsize basic_istream<_E, _Tr>::readsome(_E *_S, streamsize _N)
         {ios_base::iostate _St = ios_base::goodbit;
         _Chcount = 0;
         const sentry _Ok(*this, true, _N);
         int _M;
         if (_Myios::rdbuf() == 0)
                 _St |= ios_base::failbit;
         else if ((_M = _Myios::rdbuf()->in_avail()) < 0)
                 _St |= ios_base::eofbit;
         else if (0 < _M)
                 read(_S, _M < _N ? _M : _N);
         _Myios::setstate(_St);
         return (gcount()); }

template<class _E, class _Tr>
inline
typename basic_istream<_E, _Tr>::int_type basic_istream<_E, _Tr>::peek()
         {ios_base::iostate _St = ios_base::goodbit;
         _Chcount = 0;
         int_type _C;
         const sentry _Ok(*this, true, 1);
         if (!_Ok)
                 _C = _Tr::eof();
         else
                 {try {
                 if (_Tr::eq_int_type(_Tr::eof(),
                         _C = _Myios::rdbuf()->sgetc()))
                         _St |= ios_base::eofbit;
                 } catch (...) { _Myios::setstate(ios_base::badbit, true); } }
         _Myios::setstate(_St);
         return (_C); }

template<class _E, class _Tr>
inline
typename basic_istream<_E, _Tr>::_Myt& basic_istream<_E, _Tr>::putback(_E _X)
         {ios_base::iostate _St = ios_base::goodbit;
         _Chcount = 0;
         const sentry _Ok(*this, true);
         if (_Ok)
                 {try {
                 if (_Tr::eq_int_type(_Tr::eof(),
                         _Myios::rdbuf()->sputbackc(_X)))
                         _St |= ios_base::badbit;
                 } catch (...) { _Myios::setstate(ios_base::badbit, true); } }
         _Myios::setstate(_St);
         return (*this); }

template<class _E, class _Tr>
inline
typename basic_istream<_E, _Tr>::_Myt& basic_istream<_E, _Tr>::unget()
         {ios_base::iostate _St = ios_base::goodbit;
         _Chcount = 0;
         const sentry _Ok(*this, true);
         if (_Ok)
                 {try {
                 if (_Tr::eq_int_type(_Tr::eof(),
                         _Myios::rdbuf()->sungetc()))
                         _St |= ios_base::badbit;
                 } catch (...) { _Myios::setstate(ios_base::badbit, true); } }
         _Myios::setstate(_St);
         return (*this); }

template<class _E, class _Tr>
inline
int basic_istream<_E, _Tr>::sync()
         {ios_base::iostate _St = ios_base::goodbit;
         int _Ans;
         if (_Myios::rdbuf() == 0)
                 _Ans = -1;
         else if (_Myios::rdbuf()->pubsync() == -1)
                 _St |= ios_base::badbit, _Ans = -1;
         else
                 _Ans = 0;
         _Myios::setstate(_St);
         return (_Ans); }
#line 564
template<class _E, class _Tr>
inline
basic_istream<_E, _Tr>& operator>>(
                basic_istream<_E, _Tr>& _I, _E *_X)
        {typedef basic_istream<_E, _Tr> _Myis;
        typedef ctype<_E> _Ctype;
        ios_base::iostate _St = ios_base::goodbit;
        _E *_S = _X;
        const typename _Myis::sentry _Ok(_I);
        if (_Ok)
                {const _Ctype& _Fac = use_facet<_Ctype >(_I.getloc());
                try {
                int _N = 0 < _I.width() ? _I.width() : (2147483647);
                typename _Myis::int_type _C = _I.rdbuf()->sgetc();
                for (; 0 < --_N; _C = _I.rdbuf()->snextc())
                        if (_Tr::eq_int_type(_Tr::eof(), _C))
                                {_St |= ios_base::eofbit;
                                break; }
                        else if (_Fac.is(_Ctype::space,
                                _Tr::to_char_type(_C)))
                                break;
                        else
                                *_S++ = _Tr::to_char_type(_C);
                } catch (...) { (_I).setstate(ios_base::badbit, true); } }
        *_S = _E();
        _I.width(0);
        _I.setstate(_S == _X ? _St | ios_base::failbit : _St);
        return (_I); }
#line 604
template<class _E, class _Tr>
inline
basic_istream<_E, _Tr>& operator>>(
                basic_istream<_E, _Tr>& _I, _E& _X)
        {typedef basic_istream<_E, _Tr> _Myis;
        typename _Myis::int_type _C;
        ios_base::iostate _St = ios_base::goodbit;
        const typename _Myis::sentry _Ok(_I);
        if (_Ok)
                {try {
                _C = _I.rdbuf()->sbumpc();
                if (_Tr::eq_int_type(_Tr::eof(), _C))
                        _St |= ios_base::eofbit | ios_base::failbit;
                else
                        _X = _Tr::to_char_type(_C);
                } catch (...) { (_I).setstate(ios_base::badbit, true); } }
        _I.setstate(_St);
        return (_I); }

template<class _E, class _Tr>
inline
basic_istream<_E, _Tr>&
                ws(basic_istream<_E, _Tr>& _I)
        {typedef basic_istream<_E, _Tr> _Myis;
        typedef ctype<_E> _Ctype;
        ios_base::iostate _St = ios_base::goodbit;
        const typename _Myis::sentry _Ok(_I, true);
        if (_Ok)
                {const _Ctype& _Fac = use_facet<_Ctype >(_I.getloc());
                try {
                for (typename _Tr::int_type _C = _I.rdbuf()->sgetc(); ;
                        _C = _I.rdbuf()->snextc())
                        if (_Tr::eq_int_type(_Tr::eof(), _C))
                                {_St |= ios_base::eofbit;
                                break; }
                        else if (!_Fac.is(_Ctype::space,
                                _Tr::to_char_type(_C)))
                                break;
                } catch (...) { (_I).setstate(ios_base::badbit, true); } }
        _I.setstate(_St);
        return (_I); }
#line 655
};
#line 263 "/usr/vacpp/include/istream"
#pragma namemangling()

#pragma object_model(pop)
#line 272
#pragma info(none)

#  pragma report(pop)

#pragma info(restore)
#line 76 "/usr/vacpp/include/iostream"
namespace std {
#line 81
extern istream  cin;
extern ostream  cout;
extern ostream  cerr, clog;

class  _Winit {
public:
        _Winit();
        ~_Winit();
private:
        static int _Init_cnt;
        };

extern wistream  wcin;
extern wostream  wcout, wcerr, wclog;
#line 101
};

#pragma namemangling()

#pragma object_model(pop)
#line 112
#pragma info(none)

#  pragma report(pop)

#pragma info(restore)
#line 11 "getSysCfg.h"
class getSysCfg {
public:
	getSysCfg();

	virtual ~getSysCfg();
	void print();
};
extern "C" {
#line 45 "/usr/include/sys/systemcfg.h"
extern struct {
	int architecture;	 
	int implementation;	 
	int version;		 
	int width;		 
	int ncpus;		 
	int cache_attrib;	 
#line 56
	int icache_size;	 
	int dcache_size;	 
	int icache_asc;		 
	int dcache_asc;		 
	int icache_block;	 
	int dcache_block;	 
	int icache_line;	 
	int dcache_line;	 
	int L2_cache_size;	 
	int L2_cache_asc;	 
	int tlb_attrib;		 
#line 71
	int itlb_size;		 
	int dtlb_size;		 
	int itlb_asc;		 
	int dtlb_asc;		 
	int resv_size;		 
	int priv_lck_cnt;	 
	int prob_lck_cnt;	 
	int rtc_type;		 
	int virt_alias;		 
	int cach_cong;		 
	int model_arch;		 
	int model_impl;		 
	int Xint;		 
	int Xfrac;		 
	int kernel;		 
#line 100
	long long physmem;	 
	int slb_attr;		 
#line 105
	int slb_size;		 
	int original_ncpus;	 
	int max_ncpus;		 
	long long maxrealaddr;	 
	long long original_entitled_capacity;
#line 113
	long long entitled_capacity;  
	long long dispatch_wheel;  
	int capacity_increment;	 
	int variable_capacity_weight;	 

	int splpar_status;	 
#line 122
	int smt_status;		 
#line 126
	int smt_threads;	 
        int vmx_version;         
	long long sys_lmbsize;	 
	int num_xcpus;		 
	signed char errchecklevel; 
	char eco_status;	 
	char pad[2];		 
        int dfp_version;         

	int vrm_status;		 
	short phys_implementation;	 
	short phys_version;	 
}_system_configuration;
}
#line 11 "getSysCfg.cpp"
int main(int argc, char * argv[]){
	getSysCfg * a= new getSysCfg();
	a->print();
	return (0);
}
getSysCfg::getSysCfg() {
#line 19
}

getSysCfg::~getSysCfg() {

}

void getSysCfg::print(){
	std::cout<<_system_configuration.phys_implementation<<std::endl;
}
